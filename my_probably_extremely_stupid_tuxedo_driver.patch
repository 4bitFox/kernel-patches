diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/clevo_acpi.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_acpi.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/clevo_acpi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_acpi.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,274 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/version.h>
+#include "clevo_interfaces.h"
+
+#define DRIVER_NAME			"clevo_acpi"
+
+struct clevo_acpi_driver_data_t {
+	struct acpi_device *adev;
+	struct clevo_interface_t *clevo_interface;
+};
+
+static struct clevo_acpi_driver_data_t *active_driver_data = NULL;
+
+static int clevo_acpi_evaluate(struct acpi_device *device, u8 cmd, u32 arg, union acpi_object **result)
+{
+	int status;
+	acpi_handle handle;
+	u64 dsm_rev_dummy = 0x00; // Dummy 0 value since not used
+	u64 dsm_func = cmd;
+	union acpi_object *out_obj;
+	guid_t clevo_acpi_dsm_uuid;
+
+	// Integer package data for argument
+	union acpi_object dsm_argv4_package_data[] = {
+		{
+			.integer.type = ACPI_TYPE_INTEGER,
+			.integer.value = arg
+		}
+	};
+
+	// Package argument
+	union acpi_object dsm_argv4 = {
+		.package.type = ACPI_TYPE_PACKAGE,
+		.package.count = 1,
+		.package.elements = dsm_argv4_package_data
+	};
+
+	status = guid_parse(CLEVO_ACPI_DSM_UUID, &clevo_acpi_dsm_uuid);
+	if (status < 0)
+		return -ENOENT;
+
+	handle = acpi_device_handle(device);
+	if (handle == NULL)
+		return -ENODEV;
+
+	out_obj = acpi_evaluate_dsm(handle, &clevo_acpi_dsm_uuid, dsm_rev_dummy, dsm_func, &dsm_argv4);
+	if (!out_obj) {
+		pr_err("failed to evaluate _DSM\n");
+		status = -1;
+	}
+	else {
+		if (!IS_ERR_OR_NULL(result)) {
+			*result = out_obj;
+		}
+	}
+
+	return status;
+}
+
+static int clevo_acpi_evaluate_pkgbuf(struct acpi_device *device, u8 cmd, u8 *arg, u32 length, union acpi_object **result)
+{
+	int status;
+	acpi_handle handle;
+	u64 dsm_rev_dummy = 0x00; // Dummy 0 value since not used
+	u64 dsm_func = cmd;
+
+	// Use a buffer inside a package
+	union acpi_object args = {
+		.buffer.type = ACPI_TYPE_BUFFER,
+		.buffer.length = length,
+		.buffer.pointer = arg,
+	};
+
+	// Package argument
+	union acpi_object dsm_argv4 = {
+		.package.type = ACPI_TYPE_PACKAGE,
+		.package.count = 1,
+		.package.elements = &args,
+	};
+
+	union acpi_object *out_obj;
+
+	guid_t clevo_acpi_dsm_uuid;
+
+	status = guid_parse(CLEVO_ACPI_DSM_UUID, &clevo_acpi_dsm_uuid);
+	if (status < 0)
+		return -ENOENT;
+
+	handle = acpi_device_handle(device);
+	if (handle == NULL)
+		return -ENODEV;
+
+	out_obj = acpi_evaluate_dsm(handle, &clevo_acpi_dsm_uuid, dsm_rev_dummy, dsm_func, &dsm_argv4);
+	if (!out_obj) {
+		pr_err("failed to evaluate _DSM\n");
+		status = -1;
+	}
+	else {
+		if (!IS_ERR_OR_NULL(result)) {
+			*result = out_obj;
+		}
+	}
+
+	return status;
+}
+
+static int clevo_acpi_interface_method_call(u8 cmd, u32 arg, union acpi_object **result_value)
+{
+	int status = 0;
+
+	if (!IS_ERR_OR_NULL(active_driver_data)) {
+		status = clevo_acpi_evaluate(active_driver_data->adev, cmd, arg, result_value);
+	} else {
+		pr_err("acpi method call exec, no driver data found\n");
+		pr_err("..for method_call: %0#4x arg: %0#10x\n", cmd, arg);
+		status = -ENODATA;
+	}
+	// pr_debug("clevo_acpi method_call: %0#4x arg: %0#10x result: %0#10x\n", cmd, arg, !IS_ERR_OR_NULL(result_value) ? *result_value : 0);
+
+	return status;
+}
+
+static int clevo_acpi_interface_method_call_pkgbuf(u8 cmd, u8 *arg, u32 length, union acpi_object **result_value)
+{
+	int status = 0;
+
+	if (!IS_ERR_OR_NULL(active_driver_data)) {
+		status = clevo_acpi_evaluate_pkgbuf(active_driver_data->adev, cmd, arg, length, result_value);
+	} else {
+		pr_err("acpi method call exec, no driver data found\n");
+		pr_err("..for method_call: %0#2x\n", cmd);
+		status = -ENODATA;
+	}
+
+	return status;
+}
+
+struct clevo_interface_t clevo_acpi_interface = {
+	.string_id = CLEVO_INTERFACE_ACPI_STRID,
+	.method_call = clevo_acpi_interface_method_call,
+	.method_call_pkgbuf = clevo_acpi_interface_method_call_pkgbuf,
+};
+
+static int clevo_acpi_add(struct acpi_device *device)
+{
+	struct clevo_acpi_driver_data_t *driver_data;
+
+	driver_data = devm_kzalloc(&device->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	driver_data->adev = device;
+	driver_data->clevo_interface = &clevo_acpi_interface;
+
+	active_driver_data = driver_data;
+
+	pr_debug("clevo_acpi driver add\n");
+
+	// Add this interface
+	clevo_keyboard_add_interface(&clevo_acpi_interface);
+
+	pr_info("interface initialized\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int clevo_acpi_remove(struct acpi_device *device)
+#else
+static void clevo_acpi_remove(struct acpi_device *device)
+#endif
+{
+	pr_debug("clevo_acpi driver remove\n");
+	clevo_keyboard_remove_interface(&clevo_acpi_interface);
+	active_driver_data = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+	return 0;
+#endif
+}
+
+static void clevo_acpi_notify(struct acpi_device *device, u32 event)
+{
+	u32 event_value;
+	union acpi_object *out_obj;
+	int status;
+	// struct clevo_acpi_driver_data_t *clevo_acpi_driver_data;
+
+	status = clevo_acpi_evaluate(device, 0x01, 0, &out_obj);
+	if (!status) {
+			if (out_obj->type == ACPI_TYPE_INTEGER) {
+				event_value = (u32)out_obj->integer.value;
+			} else {
+				pr_err("return type not integer, use clevo_evaluate_method2\n");
+			}
+			ACPI_FREE(out_obj);
+	}
+	pr_debug("clevo_acpi event: %0#6x, clevo event value: %0#6x\n", event, event_value);
+
+	// clevo_acpi_driver_data = container_of(&device, struct clevo_acpi_driver_data_t, adev);
+	if (!IS_ERR_OR_NULL(clevo_acpi_interface.event_callb)) {
+		// Execute registered callback
+		clevo_acpi_interface.event_callb(event);
+	}
+}
+
+#ifdef CONFIG_PM
+static int driver_suspend_callb(struct device *dev)
+{
+	pr_debug("driver suspend\n");
+	return 0;
+}
+
+static int driver_resume_callb(struct device *dev)
+{
+	pr_debug("driver resume\n");
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(clevo_driver_pm_ops, driver_suspend_callb, driver_resume_callb);
+#endif
+
+static const struct acpi_device_id clevo_acpi_device_ids[] = {
+	{CLEVO_ACPI_RESOURCE_HID, 0},
+	{"", 0}
+};
+
+static struct acpi_driver clevo_acpi_driver = {
+	.name = DRIVER_NAME,
+	.class = DRIVER_NAME,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 10, 0)
+	.owner = THIS_MODULE,
+#endif
+	.ids = clevo_acpi_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
+	.ops = {
+		.add = clevo_acpi_add,
+		.remove = clevo_acpi_remove,
+		.notify = clevo_acpi_notify,
+	},
+#ifdef CONFIG_PM
+	.drv.pm = &clevo_driver_pm_ops
+#endif
+};
+
+module_acpi_driver(clevo_acpi_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for Clevo ACPI interface");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(acpi, clevo_acpi_device_ids);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/clevo_interfaces.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_interfaces.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/clevo_interfaces.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_interfaces.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2020-2021 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef CLEVO_INTERFACES_H
+#define CLEVO_INTERFACES_H
+
+#include <linux/types.h>
+#include <linux/acpi.h>
+
+#define CLEVO_WMI_EVENT_GUID		"ABBC0F6B-8EA1-11D1-00A0-C90629100000"
+#define CLEVO_WMI_EMAIL_GUID		"ABBC0F6C-8EA1-11D1-00A0-C90629100000"
+#define CLEVO_WMI_METHOD_GUID		"ABBC0F6D-8EA1-11D1-00A0-C90629100000"
+
+#define CLEVO_ACPI_RESOURCE_HID		"CLV0001"
+#define CLEVO_ACPI_DSM_UUID		"93f224e4-fbdc-4bbf-add6-db71bdc0afad"
+
+// The clevo get commands expect no parameters
+#define CLEVO_CMD_GET_FANINFO1		0x63
+#define CLEVO_CMD_GET_FANINFO2		0x64
+#define CLEVO_CMD_GET_FANINFO3		0x6e
+
+#define CLEVO_CMD_GET_WEBCAM_SW		0x06
+#define CLEVO_CMD_GET_FLIGHTMODE_SW	0x07
+#define CLEVO_CMD_GET_TOUCHPAD_SW	0x09
+
+#define CLEVO_CMD_GET_EVENT		0x01
+
+#define CLEVO_CMD_GET_SPECS		0x0D // Returns buffer -> only works with clevo_evaluate_method2
+#define CLEVO_CMD_GET_BIOS_FEATURES_1	0x52
+#define CLEVO_CMD_GET_BIOS_FEATURES_1_SUB_WHITE_ONLY_KB	0x40000000
+#define CLEVO_CMD_GET_BIOS_FEATURES_1_SUB_3_ZONE_RGB_KB	0x00400000
+
+#define CLEVO_CMD_GET_BIOS_FEATURES_2	0x7A
+#define CLEVO_CMD_GET_BIOS_FEATURES_2_SUB_WHITE_ONLY_KB_MAX_5	0x4000
+
+#define CLEVO_CMD_GET_KB_WHITE_LEDS	0x3D // Get brightness of white only keyboard backlights
+
+// The clevo set commands expect a parameter
+#define CLEVO_CMD_SET_FANSPEED_VALUE	0x68
+#define CLEVO_CMD_SET_FANSPEED_AUTO	0x69
+
+#define CLEVO_CMD_SET_WEBCAM_SW		0x22
+#define CLEVO_CMD_SET_FLIGHTMODE_SW	0x20
+#define CLEVO_CMD_SET_TOUCHPAD_SW	0x2a
+
+#define CLEVO_CMD_SET_EVENTS_ENABLED	0x46
+
+#define CLEVO_CMD_SET_KB_WHITE_LEDS	0x27 // Set brightness of white only keyboard backlights
+#define CLEVO_CMD_SET_KB_RGB_LEDS	0x67 // Used to set color, brightness, blinking pattern, etc.
+#define CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_0		0xF0000000 // 1-zone RGB and 3-zone RGB left
+#define CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_1		0xF1000000 // 3-zone RGB center
+#define CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_2		0xF2000000 // 3-Zone RGB right
+#define CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_3		0xF3000000 // Unused on all known Clevo devices
+#define CLEVO_CMD_SET_KB_LEDS_SUB_RGB_BRIGHTNESS	0xF4000000
+
+#define CLEVO_CMD_OPT			0x79
+#define CLEVO_CMD_OPT_SUB_SET_PERF_PROF	0x19
+
+struct clevo_interface_t {
+	char *string_id;
+	void (*event_callb)(u32);
+	int (*method_call)(u8, u32, union acpi_object **);
+	int (*method_call_pkgbuf)(u8, u8 *, u32, union acpi_object **);
+};
+
+int clevo_keyboard_add_interface(struct clevo_interface_t *new_interface);
+int clevo_keyboard_remove_interface(struct clevo_interface_t *interface);
+int clevo_evaluate_method(u8 cmd, u32 arg, u32 *result);
+int clevo_evaluate_method2(u8 cmd, u32 arg, union acpi_object **result);
+int clevo_get_active_interface_id(char **id_str);
+
+#define MODULE_ALIAS_CLEVO_WMI() \
+	MODULE_ALIAS("wmi:" CLEVO_WMI_EVENT_GUID); \
+	MODULE_ALIAS("wmi:" CLEVO_WMI_METHOD_GUID);
+
+#define CLEVO_INTERFACE_WMI_STRID	"clevo_wmi"
+#define CLEVO_INTERFACE_ACPI_STRID	"clevo_acpi"
+
+#define MODULE_ALIAS_CLEVO_ACPI() \
+	MODULE_ALIAS("acpi*:" CLEVO_ACPI_RESOURCE_HID ":*");
+
+#define MODULE_ALIAS_CLEVO_INTERFACES() \
+	MODULE_ALIAS_CLEVO_WMI(); \
+	MODULE_ALIAS_CLEVO_ACPI();
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/clevo_keyboard.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_keyboard.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/clevo_keyboard.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_keyboard.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,1139 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2018-2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef CLEVO_KEYBOARD_H
+#define CLEVO_KEYBOARD_H
+
+#include <linux/power_supply.h>
+#include <acpi/battery.h>
+#include <linux/version.h>
+
+#include "tuxedo_keyboard_common.h"
+#include "clevo_interfaces.h"
+#include "clevo_leds.h"
+
+// Clevo event codes
+#define CLEVO_EVENT_KB_LEDS_DECREASE		0x81
+#define CLEVO_EVENT_KB_LEDS_INCREASE		0x82
+#define CLEVO_EVENT_KB_LEDS_CYCLE_MODE		0x83
+#define CLEVO_EVENT_KB_LEDS_CYCLE_BRIGHTNESS	0x8A
+#define CLEVO_EVENT_KB_LEDS_TOGGLE		0x9F
+
+#define CLEVO_EVENT_KB_LEDS_DECREASE2		0x20
+#define CLEVO_EVENT_KB_LEDS_INCREASE2		0x21
+#define CLEVO_EVENT_KB_LEDS_TOGGLE2		0x3f
+
+#define CLEVO_EVENT_TOUCHPAD_TOGGLE		0x5D
+#define CLEVO_EVENT_TOUCHPAD_OFF		0xFC
+#define CLEVO_EVENT_TOUCHPAD_ON			0xFD
+
+#define CLEVO_EVENT_RFKILL1			0x85
+#define CLEVO_EVENT_RFKILL2			0x86
+
+#define CLEVO_EVENT_GAUGE_KEY			0x59
+
+#define CLEVO_EVENT_FN_LOCK_TOGGLE		0x25
+
+#define CLEVO_KB_MODE_DEFAULT			0 // "CUSTOM"/Static Color
+
+static struct clevo_interfaces_t {
+	struct clevo_interface_t *wmi;
+	struct clevo_interface_t *acpi;
+} clevo_interfaces;
+
+static struct clevo_interface_t *active_clevo_interface;
+
+static struct tuxedo_keyboard_driver clevo_keyboard_driver;
+
+static DEFINE_MUTEX(clevo_keyboard_interface_modification_lock);
+
+static struct key_entry clevo_keymap[] = {
+	// Keyboard backlight (RGB versions)
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_DECREASE, { KEY_KBDILLUMDOWN } },
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_INCREASE, { KEY_KBDILLUMUP } },
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_TOGGLE, { KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_CYCLE_MODE, { KEY_LIGHTS_TOGGLE } },
+	// Single cycle key (white only versions) (currently handled in driver)
+	// { KE_KEY, CLEVO_EVENT_KB_LEDS_CYCLE_BRIGHTNESS, { KEY_KBDILLUMTOGGLE } },
+
+	// Alternative events (ex. 6 step white kbd)
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_DECREASE2, { KEY_KBDILLUMDOWN } },
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_INCREASE2, { KEY_KBDILLUMUP } },
+	{ KE_KEY, CLEVO_EVENT_KB_LEDS_TOGGLE2, { KEY_KBDILLUMTOGGLE } },
+
+	// Touchpad
+	// The weirdly named touchpad toggle key that is implemented as KEY_F21 "everywhere"
+	// (instead of KEY_TOUCHPAD_TOGGLE or on/off)
+	// Most "new" devices just provide one toggle event
+	{ KE_KEY, CLEVO_EVENT_TOUCHPAD_TOGGLE, { KEY_F21 } },
+	// Some "old" devices produces on/off events
+	{ KE_KEY, CLEVO_EVENT_TOUCHPAD_OFF, { KEY_F21 } },
+	{ KE_KEY, CLEVO_EVENT_TOUCHPAD_ON, { KEY_F21 } },
+	// The alternative key events (currently not used)
+	// { KE_KEY, CLEVO_EVENT_TOUCHPAD_OFF, { KEY_TOUCHPAD_OFF } },
+	// { KE_KEY, CLEVO_EVENT_TOUCHPAD_ON, { KEY_TOUCHPAD_ON } },
+	// { KE_KEY, CLEVO_EVENT_TOUCHPAD_TOGGLE, { KEY_TOUCHPAD_TOGGLE } },
+
+	// Rfkill still needed by some devices
+	{ KE_KEY, CLEVO_EVENT_RFKILL1, { KEY_RFKILL } },
+	{ KE_IGNORE, CLEVO_EVENT_RFKILL2, { KEY_RFKILL } }, // Older rfkill event
+	// Note: Volume events need to be ignored as to not interfere with built-in functionality
+	{ KE_IGNORE, 0xfa, { KEY_UNKNOWN } }, // Appears by volume up/down
+	{ KE_IGNORE, 0xfb, { KEY_UNKNOWN } }, // Appears by mute toggle
+
+	// Only used to put ev bits
+	{ KE_KEY,	0xffff,				{ KEY_F6 } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTALT } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTMETA } },
+
+	{ KE_END, 0 }
+};
+
+// Keyboard struct
+static struct kbd_led_state_t {
+	u8 has_mode;
+	u8 mode;
+	u8 whole_kbd_color;
+} kbd_led_state = {
+	.has_mode = 1,
+	.mode = CLEVO_KB_MODE_DEFAULT,
+	.whole_kbd_color = 7,
+};
+
+static struct kbd_backlight_mode_t {
+	u8 key;
+	u32 value;
+	const char *const name;
+} kbd_backlight_modes[] = {
+        { .key = 0, .value = 0x00000000, .name = "CUSTOM"},
+        { .key = 1, .value = 0x1002a000, .name = "BREATHE"},
+        { .key = 2, .value = 0x33010000, .name = "CYCLE"},
+        { .key = 3, .value = 0x80000000, .name = "DANCE"},
+        { .key = 4, .value = 0xA0000000, .name = "FLASH"},
+        { .key = 5, .value = 0x70000000, .name = "RANDOM_COLOR"},
+        { .key = 6, .value = 0x90000000, .name = "TEMPO"},
+        { .key = 7, .value = 0xB0000000, .name = "WAVE"}
+};
+
+// forward declaration
+static int clevo_acpi_fn_get(u8 *on, u8 *kbstatus1, u8 *kbstatus2);
+static int clevo_acpi_fn_lock_set(int on);
+
+int clevo_evaluate_method2(u8 cmd, u32 arg, union acpi_object **result)
+{
+	if (IS_ERR_OR_NULL(active_clevo_interface)) {
+		pr_err("clevo_keyboard: no active interface while attempting cmd %02x arg %08x\n", cmd, arg);
+		return -ENODEV;
+	}
+	return active_clevo_interface->method_call(cmd, arg, result);
+}
+EXPORT_SYMBOL(clevo_evaluate_method2);
+
+static int clevo_evaluate_method_pkgbuf(u8 cmd, u8 *arg, u32 length, union acpi_object **result)
+{
+	if (IS_ERR_OR_NULL(active_clevo_interface)) {
+		pr_err("clevo_keyboard: no active interface while attempting cmd %02x\n", cmd);
+		return -ENODEV;
+	}
+	return active_clevo_interface->method_call_pkgbuf(cmd, arg, length, result);
+}
+
+int clevo_evaluate_method(u8 cmd, u32 arg, u32 *result)
+{
+	int status = 0;
+	union acpi_object *out_obj;
+
+	status = clevo_evaluate_method2(cmd, arg, &out_obj);
+	if (status) {
+		return status;
+	}
+	else {
+		if (out_obj->type == ACPI_TYPE_INTEGER) {
+			if (!IS_ERR_OR_NULL(result))
+				*result = (u32) out_obj->integer.value;
+		} else {
+			pr_err("return type not integer, use clevo_evaluate_method2\n");
+			status = -ENODATA;
+		}
+		ACPI_FREE(out_obj);
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(clevo_evaluate_method);
+
+int clevo_get_active_interface_id(char **id_str)
+{
+	if (IS_ERR_OR_NULL(active_clevo_interface))
+		return -ENODEV;
+
+	if (!IS_ERR_OR_NULL(id_str))
+		*id_str = active_clevo_interface->string_id;
+
+	return 0;
+}
+EXPORT_SYMBOL(clevo_get_active_interface_id);
+
+static void set_next_color_whole_kb(void)
+{
+	/* "Calculate" new to-be color */
+	u32 new_color_id;
+	u32 new_color_code;
+
+	new_color_id = kbd_led_state.whole_kbd_color + 1;
+	if (new_color_id >= color_list.size) {
+		new_color_id = 1; // Skip black
+	}
+	new_color_code = color_list.colors[new_color_id].code;
+
+	TUXEDO_INFO("set_next_color_whole_kb(): new_color_id: %i, new_color_code %X", 
+		    new_color_id, new_color_code);
+
+	/* Set color on all four regions*/
+	clevo_leds_set_color_extern(new_color_code);
+	kbd_led_state.whole_kbd_color = new_color_id;
+}
+
+static void set_kbd_backlight_mode(u8 kbd_backlight_mode)
+{
+	TUXEDO_INFO("Set keyboard backlight mode on %s", kbd_backlight_modes[kbd_backlight_mode].name);
+
+	if (!clevo_evaluate_method(CLEVO_CMD_SET_KB_RGB_LEDS, kbd_backlight_modes[kbd_backlight_mode].value, NULL)) {
+		// method was succesfull so update ur internal state struct
+		kbd_led_state.mode = kbd_backlight_mode;
+	}
+}
+
+// Sysfs Interface for the keyboard backlight mode
+static ssize_t list_kbd_backlight_modes_fs(struct device *child, struct device_attribute *attr,
+                                         char *buffer)
+{
+	return sprintf(buffer, "%d\n", kbd_led_state.mode);
+}
+
+static ssize_t set_kbd_backlight_mode_fs(struct device *child,
+                                       struct device_attribute *attr,
+                                       const char *buffer, size_t size)
+{
+	unsigned int kbd_backlight_mode;
+
+	int err = kstrtouint(buffer, 0, &kbd_backlight_mode);
+	if (err) {
+		return err;
+	}
+
+	kbd_backlight_mode = clamp_t(u8, kbd_backlight_mode, 0, ARRAY_SIZE(kbd_backlight_modes) - 1);
+	set_kbd_backlight_mode(kbd_backlight_mode);
+
+	return size;
+}
+
+// Sysfs attribute file permissions and method linking
+static DEVICE_ATTR(kbd_backlight_mode, 0644, list_kbd_backlight_modes_fs, set_kbd_backlight_mode_fs);
+
+static int kbd_backlight_mode_id_validator(const char *value,
+					   const struct kernel_param *kbd_backlight_mode_param)
+{
+	int kbd_backlight_mode = 0;
+
+	if (kstrtoint(value, 10, &kbd_backlight_mode) != 0
+	    || kbd_backlight_mode < 0
+	    || kbd_backlight_mode > (ARRAY_SIZE(kbd_backlight_modes) - 1)) {
+		return -EINVAL;
+	}
+
+	return param_set_int(value, kbd_backlight_mode_param);
+}
+
+static const struct kernel_param_ops param_ops_mode_ops = {
+	.set = kbd_backlight_mode_id_validator,
+	.get = param_get_int,
+};
+
+static u8 param_kbd_backlight_mode = CLEVO_KB_MODE_DEFAULT;
+module_param_cb(kbd_backlight_mode, &param_ops_mode_ops, &param_kbd_backlight_mode, S_IRUSR);
+MODULE_PARM_DESC(kbd_backlight_mode, "Set the keyboard backlight mode");
+
+static void clevo_send_cc_combo(void)
+{
+	// Special key combination. Opens TCC by default when installed.
+	input_report_key(clevo_keyboard_driver.input_device, KEY_LEFTMETA, 1);
+	input_report_key(clevo_keyboard_driver.input_device, KEY_LEFTALT, 1);
+	input_report_key(clevo_keyboard_driver.input_device, KEY_F6, 1);
+	input_sync(clevo_keyboard_driver.input_device);
+	input_report_key(clevo_keyboard_driver.input_device, KEY_F6, 0);
+	input_report_key(clevo_keyboard_driver.input_device, KEY_LEFTALT, 0);
+	input_report_key(clevo_keyboard_driver.input_device, KEY_LEFTMETA, 0);
+	input_sync(clevo_keyboard_driver.input_device);
+}
+
+static void clevo_keyboard_event_callb(u32 event)
+{
+	int err;
+	u8 on, kbstatus1, kbstatus2;
+	u32 key_event = event;
+
+	TUXEDO_DEBUG("Clevo event: %0#6x\n", event);
+
+	switch (key_event) {
+		case CLEVO_EVENT_GAUGE_KEY:
+			clevo_send_cc_combo();
+			break;
+		case CLEVO_EVENT_KB_LEDS_CYCLE_MODE:
+			if (clevo_leds_get_backlight_type() == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+				clevo_send_cc_combo();
+			} else {
+				set_next_color_whole_kb();
+			}
+			break;
+		case CLEVO_EVENT_KB_LEDS_CYCLE_BRIGHTNESS:
+			clevo_leds_notify_brightness_change_extern();
+			break;
+		case CLEVO_EVENT_FN_LOCK_TOGGLE:
+			err = clevo_acpi_fn_get(&on, &kbstatus1, &kbstatus2);
+			if (err) {
+				TUXEDO_ERROR("Error while reading ACPI fn lock; ignoring toggle request");
+			}
+			else {
+				if (on == 1)
+					clevo_acpi_fn_lock_set(0);
+				else
+					clevo_acpi_fn_lock_set(1);
+			}
+			break;
+		default:
+			break;
+	}
+
+	if (current_driver != NULL && current_driver->input_device != NULL) {
+		if (!sparse_keymap_report_known_event(current_driver->input_device, key_event, 1, true)) {
+			TUXEDO_DEBUG("Unknown key - %d (%0#6x)\n", key_event, key_event);
+		}
+	}
+}
+
+static void clevo_keyboard_init_device_interface(struct platform_device *dev)
+{
+	// Setup sysfs
+	if (clevo_leds_get_backlight_type() == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+		if (device_create_file(&dev->dev, &dev_attr_kbd_backlight_mode) != 0) {
+			TUXEDO_ERROR("Sysfs attribute file creation failed for blinking pattern\n");
+		}
+		else {
+			kbd_led_state.has_mode = 1;
+		}
+	}
+}
+
+/**
+ * strstr version of dmi_match
+ */
+static bool dmi_string_in(enum dmi_field f, const char *str)
+{
+	const char *info = dmi_get_system_info(f);
+
+	if (info == NULL || str == NULL)
+		return info == str;
+
+	return strstr(info, str) != NULL;
+}
+
+// Fn lock
+
+static int clevo_acpi_fn_get(u8 *on, u8 *kbstatus1, u8 *kbstatus2)
+{
+	int status = 0;
+	union acpi_object *out_obj;
+	u8 fnlock;
+
+	status = clevo_evaluate_method2(0x4, 0x18, &out_obj);
+	if (status) {
+		return status;
+	}
+
+	if (out_obj->type == ACPI_TYPE_BUFFER ) {
+		if (out_obj->buffer.length >= 3) {
+			// use buffer
+			fnlock = out_obj->buffer.pointer[0];
+			if (fnlock == 1) {
+				pr_debug("FnLock is set: kbstatus[1]: %08x  kbstatus[2]: %08x\n", (u32) out_obj->buffer.pointer[1], (u32)out_obj->buffer.pointer[2]);
+				*on = 1;
+			}
+			if (fnlock == 2) {
+				pr_debug("FnLock is not set: kbstatus[1]: %08x  kbstatus[2]: %08x\n", (u32) out_obj->buffer.pointer[1], (u32)out_obj->buffer.pointer[2]);
+				*on = 0;
+			}
+			if (fnlock != 1 && fnlock != 2) {
+				pr_err("FnLock undefined: 0x%x\n", fnlock);
+				status = -ENODATA;
+			}
+			*kbstatus1 = out_obj->buffer.pointer[1];
+			*kbstatus2 = out_obj->buffer.pointer[2];
+		}
+		else {
+			pr_err("unexpected buffer size %d\n", out_obj->buffer.length);
+		}
+		ACPI_FREE(out_obj);
+	}
+
+	return status;
+}
+
+static int clevo_acpi_fn_lock_set(int on)
+{
+	int status = 0;
+	union acpi_object *out_obj;
+	u8 fnlock_on, kbstatus1, kbstatus2;
+
+	// cmd 0x19; fnlock_off = 0x02, fnlock_on = 0x01
+	u8 args[] = {0x19, 0x02, 0x00, 0x00};
+
+	if (on)
+		args[1] = 0x01;
+
+	// read keyboard status first
+	status = clevo_acpi_fn_get(&fnlock_on, &kbstatus1, &kbstatus2);
+	if (status)
+		return status;
+
+	args[2] = kbstatus1;
+	args[3] = kbstatus2;
+
+	// set Fn lock
+	status = clevo_evaluate_method_pkgbuf(0x4, args, 4, &out_obj);
+
+	if (status)
+		pr_err("set/unset FnLock failed\n");
+	else
+		ACPI_FREE(out_obj);
+
+	return status;
+}
+
+static ssize_t clevo_fn_lock_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	int err;
+	u8 on, kbstatus1, kbstatus2;
+
+	err = clevo_acpi_fn_get(&on, &kbstatus1, &kbstatus2);
+	if (err)
+		return err;
+
+	return sprintf(buf, "%d\n", on);
+}
+
+static ssize_t clevo_fn_lock_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int on, err;
+
+	if (kstrtoint(buf, 10, &on) ||
+			on < 0 || on > 1)
+		return -EINVAL;
+
+	err = clevo_acpi_fn_lock_set(on);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static bool clevo_fn_lock_available(void){
+	int err;
+	union acpi_object *out_obj;
+	u8 fnlock;
+
+	// no sysfs device for Aura Gen3 due to Fn Lock interference (via keyboard)
+	// but Aura Gen3 refresh (NL45AU2 und NL57AU) has working Fn Lock
+	if ((dmi_match(DMI_PRODUCT_SKU, "AURA14GEN3") ||
+	     dmi_match(DMI_PRODUCT_SKU, "AURA15GEN3")) &&
+	    (dmi_match(DMI_BOARD_NAME, "NL57PU") ||
+	     dmi_match(DMI_BOARD_NAME, "NL45PU2")))
+			return 0;
+
+	// check Fn lock for WMI
+	if( strcmp(active_clevo_interface->string_id, CLEVO_INTERFACE_WMI_STRID) == 0) {
+		pr_debug("FnLock test: WMI is not supported\n");
+		return 0;
+	}
+
+	// check Fn Lock for ACPI
+	if( strcmp(active_clevo_interface->string_id, CLEVO_INTERFACE_ACPI_STRID) == 0) {
+		err = clevo_evaluate_method2(0x4, 0x18, &out_obj);
+		if (err) {
+			pr_debug("FnLock test: ACPI evaluate returned an error\n");
+			return 0;
+		}
+
+		if (out_obj->type != ACPI_TYPE_BUFFER ) {
+			pr_debug("FnLock test: no ACPI buffer\n");
+			return 0;
+		}
+		if (out_obj->buffer.length < 3) {
+			pr_debug("FnLock test: ACPI buffer too small\n");
+			ACPI_FREE(out_obj);
+			return 0;
+		}
+		fnlock = out_obj->buffer.pointer[0];
+		if (fnlock != 1 && fnlock != 2) {
+			pr_debug("FnLock test: unexpected FnLock value 0x%02x\n", fnlock);
+			ACPI_FREE(out_obj);
+			return 0;
+		}
+		ACPI_FREE(out_obj);
+		return 1;
+	}
+
+	return 0;
+}
+
+static u8 clevo_legacy_flexicharger_start_values[] = {40, 50, 60, 70, 80, 95};
+static u8 clevo_legacy_flexicharger_end_values[] = {60, 70, 80, 90, 100};
+
+static int array_find_closest_u8(u8 value, u8 *haystack, size_t length)
+{
+	int i;
+	u8 closest;
+
+	if (length == 0)
+		return -EINVAL;
+
+	closest = haystack[0];
+	for (i = 0; i < length; ++i) {
+		if (abs(value - haystack[i]) < abs(value - closest))
+			closest = haystack[i];
+	}
+
+	return closest;
+}
+
+static int clevo_has_legacy_flexicharger(bool *status)
+{
+	u32 read_data = 0;
+	u32 write_data = 0x06000000;
+	int result;
+
+	// Known exclude list
+	bool excluded_device = false
+		|| dmi_string_in(DMI_BOARD_NAME, "N24_25BU")
+		|| dmi_string_in(DMI_BOARD_NAME, "L14xMU")
+		|| dmi_string_in(DMI_BOARD_NAME, "N141CU")
+		|| dmi_string_in(DMI_BOARD_NAME, "NH5xAx")
+		|| dmi_string_in(DMI_BOARD_NAME, "NL5xNU")
+		|| dmi_string_in(DMI_BOARD_NAME, "P95xER")
+		|| dmi_string_in(DMI_BOARD_NAME, "PCX0DX")
+		|| dmi_string_in(DMI_BOARD_NAME, "PD5x_7xPNP_PNR_PNN_PNT")
+		|| dmi_string_in(DMI_BOARD_NAME, "X170SM")
+		|| dmi_string_in(DMI_BOARD_NAME, "NS50MU")
+		|| dmi_string_in(DMI_BOARD_NAME, "NS50_70MU")
+		;
+
+	if (excluded_device) {
+		*status = false;
+		return 0;
+	}
+
+	// Use a combination of read and write read values to identify legacy flexicharger
+	// Using set command should read the command back as result if existing
+	result = clevo_evaluate_method(0x77, 0, &read_data);
+	if (result != 0)
+		return result;
+
+	write_data |= ((read_data >> 8) & 0xffff);
+	result = clevo_evaluate_method(0x76, write_data, &read_data);
+
+	if (read_data == 0x76)
+		*status = true;
+	else
+		*status = false;
+	
+	return result;
+}
+
+/**
+ * Read legacy flexicharger data. If successful parameter contains result.
+ * 
+ * @param start Start threshold
+ * @param end End threshold
+ * @param status On or Off (1 or 0)
+ */
+static int clevo_legacy_flexicharger_read(u8 *start, u8 *end, u8 *status)
+{
+	/*
+	 * Data bytes
+	 *            end      start    on/off
+	 * |--------|--------|--------|--------|
+	 */
+	u32 data;
+	int result;
+
+	result = clevo_evaluate_method(0x77, 0, &data);
+	if (end != NULL)
+		*end = (data >> 0x10) & 0xff;
+	if (start != NULL)
+		*start = (data >> 0x08) & 0xff;
+	if (status != NULL)
+		*status = data & 0x01;
+
+	return result;
+}
+
+/**
+ * Write flexicharger data.
+ * 
+ * @param start Start threshold
+ * @param end End threshold
+ * @param status On or Off (1 or 0)
+ */
+static int clevo_legacy_flexicharger_write(const u8 *param_start, const u8 *param_end, const u8 *param_status)
+{
+	// Two different subcommands for writing
+	u32 write_data_thresholds = (0x06 << 0x18);
+	u32 write_data_status = (0x05 << 0x18);
+
+	u8 previous_start, previous_end, previous_status;
+	u8 set_start, set_end, set_status;
+
+	if (clevo_legacy_flexicharger_read(&previous_start, &previous_end, &previous_status) != 0)
+		return -EIO;
+
+	// Set choosen parameters, leave nulled ones with previous value
+	set_start = param_start != NULL ? *param_start : previous_start;
+	set_end = param_end != NULL ? *param_end : previous_end;
+	set_status = param_status != NULL ? *param_status : previous_status;
+
+	write_data_thresholds |= set_start;
+	write_data_thresholds |= (set_end << 0x08);
+	write_data_status |= set_status & 0x01;
+
+	// Write to EC, note that status go last as it also triggers save
+	if (clevo_evaluate_method(0x76, write_data_thresholds, NULL) != 0)
+		return -EIO;
+
+	if (clevo_evaluate_method(0x76, write_data_status, NULL) != 0)
+		return -EIO;
+	
+	return 0;
+}
+
+static int clevo_cc4_flexicharger_read(u8 *start, u8 *end, u8 *status)
+{
+	int result;
+	union acpi_object *out_obj;
+
+	result = clevo_evaluate_method2(0x04, 0x1e, &out_obj);
+	if (result)
+		return -EIO;
+
+	if (out_obj->type != ACPI_TYPE_BUFFER ||
+	    out_obj->buffer.length < 3) {
+		ACPI_FREE(out_obj);
+		return -EIO;
+	}
+
+	if (out_obj->buffer.pointer[2] == 0 &&
+	    out_obj->buffer.pointer[1] == 0) {
+		ACPI_FREE(out_obj);
+		return -ENODEV;
+	}
+
+	if (end != NULL)
+		*end = out_obj->buffer.pointer[2];
+	if (start != NULL)
+		*start = out_obj->buffer.pointer[1];
+	if (status != NULL)
+		*status = out_obj->buffer.pointer[0];
+
+	ACPI_FREE(out_obj);
+
+	return result;
+}
+
+static int clevo_has_cc4_flexicharger(bool *status)
+{
+	if (clevo_cc4_flexicharger_read(NULL, NULL, NULL))
+		*status = false;
+	else
+		*status = true;
+
+	return 0;
+}
+
+static int clevo_cc4_flexicharger_write(const u8 *param_start,
+					const u8 *param_end,
+					const u8 *param_status)
+{
+	union acpi_object *dummy_out;
+	u8 previous_start, previous_end, previous_status;
+	u8 set_start, set_end, set_status;
+	u8 buffer_set[0xff] = { 0x1f };
+
+	if (clevo_cc4_flexicharger_read(&previous_start, &previous_end, &previous_status))
+		return -EIO;
+
+	// Set choosen parameters, leave nulled ones with previous value
+	set_start = param_start != NULL ? *param_start : previous_start;
+	set_end = param_end != NULL ? *param_end : previous_end;
+	set_status = param_status != NULL ? *param_status : previous_status;
+
+	buffer_set[1] = set_status;
+	buffer_set[2] = set_start;
+	buffer_set[3] = set_end;
+
+	if (clevo_evaluate_method_pkgbuf(0x04, buffer_set, ARRAY_SIZE(buffer_set), &dummy_out))
+		return -EIO;
+
+	ACPI_FREE(dummy_out);
+
+	return 0;
+}
+
+static int clevo_flexicharger_read(u8 *start, u8 *end, u8 *status)
+{
+	bool has_cc4_flexicharger;
+	clevo_has_cc4_flexicharger(&has_cc4_flexicharger);
+	if (has_cc4_flexicharger)
+		return clevo_cc4_flexicharger_read(start, end, status);
+	else
+		return clevo_legacy_flexicharger_read(start, end, status);
+}
+
+static int clevo_flexicharger_write(const u8 *param_start,
+				    const u8 *param_end,
+				    const u8 *param_status)
+{
+	bool has_cc4_flexicharger;
+	clevo_has_cc4_flexicharger(&has_cc4_flexicharger);
+	if (has_cc4_flexicharger)
+		return clevo_cc4_flexicharger_write(param_start, param_end, param_status);
+	else
+		return clevo_legacy_flexicharger_write(param_start, param_end, param_status);
+}
+
+static ssize_t charge_type_show(struct device *device,
+				struct device_attribute *attr,
+				char *buf)
+{
+	int result;
+	u8 status;
+
+	result = clevo_flexicharger_read(NULL, NULL, &status);
+
+	if (result != 0)
+		return result;
+
+	if (status == 1)
+		return sprintf(buf, "%s\n", "Custom");
+	else
+		return sprintf(buf, "%s\n", "Standard");
+
+}
+
+static ssize_t charge_type_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf,
+				 size_t count)
+{
+	u8 write_status;
+	int result;
+
+	if (sysfs_streq(buf, "Standard"))
+		write_status = 0;
+	else if (sysfs_streq(buf, "Custom"))
+		write_status = 1;
+	else
+		return -EINVAL;
+
+	result = clevo_flexicharger_write(NULL, NULL, &write_status);
+
+	if (result < 0)
+		return result;
+	else
+		return count;
+}
+
+static ssize_t charge_control_start_threshold_show(struct device *device,
+						   struct device_attribute *attr,
+						   char *buf)
+{
+	int result;
+	u8 start_threshold;
+
+	result = clevo_flexicharger_read(&start_threshold, NULL, NULL);
+
+	if (result != 0)
+		return result;
+
+	return sprintf(buf, "%d\n", start_threshold);
+}
+
+static ssize_t charge_control_start_threshold_store(struct device *dev,
+						    struct device_attribute *attr,
+						    const char *buf,
+						    size_t count)
+{
+	u8 value, write_value;
+	int result;
+
+	result = kstrtou8(buf, 10, &value);
+	if (result)
+		return result;
+
+	if (value < 1 || value > 100)
+		return -EINVAL;
+	
+	write_value = array_find_closest_u8(value,
+					    clevo_legacy_flexicharger_start_values,
+					    ARRAY_SIZE(clevo_legacy_flexicharger_start_values));
+	result = clevo_flexicharger_write(&write_value, NULL, NULL);
+
+	if (result < 0)
+		return result;
+	else
+		return count;
+}
+
+static ssize_t charge_control_end_threshold_show(struct device *device,
+						 struct device_attribute *attr,
+						 char *buf)
+{
+	int result;
+	u8 end_threshold;
+
+	result = clevo_flexicharger_read(NULL, &end_threshold, NULL);
+
+	if (result != 0)
+		return result;
+
+	return sprintf(buf, "%d\n", end_threshold);
+}
+
+static ssize_t charge_control_end_threshold_store(struct device *dev,
+						  struct device_attribute *attr,
+						  const char *buf,
+						  size_t count)
+{
+	u8 value, write_value;
+	int result;
+
+	result = kstrtou8(buf, 10, &value);
+	if (result)
+		return result;
+
+	if (value < 1 || value > 100)
+		return -EINVAL;
+
+	write_value = array_find_closest_u8(value,
+					    clevo_legacy_flexicharger_end_values,
+					    ARRAY_SIZE(clevo_legacy_flexicharger_end_values));
+	result = clevo_flexicharger_write(NULL, &write_value, NULL);
+
+
+	if (result < 0)
+		return result;
+	else
+		return count;
+}
+
+static ssize_t charge_control_start_available_thresholds_show(struct device *device,
+							    struct device_attribute *attr,
+							    char *buf)
+{
+	int i;
+	ssize_t length = ARRAY_SIZE(clevo_legacy_flexicharger_start_values);
+
+	for (i = 0; i < length; ++i) {
+		sprintf(buf + strlen(buf), "%d",
+			clevo_legacy_flexicharger_start_values[i]);
+		if (i < length - 1)
+			sprintf(buf + strlen(buf), " ");
+		else
+			sprintf(buf + strlen(buf), "\n");
+	}
+
+	return strlen(buf);
+}
+
+static ssize_t charge_control_end_available_thresholds_show(struct device *device,
+							    struct device_attribute *attr,
+							    char *buf)
+{
+	int i;
+	ssize_t length = ARRAY_SIZE(clevo_legacy_flexicharger_end_values);
+
+	for (i = 0; i < length; ++i) {
+		sprintf(buf + strlen(buf), "%d",
+			clevo_legacy_flexicharger_end_values[i]);
+		if (i < length - 1)
+			sprintf(buf + strlen(buf), " ");
+		else
+			sprintf(buf + strlen(buf), "\n");
+	}
+
+	return strlen(buf);
+}
+
+// Official attributes
+static DEVICE_ATTR_RW(charge_type);
+static DEVICE_ATTR_RW(charge_control_start_threshold);
+static DEVICE_ATTR_RW(charge_control_end_threshold);
+
+// Unofficial attributes
+static DEVICE_ATTR_RO(charge_control_start_available_thresholds);
+static DEVICE_ATTR_RO(charge_control_end_available_thresholds);
+
+static bool charge_control_registered = false;
+
+static struct attribute *clevo_battery_attrs[] = {
+	&dev_attr_charge_type.attr,
+	&dev_attr_charge_control_start_threshold.attr,
+	&dev_attr_charge_control_end_threshold.attr,
+	&dev_attr_charge_control_start_available_thresholds.attr,
+	&dev_attr_charge_control_end_available_thresholds.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(clevo_battery);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int clevo_battery_add(struct power_supply *battery)
+#else
+static int clevo_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)
+#endif
+{
+	bool has_legacy_flexicharger;
+	bool has_cc4_flexicharger;
+
+	clevo_has_legacy_flexicharger(&has_legacy_flexicharger);
+	clevo_has_cc4_flexicharger(&has_cc4_flexicharger);
+
+	if (has_cc4_flexicharger) {
+		pr_debug("cc4 flexicharger identified\n");
+	}
+
+	if (has_legacy_flexicharger) {
+		pr_debug("legacy flexicharger identified\n");
+	}
+
+	// Check support and type
+	if (!has_legacy_flexicharger && !has_cc4_flexicharger)
+		return -ENODEV;
+
+	if (device_add_groups(&battery->dev, clevo_battery_groups))
+		return -ENODEV;
+
+	charge_control_registered = true;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int clevo_battery_remove(struct power_supply *battery)
+#else
+static int clevo_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)
+#endif
+{
+	device_remove_groups(&battery->dev, clevo_battery_groups);
+	return 0;
+}
+
+static struct acpi_battery_hook battery_hook = {
+	.add_battery = clevo_battery_add,
+	.remove_battery = clevo_battery_remove,
+	.name = "TUXEDO Flexicharger Extension",
+};
+
+static void clevo_flexicharger_init(void)
+{
+	battery_hook_register(&battery_hook);
+}
+
+static void clevo_flexicharger_remove(void)
+{
+	if (charge_control_registered)
+		battery_hook_unregister(&battery_hook);
+}
+
+static void clevo_keyboard_init(void)
+{
+	bool performance_profile_set_workaround;
+
+	kbd_led_state.mode = param_kbd_backlight_mode;
+	set_kbd_backlight_mode(kbd_led_state.mode);
+
+	clevo_evaluate_method(CLEVO_CMD_SET_EVENTS_ENABLED, 0, NULL);
+
+	// Workaround for firmware issue not setting selected performance profile.
+	// Explicitly set "performance" perf. profile on init regardless of what is chosen
+	// for these devices (Aura, XP14, IBS14v5)
+	performance_profile_set_workaround = false
+		|| dmi_string_in(DMI_BOARD_NAME, "AURA1501")
+		|| dmi_string_in(DMI_BOARD_NAME, "EDUBOOK1502")
+		|| dmi_string_in(DMI_BOARD_NAME, "NL5xRU")
+		|| dmi_string_in(DMI_BOARD_NAME, "NV4XMB,ME,MZ")
+		|| dmi_string_in(DMI_BOARD_NAME, "L140CU")
+		|| dmi_string_in(DMI_BOARD_NAME, "NS50MU")
+		|| dmi_string_in(DMI_BOARD_NAME, "NS50_70MU")
+		|| dmi_string_in(DMI_BOARD_NAME, "PCX0DX")
+		|| dmi_string_in(DMI_BOARD_NAME, "PCx0Dx_GN20")
+		|| dmi_string_in(DMI_BOARD_NAME, "L14xMU")
+		;
+	if (performance_profile_set_workaround) {
+		TUXEDO_INFO("Performance profile 'performance' set workaround applied\n");
+		clevo_evaluate_method(CLEVO_CMD_OPT, 0x19000002, NULL);
+	}
+
+	clevo_flexicharger_init();
+}
+
+static int clevo_keyboard_probe(struct platform_device *dev)
+{
+	clevo_leds_init(dev);
+	// clevo_keyboard_init_device_interface() must come after clevo_leds_init()
+	// to know keyboard backlight type
+	clevo_keyboard_init_device_interface(dev);
+	clevo_keyboard_init();
+
+	return 0;
+}
+
+static void clevo_keyboard_remove_device_interface(struct platform_device *dev)
+{
+	if (kbd_led_state.has_mode == 1) {
+		device_remove_file(&dev->dev, &dev_attr_kbd_backlight_mode);
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int clevo_keyboard_remove(struct platform_device *dev)
+#else
+static void clevo_keyboard_remove(struct platform_device *dev)
+#endif
+{
+	clevo_flexicharger_remove();
+	clevo_keyboard_remove_device_interface(dev);
+	clevo_leds_remove(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static int clevo_keyboard_suspend(struct platform_device *dev, pm_message_t state)
+{
+	clevo_leds_suspend(dev);
+	return 0;
+}
+
+static int clevo_keyboard_resume(struct platform_device *dev)
+{
+	clevo_evaluate_method(CLEVO_CMD_SET_EVENTS_ENABLED, 0, NULL);
+	clevo_leds_restore_state_extern(); // Sometimes clevo devices forget their last state after
+					   // suspend, so let the kernel ensure it.
+	clevo_leds_resume(dev);
+	return 0;
+}
+
+static struct platform_driver platform_driver_clevo = {
+	.remove = clevo_keyboard_remove,
+	.suspend = clevo_keyboard_suspend,
+	.resume = clevo_keyboard_resume,
+	.driver =
+		{
+			.name = DRIVER_NAME,
+			.owner = THIS_MODULE,
+		},
+};
+
+static struct tuxedo_keyboard_driver clevo_keyboard_driver = {
+	.platform_driver = &platform_driver_clevo,
+	.probe = clevo_keyboard_probe,
+	.key_map = clevo_keymap,
+	.fn_lock_available = clevo_fn_lock_available,
+	.fn_lock_show = clevo_fn_lock_show,
+	.fn_lock_store = clevo_fn_lock_store,
+};
+
+int clevo_keyboard_add_interface(struct clevo_interface_t *new_interface)
+{
+	mutex_lock(&clevo_keyboard_interface_modification_lock);
+
+	if (strcmp(new_interface->string_id, CLEVO_INTERFACE_WMI_STRID) == 0) {
+		clevo_interfaces.wmi = new_interface;
+		clevo_interfaces.wmi->event_callb = clevo_keyboard_event_callb;
+
+		// Only use wmi if there is no other current interface
+		if (ZERO_OR_NULL_PTR(active_clevo_interface)) {
+			pr_debug("enable wmi events\n");
+			clevo_interfaces.wmi->method_call(CLEVO_CMD_SET_EVENTS_ENABLED, 0, NULL);
+
+			active_clevo_interface = clevo_interfaces.wmi;
+		}
+	} else if (strcmp(new_interface->string_id, CLEVO_INTERFACE_ACPI_STRID) == 0) {
+		clevo_interfaces.acpi = new_interface;
+		clevo_interfaces.acpi->event_callb = clevo_keyboard_event_callb;
+
+		pr_debug("enable acpi events (takes priority)\n");
+		clevo_interfaces.acpi->method_call(CLEVO_CMD_SET_EVENTS_ENABLED, 0, NULL);
+		active_clevo_interface = clevo_interfaces.acpi;
+	} else {
+		// Not recognized interface
+		pr_err("unrecognized interface\n");
+		mutex_unlock(&clevo_keyboard_interface_modification_lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&clevo_keyboard_interface_modification_lock);
+
+	if (active_clevo_interface != NULL)
+		tuxedo_keyboard_init_driver(&clevo_keyboard_driver);
+
+	return 0;
+}
+EXPORT_SYMBOL(clevo_keyboard_add_interface);
+
+int clevo_keyboard_remove_interface(struct clevo_interface_t *interface)
+{
+	mutex_lock(&clevo_keyboard_interface_modification_lock);
+
+	if (strcmp(interface->string_id, CLEVO_INTERFACE_WMI_STRID) == 0) {
+		clevo_interfaces.wmi = NULL;
+	} else if (strcmp(interface->string_id, CLEVO_INTERFACE_ACPI_STRID) == 0) {
+		clevo_interfaces.acpi = NULL;
+	} else {
+		mutex_unlock(&clevo_keyboard_interface_modification_lock);
+		return -EINVAL;
+	}
+
+	if (active_clevo_interface == interface) {
+		tuxedo_keyboard_remove_driver(&clevo_keyboard_driver);
+		active_clevo_interface = NULL;
+	}
+
+
+	mutex_unlock(&clevo_keyboard_interface_modification_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(clevo_keyboard_remove_interface);
+
+#endif // CLEVO_KEYBOARD_H
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/clevo_leds.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_leds.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/clevo_leds.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_leds.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,554 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2018-2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef CLEVO_LEDS_H
+#define CLEVO_LEDS_H
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+
+enum clevo_kb_backlight_types {
+	CLEVO_KB_BACKLIGHT_TYPE_NONE = 0x00,
+	CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR = 0x01,
+	CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB = 0x02,
+	CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB = 0x06,
+	CLEVO_KB_BACKLIGHT_TYPE_PER_KEY_RGB = 0xf3
+};
+
+int clevo_leds_init(struct platform_device *dev);
+int clevo_leds_remove(struct platform_device *dev);
+int clevo_leds_suspend(struct platform_device *dev);
+int clevo_leds_resume(struct platform_device *dev);
+enum clevo_kb_backlight_types clevo_leds_get_backlight_type(void);
+void clevo_leds_restore_state_extern(void);
+void clevo_leds_notify_brightness_change_extern(void);
+void clevo_leds_set_brightness_extern(enum led_brightness brightness);
+void clevo_leds_set_color_extern(u32 color);
+static bool dmi_string_in(enum dmi_field f, const char *str);
+
+// TODO The following should go into a seperate .c file, but for this to work more reworking is required in the tuxedo_keyboard structure.
+
+#include "clevo_leds.h"
+
+#include "clevo_interfaces.h"
+
+#include <linux/led-class-multicolor.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+
+#define CLEVO_KBD_BRIGHTNESS_MAX			0xff
+#define CLEVO_KBD_BRIGHTNESS_DEFAULT			0x00
+
+#define CLEVO_KBD_BRIGHTNESS_WHITE_MAX			0x02 // White only keyboards can only be off, half, or full brightness
+#define CLEVO_KBD_BRIGHTNESS_WHITE_DEFAULT		0x00
+
+#define CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5		0x05 // Devices <= Intel 7th gen had a different white control with 5 brightness values + off
+#define CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5_DEFAULT	0x00
+
+#define CLEVO_KB_COLOR_DEFAULT_RED			0xff
+#define CLEVO_KB_COLOR_DEFAULT_GREEN			0xff
+#define CLEVO_KB_COLOR_DEFAULT_BLUE			0xff
+#define CLEVO_KB_COLOR_DEFAULT				((CLEVO_KB_COLOR_DEFAULT_RED << 16) + (CLEVO_KB_COLOR_DEFAULT_GREEN << 8) + CLEVO_KB_COLOR_DEFAULT_BLUE)
+
+static enum clevo_kb_backlight_types clevo_kb_backlight_type = CLEVO_KB_BACKLIGHT_TYPE_NONE;
+static bool leds_initialized = false;
+
+/**
+ * Color scaling quirk list
+ */
+static void color_scaling(enum clevo_kb_backlight_types *type, u8 *red, u8 *green, u8 *blue)
+{
+	if (*type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		*red = (180 * *red) / 255;
+		*blue = (200 * *blue) / 255;
+	}
+}
+
+static int clevo_evaluate_set_white_brightness(u8 brightness)
+{
+	pr_debug("Set white brightness to %d\n", brightness);
+
+	return clevo_evaluate_method (CLEVO_CMD_SET_KB_WHITE_LEDS, brightness, NULL);
+}
+
+static int clevo_evaluate_set_rgb_brightness(u8 brightness)
+{
+	pr_debug("Set RGB brightness to %d\n", brightness);
+
+	return clevo_evaluate_method (CLEVO_CMD_SET_KB_RGB_LEDS, CLEVO_CMD_SET_KB_LEDS_SUB_RGB_BRIGHTNESS | brightness, NULL);
+}
+
+static int clevo_evaluate_set_rgb_color(u32 zone, u32 color)
+{
+	u32 cset = ((color & 0x0000FF) << 16) | ((color & 0xFF0000) >> 8) | ((color & 0x00FF00) >> 8);
+	u32 clevo_submethod_arg = zone | cset;
+
+	pr_debug("Set Color 0x%08x for region 0x%08x\n", color, zone);
+
+	return clevo_evaluate_method(CLEVO_CMD_SET_KB_RGB_LEDS, clevo_submethod_arg, NULL);
+}
+
+static int clevo_evaluate_set_keyboard_status(u8 state)
+{
+	u32 cmd = 0xE0000000;
+	TUXEDO_INFO("Set keyboard enabled to: %d\n", state);
+
+	if (state == 0) {
+		cmd |= 0x003001;
+	} else {
+		cmd |= 0x07F001;
+	}
+
+	return clevo_evaluate_method(CLEVO_CMD_SET_KB_RGB_LEDS, cmd, NULL);
+}
+
+static void clevo_leds_set_brightness(struct led_classdev *led_cdev __always_unused, enum led_brightness brightness) {
+	int ret = clevo_evaluate_set_white_brightness(brightness);
+	if (ret) {
+		pr_debug("clevo_leds_set_brightness(): clevo_evaluate_set_white_brightness() failed\n");
+		return;
+	}
+	led_cdev->brightness = brightness;
+}
+
+/*static void clevo_leds_set_brightness_mc(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int ret;
+	u32 zone, color;
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+
+	ret = clevo_evaluate_set_rgb_brightness(CLEVO_KBD_BRIGHTNESS_MAX);
+	if (ret) {
+		pr_debug("clevo_leds_set_brightness_mc(): clevo_evaluate_set_rgb_brightness() failed\n");
+		return;
+	}
+
+	zone = mcled_cdev->subled_info[0].channel;
+
+	led_mc_calc_color_components(mcled_cdev, brightness);
+	color = (mcled_cdev->subled_info[0].brightness << 16) +
+		(mcled_cdev->subled_info[1].brightness << 8) +
+		mcled_cdev->subled_info[2].brightness;
+
+	ret = clevo_evaluate_set_rgb_color(zone, color);
+	if (ret) {
+		pr_debug("clevo_leds_set_brightness_mc(): clevo_evaluate_set_rgb_color() failed\n");
+		return;
+	}
+	led_cdev->brightness = brightness;
+}*/
+
+// Temprary fix for KDE: KDE does only set one kbd_backlight brightness value, this version of the
+// function uses clevos built in brightness setting to set the whole keyboard brightness at once.
+// -> use clevo_evaluate_set_rgb_brightness() to set overall brightness via firmware instead of scaling
+//    the RGB values
+// -> update all clevo_mcled_cdevs brightness levels to refect that the firmware method sets the
+//    the whole keyboard brightness and not just one zone
+// This is a temporary fix until KDE handles multiple keyboard backlights correctly
+static struct led_classdev_mc clevo_mcled_cdevs[3]; // forward declaration
+static void clevo_leds_set_brightness_mc(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int ret;
+	u32 zone, color;
+	u8 red, green, blue;
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+
+	ret = clevo_evaluate_set_rgb_brightness(brightness);
+	if (ret) {
+		pr_debug("clevo_leds_set_brightness_mc(): clevo_evaluate_set_rgb_brightness() failed\n");
+		return;
+	}
+	clevo_mcled_cdevs[0].led_cdev.brightness = brightness;
+	clevo_mcled_cdevs[1].led_cdev.brightness = brightness;
+	clevo_mcled_cdevs[2].led_cdev.brightness = brightness;
+
+	zone = mcled_cdev->subled_info[0].channel;
+
+	red = mcled_cdev->subled_info[0].intensity;
+	green = mcled_cdev->subled_info[1].intensity;
+	blue = mcled_cdev->subled_info[2].intensity;
+
+	color_scaling(&clevo_kb_backlight_type, &red, &green, &blue);
+
+	color = (red << 16) +
+		(green << 8) +
+		blue;
+
+	ret = clevo_evaluate_set_rgb_color(zone, color);
+	if (ret) {
+		pr_debug("clevo_leds_set_brightness_mc(): clevo_evaluate_set_rgb_color() failed\n");
+	}
+}
+
+static struct led_classdev clevo_led_cdev = {
+	.name = "white:" LED_FUNCTION_KBD_BACKLIGHT,
+	.max_brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX,
+	.brightness_set = &clevo_leds_set_brightness,
+	.brightness = CLEVO_KBD_BRIGHTNESS_WHITE_DEFAULT,
+	.flags = LED_BRIGHT_HW_CHANGED
+};
+
+static struct mc_subled clevo_mcled_cdevs_subleds[3][3] = {
+	{
+		{
+			.color_index = LED_COLOR_ID_RED,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_RED,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_0
+		},
+		{
+			.color_index = LED_COLOR_ID_GREEN,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_GREEN,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_0
+		},
+		{
+			.color_index = LED_COLOR_ID_BLUE,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_BLUE,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_0
+		}
+	},
+	{
+		{
+			.color_index = LED_COLOR_ID_RED,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_RED,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_1
+		},
+		{
+			.color_index = LED_COLOR_ID_GREEN,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_GREEN,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_1
+		},
+		{
+			.color_index = LED_COLOR_ID_BLUE,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_BLUE,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_1
+		}
+	},
+	{
+		{
+			.color_index = LED_COLOR_ID_RED,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_RED,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_2
+		},
+		{
+			.color_index = LED_COLOR_ID_GREEN,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_GREEN,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_2
+		},
+		{
+			.color_index = LED_COLOR_ID_BLUE,
+			.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+			.intensity = CLEVO_KB_COLOR_DEFAULT_BLUE,
+			.channel = CLEVO_CMD_SET_KB_LEDS_SUB_RGB_ZONE_2
+		}
+	}
+};
+
+static struct led_classdev_mc clevo_mcled_cdevs[3] = {
+	{
+		.led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT,
+		.led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_MAX,
+		.led_cdev.brightness_set = &clevo_leds_set_brightness_mc,
+		.led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+		.num_colors = 3,
+		.subled_info = clevo_mcled_cdevs_subleds[0]
+	},
+	{
+		.led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT,
+		.led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_MAX,
+		.led_cdev.brightness_set = &clevo_leds_set_brightness_mc,
+		.led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+		.num_colors = 3,
+		.subled_info = clevo_mcled_cdevs_subleds[1]
+	},
+	{
+		.led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT,
+		.led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_MAX,
+		.led_cdev.brightness_set = &clevo_leds_set_brightness_mc,
+		.led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_DEFAULT,
+		.num_colors = 3,
+		.subled_info = clevo_mcled_cdevs_subleds[2]
+	}
+};
+
+int clevo_leds_init(struct platform_device *dev)
+{
+	int ret, i;
+	int status;
+	union acpi_object *result;
+	u32 result_fallback;
+
+	for (i = 0; i < 3; ++i) {
+		status = clevo_evaluate_method2(CLEVO_CMD_GET_SPECS, 0, &result);
+		if (!status) {
+			if (result->type == ACPI_TYPE_BUFFER) {
+				pr_debug("CLEVO_CMD_GET_SPECS result->buffer.pointer[0x0f]: 0x%02x\n", result->buffer.pointer[0x0f]);
+				clevo_kb_backlight_type = result->buffer.pointer[0x0f];
+				if (clevo_kb_backlight_type) {
+					status = clevo_evaluate_method(CLEVO_CMD_GET_BIOS_FEATURES_2, 0, &result_fallback);
+					if (!status) {
+						pr_debug("CLEVO_CMD_GET_BIOS_FEATURES_2 result_fallback: 0x%08x\n", result_fallback);
+						if (result_fallback & CLEVO_CMD_GET_BIOS_FEATURES_2_SUB_WHITE_ONLY_KB_MAX_5) {
+							clevo_led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5;
+							clevo_led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5_DEFAULT;
+						}
+					}
+					break;
+				} else {
+					pr_debug("clevo_kb_backlight_type 0x00 probably wrong, retrying...\n");
+					msleep(50);
+				}
+			}
+			else {
+				pr_err("CLEVO_CMD_GET_SPECS does not exist on this device or return value has wrong type, trying CLEVO_CMD_GET_BIOS_FEATURES\n");
+				status = -EINVAL;
+			}
+			ACPI_FREE(result);
+		}
+		else {
+			pr_notice("CLEVO_CMD_GET_SPECS does not exist on this device or failed, trying CLEVO_CMD_GET_BIOS_FEATURES_1\n");
+		}
+	}
+
+	if (status || clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_NONE) {
+		// check for devices <= Intel 8th gen (only white only, 3 zone RGB, or no backlight on these devices)
+		status = clevo_evaluate_method(CLEVO_CMD_GET_BIOS_FEATURES_1, 0, &result_fallback);
+		if (!status) {
+			pr_debug("CLEVO_CMD_GET_BIOS_FEATURES_1 result_fallback: 0x%08x\n", result_fallback);
+			if (result_fallback & CLEVO_CMD_GET_BIOS_FEATURES_1_SUB_3_ZONE_RGB_KB) {
+				clevo_kb_backlight_type = CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB;
+			}
+			else if (result_fallback & CLEVO_CMD_GET_BIOS_FEATURES_1_SUB_WHITE_ONLY_KB) {
+				clevo_kb_backlight_type = CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR;
+
+				status = clevo_evaluate_method(CLEVO_CMD_GET_BIOS_FEATURES_2, 0, &result_fallback);
+				if (!status) {
+					pr_debug("CLEVO_CMD_GET_BIOS_FEATURES_2 result_fallback: 0x%08x\n", result_fallback);
+					if (result_fallback & CLEVO_CMD_GET_BIOS_FEATURES_2_SUB_WHITE_ONLY_KB_MAX_5) {
+						clevo_led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5;
+						clevo_led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5_DEFAULT;
+					}
+				}
+				else {
+					pr_notice("CLEVO_CMD_GET_BIOS_FEATURES_2 does not exist on this device or failed\n");
+				}
+			}
+		}
+		else {
+			pr_notice("CLEVO_CMD_GET_BIOS_FEATURES_1 does not exist on this device or failed\n");
+		}
+	}
+	pr_debug("Keyboard backlight type: 0x%02x\n", clevo_kb_backlight_type);
+
+	// detection of N14xWUs white keyboard backlight with five steps fails
+	// old DMI strings may have trailing spaces (dmi_string_in for substring match)
+	if (dmi_string_in(DMI_BOARD_NAME, "N14xWU") ||
+	    dmi_string_in(DMI_BOARD_NAME, "N13xWU")) {
+		pr_notice("Use keyboard backlight quirk for TUXEDO IBP v3\n");
+		clevo_led_cdev.max_brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5;
+		clevo_led_cdev.brightness = CLEVO_KBD_BRIGHTNESS_WHITE_MAX_5_DEFAULT;
+	}
+
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR)
+		clevo_leds_set_brightness_extern(clevo_led_cdev.brightness);
+	else
+		clevo_leds_set_color_extern(CLEVO_KB_COLOR_DEFAULT);
+
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+		pr_debug("Registering fixed color leds interface\n");
+		ret = led_classdev_register(&dev->dev, &clevo_led_cdev);
+		if (ret) {
+			pr_err("Registering fixed color leds interface failed\n");
+			return ret;
+		}
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		clevo_evaluate_set_keyboard_status(1);
+		pr_debug("Registering single zone rgb leds interface\n");
+		ret = devm_led_classdev_multicolor_register(&dev->dev, &clevo_mcled_cdevs[0]);
+		if (ret) {
+			pr_err("Registering single zone rgb leds interface failed\n");
+			return ret;
+		}
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+		clevo_evaluate_set_keyboard_status(1);
+		pr_debug("Registering three zone rgb leds interface\n");
+		ret = devm_led_classdev_multicolor_register(&dev->dev, &clevo_mcled_cdevs[0]);
+		if (ret) {
+			pr_err("Registering three zone rgb zone 0 leds interface failed\n");
+			return ret;
+		}
+		ret = devm_led_classdev_multicolor_register(&dev->dev, &clevo_mcled_cdevs[1]);
+		if (ret) {
+			pr_err("Registering three zone rgb zone 1 leds interface failed\n");
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[0]);
+			return ret;
+		}
+		ret = devm_led_classdev_multicolor_register(&dev->dev, &clevo_mcled_cdevs[2]);
+		if (ret) {
+			pr_err("Registering three zone rgb zone 2 leds interface failed\n");
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[0]);
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[1]);
+			return ret;
+		}
+	}
+
+	leds_initialized = true;
+	return 0;
+}
+EXPORT_SYMBOL(clevo_leds_init);
+
+int clevo_leds_suspend(struct platform_device *dev)
+{
+	switch (clevo_kb_backlight_type) {
+	case CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB:
+	case CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB:
+		clevo_evaluate_set_keyboard_status(0);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(clevo_leds_suspend);
+
+int clevo_leds_resume(struct platform_device *dev)
+{
+	switch (clevo_kb_backlight_type) {
+	case CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB:
+	case CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB:
+		clevo_evaluate_set_keyboard_status(1);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(clevo_leds_resume);
+
+int clevo_leds_remove(struct platform_device *dev) {
+	if (leds_initialized) {
+		if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+			led_classdev_unregister(&clevo_led_cdev);
+		}
+		else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[0]);
+		}
+		else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[0]);
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[1]);
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[2]);
+		}
+	}
+
+	leds_initialized = false;
+
+	return 0;
+}
+EXPORT_SYMBOL(clevo_leds_remove);
+
+enum clevo_kb_backlight_types clevo_leds_get_backlight_type(void) {
+	return clevo_kb_backlight_type;
+}
+EXPORT_SYMBOL(clevo_leds_get_backlight_type);
+
+// TODO Don't reuse brightness_set as it is writing back the same brightness which could lead to race conditions.
+// Reimplement brightness_set instead without writing back brightness value like in uniwill_leds.h.
+void clevo_leds_restore_state_extern(void) {
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+		clevo_led_cdev.brightness_set(&clevo_led_cdev, clevo_led_cdev.brightness);
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, clevo_mcled_cdevs[0].led_cdev.brightness);
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, clevo_mcled_cdevs[0].led_cdev.brightness);
+		clevo_mcled_cdevs[1].led_cdev.brightness_set(&clevo_mcled_cdevs[1].led_cdev, clevo_mcled_cdevs[1].led_cdev.brightness);
+		clevo_mcled_cdevs[2].led_cdev.brightness_set(&clevo_mcled_cdevs[2].led_cdev, clevo_mcled_cdevs[2].led_cdev.brightness);
+	}
+}
+EXPORT_SYMBOL(clevo_leds_restore_state_extern);
+
+void clevo_leds_notify_brightness_change_extern(void) {
+	int status;
+	u32 result;
+
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+		status = clevo_evaluate_method(CLEVO_CMD_GET_KB_WHITE_LEDS, 0, &result);
+		pr_debug("Firmware set brightness: %u\n", result);
+		clevo_led_cdev.brightness = result;
+		led_classdev_notify_brightness_hw_changed(&clevo_led_cdev, result);
+	}
+}
+EXPORT_SYMBOL(clevo_leds_notify_brightness_change_extern);
+
+// TODO Not used externaly, but only on init. Should not be exposed because it would require a correct
+// led_classdev_notify_brightness_hw_changed implementation when used outside of init.
+void clevo_leds_set_brightness_extern(enum led_brightness brightness) {
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+		clevo_led_cdev.brightness_set(&clevo_led_cdev, brightness);
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, brightness);
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, brightness);
+		clevo_mcled_cdevs[1].led_cdev.brightness_set(&clevo_mcled_cdevs[1].led_cdev, brightness);
+		clevo_mcled_cdevs[2].led_cdev.brightness_set(&clevo_mcled_cdevs[2].led_cdev, brightness);
+	}
+}
+EXPORT_SYMBOL(clevo_leds_set_brightness_extern);
+
+// TODO Not used externaly, but only on init. Should not be exposed because it would require a correct
+// led_classdev_notify_brightness_hw_changed equivalent for color implementation when used outside of init.
+void clevo_leds_set_color_extern(u32 color) {
+	if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		clevo_mcled_cdevs[0].subled_info[0].intensity = (color >> 16) & 0xff;
+		clevo_mcled_cdevs[0].subled_info[1].intensity = (color >> 8) & 0xff;
+		clevo_mcled_cdevs[0].subled_info[2].intensity = color & 0xff;
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, clevo_mcled_cdevs[0].led_cdev.brightness);
+	}
+	else if (clevo_kb_backlight_type == CLEVO_KB_BACKLIGHT_TYPE_3_ZONE_RGB) {
+		clevo_mcled_cdevs[0].subled_info[0].intensity = (color >> 16) & 0xff;
+		clevo_mcled_cdevs[0].subled_info[1].intensity = (color >> 8) & 0xff;
+		clevo_mcled_cdevs[0].subled_info[2].intensity = color & 0xff;
+		clevo_mcled_cdevs[0].led_cdev.brightness_set(&clevo_mcled_cdevs[0].led_cdev, clevo_mcled_cdevs[0].led_cdev.brightness);
+		clevo_mcled_cdevs[1].subled_info[0].intensity = (color >> 16) & 0xff;
+		clevo_mcled_cdevs[1].subled_info[1].intensity = (color >> 8) & 0xff;
+		clevo_mcled_cdevs[1].subled_info[2].intensity = color & 0xff;
+		clevo_mcled_cdevs[1].led_cdev.brightness_set(&clevo_mcled_cdevs[1].led_cdev, clevo_mcled_cdevs[1].led_cdev.brightness);
+		clevo_mcled_cdevs[2].subled_info[0].intensity = (color >> 16) & 0xff;
+		clevo_mcled_cdevs[2].subled_info[1].intensity = (color >> 8) & 0xff;
+		clevo_mcled_cdevs[2].subled_info[2].intensity = color & 0xff;
+		clevo_mcled_cdevs[2].led_cdev.brightness_set(&clevo_mcled_cdevs[2].led_cdev, clevo_mcled_cdevs[2].led_cdev.brightness);
+	}
+}
+EXPORT_SYMBOL(clevo_leds_set_color_extern);
+
+MODULE_LICENSE("GPL");
+
+#endif // CLEVO_LEDS_H
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/clevo_wmi.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_wmi.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/clevo_wmi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/clevo_wmi.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/version.h>
+#include "clevo_interfaces.h"
+
+static int clevo_wmi_evaluate(u32 wmi_method_id, u32 wmi_arg, union acpi_object **result)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)sizeof(wmi_arg),
+					      &wmi_arg };
+	struct acpi_buffer acpi_buffer_out = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_result;
+	acpi_status status_acpi;
+	int return_status = 0;
+
+	status_acpi =
+		wmi_evaluate_method(CLEVO_WMI_METHOD_GUID, 0x00, wmi_method_id,
+				    &acpi_buffer_in, &acpi_buffer_out);
+
+	if (unlikely(ACPI_FAILURE(status_acpi))) {
+		pr_err("failed to evaluate wmi method\n");
+		return -EIO;
+	}
+
+	acpi_result = (union acpi_object *)acpi_buffer_out.pointer;
+	if (!acpi_result) {
+		pr_err("failed to evaluate WMI method\n");
+		return_status = -1;
+	}
+	else {
+		if (!IS_ERR_OR_NULL(result)) {
+			*result = acpi_result;
+		}
+	}
+
+	return return_status;
+}
+
+static int clevo_wmi_interface_method_call(u8 cmd, u32 arg, union acpi_object **result_value)
+{
+	return clevo_wmi_evaluate(cmd, arg, result_value);
+}
+
+static int clevo_wmi_interface_method_call_pkgbuf(u8 cmd, u8 *arg, u32 length, union acpi_object **result_value)
+{
+	pr_info("%s: unsupported wmi method call; ignoring cmd 0x%02x; please use acpi interface\n",
+			__func__, cmd);
+	return 0;
+}
+
+struct clevo_interface_t clevo_wmi_interface = {
+	.string_id = CLEVO_INTERFACE_WMI_STRID,
+	.method_call = clevo_wmi_interface_method_call,
+	.method_call_pkgbuf = clevo_wmi_interface_method_call_pkgbuf,
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int clevo_wmi_probe(struct wmi_device *wdev)
+#else
+static int clevo_wmi_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	int status;
+	union acpi_object *out_obj;
+
+	pr_debug("clevo_wmi driver probe\n");
+
+	if (!wmi_has_guid(CLEVO_WMI_EVENT_GUID)) {
+		pr_debug("probe: Clevo event guid missing\n");
+		return -ENODEV;
+	}
+
+	if (!wmi_has_guid(CLEVO_WMI_METHOD_GUID)) {
+		pr_debug("probe: Clevo method guid missing\n");
+		return -ENODEV;
+	}
+
+	// Since the WMI GUIDs aren't unique let's (at least)
+	// check the return of some "known existing general" method
+	status = clevo_wmi_evaluate(0x52, 0, &out_obj);
+	if (status < 0) {
+		pr_debug("probe: Clevo GUIDs present but method call failed\n");
+		return -ENODEV;
+	}
+	if (out_obj->type != ACPI_TYPE_INTEGER || (out_obj->type == ACPI_TYPE_INTEGER && (u32)out_obj->integer.value == 0xffffffff)) {
+		pr_debug(
+			"probe: Clevo GUIDs present but method returned unexpected value\n");
+		ACPI_FREE(out_obj);
+		return -ENODEV;
+	}
+	ACPI_FREE(out_obj);
+
+	// Add this interface
+	clevo_keyboard_add_interface(&clevo_wmi_interface);
+
+	pr_info("interface initialized\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int clevo_wmi_remove(struct wmi_device *wdev)
+#else
+static void clevo_wmi_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("clevo_wmi driver remove\n");
+	clevo_keyboard_remove_interface(&clevo_wmi_interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static void clevo_wmi_notify(struct wmi_device *wdev, union acpi_object *dummy)
+{
+	u32 event_value;
+	union acpi_object *out_obj;
+	int status;
+
+	status = clevo_wmi_evaluate(0x01, 0, &out_obj);
+	if (!status) {
+		if (out_obj->type == ACPI_TYPE_INTEGER) {
+			event_value = (u32)out_obj->integer.value;
+		} else {
+			pr_err("return type not integer, use clevo_evaluate_method2\n");
+		}
+		ACPI_FREE(out_obj);
+	}
+	pr_debug("clevo_wmi notify\n");
+	if (!IS_ERR_OR_NULL(clevo_wmi_interface.event_callb)) {
+		// Execute registered callback
+		clevo_wmi_interface.event_callb(event_value);
+	}
+}
+
+static const struct wmi_device_id clevo_wmi_device_ids[] = {
+	// Listing one should be enough, for a driver that "takes care of all anyways"
+	// also prevents probe (and handling) per "device"
+	{ .guid_string = CLEVO_WMI_EVENT_GUID },
+	{ }
+};
+
+static struct wmi_driver clevo_wmi_driver = {
+	.driver = {
+		.name = CLEVO_INTERFACE_WMI_STRID,
+		.owner = THIS_MODULE
+	},
+	.id_table = clevo_wmi_device_ids,
+	.probe = clevo_wmi_probe,
+	.remove = clevo_wmi_remove,
+	.notify = clevo_wmi_notify,
+};
+
+module_wmi_driver(clevo_wmi_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for Clevo WMI interface");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, clevo_wmi_device_ids);
+MODULE_ALIAS_CLEVO_WMI();
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/gxtp7380/gxtp7380.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/gxtp7380/gxtp7380.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/gxtp7380/gxtp7380.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/gxtp7380/gxtp7380.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,75 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/version.h>
+
+#define DRIVER_NAME "gxtp7380"
+
+static int gxtp7380_add(struct acpi_device *device)
+{
+	kobject_uevent(&device->dev.kobj, KOBJ_ADD);
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int gxtp7380_remove(struct acpi_device *device)
+#else
+static void gxtp7380_remove(struct acpi_device *device)
+#endif
+{
+	kobject_uevent(&device->dev.kobj, KOBJ_REMOVE);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+	return 0;
+#endif
+}
+
+static void gxtp7380_notify(struct acpi_device *device, u32 event)
+{
+	kobject_uevent(&device->dev.kobj, KOBJ_CHANGE);
+}
+
+static const struct acpi_device_id gxtp7380_device_ids[] = {
+	{ "GXTP7380", 0 },
+	{ "", 0 }
+};
+
+static struct acpi_driver gxtp7380_driver = {
+	.name = DRIVER_NAME,
+	.class = DRIVER_NAME,
+	.ids = gxtp7380_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
+	.ops = {
+		.add = gxtp7380_add,
+		.remove = gxtp7380_remove,
+		.notify = gxtp7380_notify,
+	},
+};
+
+module_acpi_driver(gxtp7380_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Touch panel disable, notify driver");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(acpi, gxtp7380_device_ids);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/gxtp7380/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/gxtp7380/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/gxtp7380/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/gxtp7380/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += gxtp7380.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291/ite_8291.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291/ite_8291.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291/ite_8291.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291/ite_8291.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,912 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2020-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+/*
+ * All numbers in hex format
+ * 
+ * Turn off (same as "set params" described below). This is called with all other bytes set to zero when turned-off.
+ * Control: 08 01 00 00 00 00 00 00
+ * 
+ * Set brightness only
+ * Control: 09 02 [brightness] 00 00 00 00 00
+ * 
+ * Announce 64 byte data chunks (for "user mode" 0x33). To be followed by specified number on chunks on interrupt endpoint.
+ * Control: 12 00 00 [nr of chunks] 00 00 00 00
+ * 
+ * [nr of chunks]
+ * 	1 -> 8
+ * 
+ * Announce row data chunk (for "user mode" 0x33). To be followed by 64 bytes of row data on interrupt endpoint.
+ * Control: 16 00 [row number] 00 00 00 00 00
+ * 
+ * [row number]
+ * 	0 -> 5
+ * 
+ * 
+ * Most "special modes" uses seven colors that can be defined individually
+ * Set color define
+ * Control: 14 00 [color define number] [red] [green] [blue] 00 00
+ * 
+ * [color define number]
+ * 	1 -> 7
+ * 
+ * 
+ * Set params
+ * Control: 08 [power state] [anim mode] [speed] [brightness] 08 [behaviour] 00
+ * 
+ * [power state]
+ * 	01 off
+ * 	02 on
+ * 
+ * [anim mode]
+ * 	02 breath
+ * 	03 wave ([behaviour]: direction)
+ * 	04 reactive ([behaviour]: key mode)
+ * 	05 rainbow (no color set)
+ * 	06 ripple ([behaviour]: key mode)
+ * 	09 marquee
+ * 	0a raindrop
+ * 	0e aurora ([behaviour]: key mode)
+ * 	11 spark ([behaviour]: key mode)
+ * 
+ * 	33 per key control, needs additional "data announcing", then data on interrupt endpoint
+ * 
+ * [speed]
+ * 	0a -> 01
+ * 
+ * [brightness]
+ * 	00 -> 32
+ * 
+ * [behaviour]
+ * 	00 when not used, otherwise dependent on [anim mode]
+ * 
+ * [behaviour]: direction
+ * 	01 left to right
+ * 	02 right to left
+ * 	03 bottom to top
+ * 	04 top to bottom
+ * 
+ * [behaviour]: key mode
+ * 	00 key press
+ * 	01 auto
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/usb.h>
+#include <linux/hid.h>
+#include <linux/dmi.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/of.h>
+
+// USB HID control data write size
+#define HID_DATA_SIZE 8
+
+// led_classdev names, default and max brightness
+//#define ITE8291_KBD_BRIGHTNESS_MAX	0xff
+#define ITE8291_KBD_BRIGHTNESS_MAX	0x32
+#define ITE8291_KBD_BRIGHTNESS_DEFAULT	0x00
+
+#define ITE8291_KB_COLOR_DEFAULT_RED	0xff
+#define ITE8291_KB_COLOR_DEFAULT_GREEN	0xff
+#define ITE8291_KB_COLOR_DEFAULT_BLUE	0xff
+#define ITE8291_KB_COLOR_DEFAULT	((UNIWILL_KB_COLOR_DEFAULT_RED << 16) + (UNIWILL_KB_COLOR_DEFAULT_GREEN << 8) + UNIWILL_KB_COLOR_DEFAULT_BLUE)
+
+#define ITE8291_LEDS_PER_ROW_MAX	21
+// Data length needs one byte (0x00) initial padding for the sending function
+// and one byte (also seemingly 0x00) before the color data starts
+#define ITE8291_ROW_DATA_PADDING	(1 + 1)
+#define ITE8291_ROW_DATA_LENGTH		(ITE8291_ROW_DATA_PADDING + (ITE8291_LEDS_PER_ROW_MAX * 3))
+#define ITE8291_NR_ROWS			6
+
+#define ITE8291_PARAM_MODE_USER		0x33
+
+struct ite8291_driver_data_t {
+	u16 bcd_device;
+	struct hid_device *hid_dev;
+	void *device_data;
+	bool device_has_buffer_input_control;
+	bool device_buffer_input;
+	int (*device_add)(struct hid_device *);
+	int (*device_remove)(struct hid_device *);
+	int (*device_write_on)(struct hid_device *);
+	int (*device_write_off)(struct hid_device *);
+	int (*device_write_state)(struct hid_device *);
+};
+
+// Per key device specific defines
+typedef u8 row_data_t[ITE8291_NR_ROWS][ITE8291_ROW_DATA_LENGTH];
+struct ite8291_driver_data_perkey_t {
+	row_data_t row_data;
+	u8 brightness;
+	struct led_classdev_mc mcled_cdevs[ITE8291_NR_ROWS][ITE8291_LEDS_PER_ROW_MAX];
+	struct mc_subled mcled_cdevs_subleds[ITE8291_NR_ROWS][ITE8291_LEDS_PER_ROW_MAX][3];
+};
+
+static int ite8291_perkey_add(struct hid_device *);
+static int ite8291_perkey_remove(struct hid_device *);
+static int ite8291_perkey_write_on(struct hid_device *);
+static int ite8291_perkey_write_off(struct hid_device *);
+static int ite8291_perkey_write_state(struct hid_device *);
+
+// Zones device specific defines
+#define ITE8291_NR_ZONES 			4
+#define ITE8291_KBD_ZONES_BRIGHTNESS_MAX	0x32
+#define ITE8291_KBD_ZONES_BRIGHTNESS_DEFAULT	0x00
+struct ite8291_driver_data_zones_t {
+	u8 brightness;
+	struct led_classdev_mc mcled_cdevs[ITE8291_NR_ZONES];
+	struct mc_subled mcled_cdevs_subleds[ITE8291_NR_ZONES][3];
+};
+
+static int ite8291_zones_add(struct hid_device *);
+static int ite8291_zones_remove(struct hid_device *);
+static int ite8291_zones_write_on(struct hid_device *);
+static int ite8291_zones_write_off(struct hid_device *);
+static int ite8291_zones_write_state(struct hid_device *);
+
+/**
+ * Color scaling quirk list
+ */
+static void color_scaling(struct hid_device *hdev, u8 *red, u8 *green, u8 *blue, bool row_col_set, u8 row, u8 col)
+{
+	struct ite8291_driver_data_t *driver_data = hid_get_drvdata(hdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	if (dmi_match(DMI_PRODUCT_SKU, "STEPOL1XA04") && hdev->product == 0x600a) {
+		*red = (126 * *red) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05") && hdev->product == 0x600a) {
+		*red = (200 * *red) / 255;
+		*blue = (220 * *blue) / 255;
+
+		// top row: reduce some additional violett
+		if(row_col_set && row == 5) {
+			*red = ( 230 * *red) / 255;
+			*blue = ( 200 * *blue) / 255;
+		}
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XA05")) {
+		*red = (128 * *red) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05") &&
+		   hdev->product == 0xce00 && driver_data->bcd_device == 0x0002) {
+		*red = (255 * *red) / 255;
+		*green = (220 * *green) / 255;
+		*blue = (200 * *blue) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS17I06") &&
+		   hdev->product == 0xce00 && driver_data->bcd_device == 0x0002) {
+		*green = (180 * *green) / 255;
+		*blue = (180 * *blue) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS17I06") &&
+		   hdev->product == 0x600a) {
+		*red = (200 * *red) / 255;
+		*blue = (220 * *blue) / 255;
+	} else if ((dmi_match(DMI_PRODUCT_SKU, "STELLSL15I06") || dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I06"))
+		   && hdev->product == 0x600b) {
+		// all keys: reduce pink
+		*red = (155 * *red) / 255;
+		*blue = (140 * *blue) / 255;
+
+		// bottom row: reduce green (adding red and blue)
+		if (row_col_set && row == 0) {
+			*red = (279 * *red) / 255;
+			*blue = (282 * *blue) / 255;
+		}
+
+		// top row: reduce violett
+		if(row_col_set && row == 5) {
+			*red = (148 * *red) / 255;
+			*blue = (137 * *blue) / 255;
+		}
+	} else if ((dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I07") || dmi_match(DMI_PRODUCT_SKU, "STELLARIS16A07"))
+		   && hdev->product == 0x600b) {
+		// all keys: reduce pink
+		*red = (170 * *red) / 255;
+		*blue = (125 * *blue) / 255;
+	} else if (dmi_match(DMI_BOARD_NAME, "X5KK45xS_X5SP45xS")) {
+		*red = (180 * *red) / 255;
+	} else {
+		*green = (126 * *green) / 255;
+		*blue = (120 * *blue) / 255;
+	}
+#endif
+}
+
+/**
+ * Set color for specified [row, column] in row based data structure
+ * 
+ * @param row_data Data structure to fill
+ * @param row Row number 0 - 5
+ * @param column Column number 0 - 20
+ * @param red Red brightness 0x00 - 0xff
+ * @param green Green brightness 0x00 - 0xff
+ * @param blue Blue brightness 0x00 - 0xff
+ * 
+ * @returns 0 on success, otherwise error
+ */
+static int row_data_set(struct hid_device *hdev, row_data_t row_data, int row, int column, u8 red, u8 green, u8 blue)
+{
+	int column_index_red, column_index_green, column_index_blue;
+
+	color_scaling(hdev, &red, &green, &blue, true, row, column);
+
+	if (row < 0 || row >= ITE8291_NR_ROWS)
+		return -EINVAL;
+
+	if (column < 0 || column >= ITE8291_LEDS_PER_ROW_MAX)
+		return -EINVAL;
+
+	column_index_red = ITE8291_ROW_DATA_PADDING + (2 * ITE8291_LEDS_PER_ROW_MAX) + column;
+	column_index_green = ITE8291_ROW_DATA_PADDING + (1 * ITE8291_LEDS_PER_ROW_MAX) + column;
+	column_index_blue = ITE8291_ROW_DATA_PADDING + (0 * ITE8291_LEDS_PER_ROW_MAX) + column;
+
+	row_data[row][column_index_red] = red;
+	row_data[row][column_index_green] = green;
+	row_data[row][column_index_blue] = blue;
+
+	return 0;
+}
+
+/**
+ * Set brightness only
+ * 09 02 [brightness] 00 00 00 00 00
+ */
+/*
+static int ite8291_write_brightness(struct hid_device *hdev, u8 brightness)
+{
+	int result = 0;
+	u8 *buf;
+	if (hdev == NULL)
+		return -ENODEV;
+
+	buf = kzalloc(HID_DATA_SIZE, GFP_KERNEL);
+	buf[0] = 0x09;
+	buf[1] = 0x02;
+	buf[2] = brightness;
+	buf[3] = 0x00;
+	buf[4] = 0x00;
+	buf[5] = 0x00;
+	buf[6] = 0x00;
+	buf[7] = 0x00;
+
+	result = hid_hw_raw_request(hdev, buf[0], buf, HID_DATA_SIZE,
+				    HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+	kfree(buf);
+
+	return result;
+}
+*/
+
+/**
+ * Write control data
+ */
+static int ite8291_write_control(struct hid_device *hdev, u8 *ctrl_data)
+{
+	int result = 0;
+	u8 *buf;
+	if (hdev == NULL)
+		return -ENODEV;
+
+	buf = kzalloc(HID_DATA_SIZE, GFP_KERNEL);
+
+	memcpy(buf, ctrl_data, (size_t) 8);
+
+	result = hid_hw_raw_request(hdev, buf[0], buf, HID_DATA_SIZE,
+				    HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+	kfree(buf);
+
+	return result;
+}
+
+#if 0
+/**
+ * *experimental*
+ * 
+ * Write color (and brightness) to the whole keyboard (chunk-wise)
+ */
+static int ite8291_write_color_full(struct hid_device *hdev, u8 red, u8 green, u8 blue, u8 brightness)
+{
+	int result = 0, i, j;
+	int nr_data_packets = 0x08;
+	u8 ctrl_params[] = { 0x08,
+			     0x02,
+			     ITE8291_PARAM_MODE_USER,
+			     0x00,
+			     brightness % (ITE8291_KBD_BRIGHTNESS_MAX + 1),
+			     0x00,
+			     0x00,
+			     0x00 };
+	u8 ctrl_announce_data[] = { 0x12, 0x00, 0x00, (u8)nr_data_packets,
+				    0x00, 0x00, 0x00, 0x00 };
+	int data_packet_length = 65;
+	u8 *data_buf;
+	if (hdev == NULL)
+		return -ENODEV;
+
+	color_scaling(hdev, &red, &green, &blue);
+
+	ite8291_write_control(hdev, ctrl_params);
+	ite8291_write_control(hdev, ctrl_announce_data);
+
+	data_buf = kzalloc(nr_data_packets * data_packet_length, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	for (j = 0; j < nr_data_packets; ++j) {
+		for (i = 1; i < data_packet_length; ++i) {
+			if (((i + 2) % 4) == 0)
+				data_buf[(j * data_packet_length) + i] = red;
+			if (((i + 1) % 4) == 0)
+				data_buf[(j * data_packet_length) + i] = green;
+			if (((i) % 4) == 0)
+				data_buf[(j * data_packet_length) + i] = blue;
+		}
+	}
+
+	for (j = 0; j < nr_data_packets; ++j) {
+		result = hdev->ll_driver->output_report(
+			hdev, &data_buf[j * data_packet_length],
+			data_packet_length);
+		if (result < 0)
+			return result;
+	}
+
+	kfree(data_buf);
+	return result;
+}
+#endif
+
+/**
+ * Write color (and brightness) to the whole keyboard from row data
+ */
+static int ite8291_write_rows(struct hid_device *hdev, row_data_t row_data, u8 brightness)
+{
+	int result = 0, row_index;
+	u8 ctrl_params[] = { 0x08,
+			     0x02,
+			     ITE8291_PARAM_MODE_USER,
+			     0x00,
+			     brightness > ITE8291_KBD_BRIGHTNESS_MAX ? ITE8291_KBD_BRIGHTNESS_MAX : brightness,
+			     0x00,
+			     0x00,
+			     0x00 };
+	u8 ctrl_announce_row_data[] = { 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+	if (hdev == NULL)
+		return -ENODEV;
+
+	ite8291_write_control(hdev, ctrl_params);
+
+	for (row_index = 0; row_index < ITE8291_NR_ROWS; ++row_index) {
+		ctrl_announce_row_data[2] = row_index;
+		ite8291_write_control(hdev, ctrl_announce_row_data);
+		result = hdev->ll_driver->output_report(
+			hdev, row_data[row_index], ITE8291_ROW_DATA_LENGTH);
+		if (result < 0)
+			return result;
+	}
+	if (result > 0)
+		result = 0;
+
+	return result;
+}
+
+static void stop_hw(struct hid_device *hdev)
+{
+	hid_hw_power(hdev, PM_HINT_NORMAL);
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+}
+
+static int start_hw(struct hid_device *hdev)
+{
+	int result;
+	result = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (result) {
+		pr_err("hid_hw_start failed\n");
+		goto err_stop_hw;
+	}
+
+	hid_hw_power(hdev, PM_HINT_FULLON);
+
+	result = hid_hw_open(hdev);
+	if (result) {
+		pr_err("hid_hw_open failed\n");
+		goto err_stop_hw;
+	}
+
+	return 0;
+
+err_stop_hw:
+	stop_hw(hdev);
+	return result;
+}
+
+/*
+static void leds_set_brightness_mc (struct led_classdev *led_cdev, enum led_brightness brightness) {
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hdev = to_hid_device(dev);
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+
+	led_mc_calc_color_components(mcled_cdev, brightness);
+	row_data_set(hdev, ite8291_driver_data->row_data, mcled_cdev->subled_info[0].channel / ITE8291_LEDS_PER_ROW_MAX,
+		     mcled_cdev->subled_info[0].channel % ITE8291_LEDS_PER_ROW_MAX,
+		     mcled_cdev->subled_info[0].brightness, mcled_cdev->subled_info[1].brightness,
+		     mcled_cdev->subled_info[2].brightness);
+
+	ite8291_write_state(ite8291_driver_data);
+}
+*/
+
+static void leds_set_brightness_mc (struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int i, j;
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hdev = to_hid_device(dev);
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_perkey_t *device_data = ite8291_driver_data->device_data;
+
+	pr_debug("leds_set_brightness_mc: channel: %d, brightness: %d, saved brightness: %d, red: %d, green: %d, blue: %d\n",
+		 mcled_cdev->subled_info[0].channel, brightness, device_data->brightness, mcled_cdev->subled_info[0].intensity,
+		 mcled_cdev->subled_info[1].intensity, mcled_cdev->subled_info[2].intensity);
+
+	device_data->brightness = brightness;
+
+	for (i = 0; i < ITE8291_NR_ROWS; ++i) {
+		for (j = 0; j < ITE8291_LEDS_PER_ROW_MAX; ++j) {
+			device_data->mcled_cdevs[i][j].led_cdev.brightness = brightness;
+		}
+	}
+
+	row_data_set(hdev, device_data->row_data, mcled_cdev->subled_info[0].channel / ITE8291_LEDS_PER_ROW_MAX,
+		     mcled_cdev->subled_info[0].channel % ITE8291_LEDS_PER_ROW_MAX,
+		     mcled_cdev->subled_info[0].intensity, mcled_cdev->subled_info[1].intensity,
+		     mcled_cdev->subled_info[2].intensity);
+
+	if (!ite8291_driver_data->device_buffer_input)
+		ite8291_perkey_write_state(hdev);
+}
+
+static int register_leds(struct hid_device *hdev)
+{
+	int res, i, j, k, l;
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_perkey_t *device_data = ite8291_driver_data->device_data;
+
+	for (i = 0; i < ITE8291_NR_ROWS; ++i) {
+		for (j = 0; j < ITE8291_LEDS_PER_ROW_MAX; ++j) {
+			device_data->mcled_cdevs[i][j].led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT;
+			device_data->mcled_cdevs[i][j].led_cdev.max_brightness = ITE8291_KBD_BRIGHTNESS_MAX;
+			device_data->mcled_cdevs[i][j].led_cdev.brightness_set = &leds_set_brightness_mc;
+			device_data->mcled_cdevs[i][j].led_cdev.brightness = ITE8291_KBD_BRIGHTNESS_DEFAULT;
+			device_data->mcled_cdevs[i][j].num_colors = 3;
+			device_data->mcled_cdevs[i][j].subled_info = device_data->mcled_cdevs_subleds[i][j];
+			device_data->mcled_cdevs[i][j].subled_info[0].color_index = LED_COLOR_ID_RED;
+			device_data->mcled_cdevs[i][j].subled_info[0].intensity = ITE8291_KB_COLOR_DEFAULT_RED;
+			device_data->mcled_cdevs[i][j].subled_info[0].channel = ITE8291_LEDS_PER_ROW_MAX * i + j;
+			device_data->mcled_cdevs[i][j].subled_info[1].color_index = LED_COLOR_ID_GREEN;
+			device_data->mcled_cdevs[i][j].subled_info[1].intensity = ITE8291_KB_COLOR_DEFAULT_GREEN;
+			device_data->mcled_cdevs[i][j].subled_info[1].channel = ITE8291_LEDS_PER_ROW_MAX * i + j;
+			device_data->mcled_cdevs[i][j].subled_info[2].color_index = LED_COLOR_ID_BLUE;
+			device_data->mcled_cdevs[i][j].subled_info[2].intensity = ITE8291_KB_COLOR_DEFAULT_BLUE;
+			device_data->mcled_cdevs[i][j].subled_info[2].channel = ITE8291_LEDS_PER_ROW_MAX * i + j;
+
+			res = devm_led_classdev_multicolor_register(&hdev->dev, &device_data->mcled_cdevs[i][j]);
+			if (res) {
+				for (k = 0; k <= i; ++k) {
+					for (l = 0; l <= j; ++l) {
+						devm_led_classdev_multicolor_unregister(&hdev->dev, &device_data->mcled_cdevs[i][j]);
+					}
+				}
+				return res;
+			}
+		}
+	}
+	return 0;
+}
+
+static void unregister_leds(struct hid_device *hdev) {
+	int i, j;
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_perkey_t *device_data = ite8291_driver_data->device_data;
+
+	for (i = 0; i < ITE8291_NR_ROWS; ++i) {
+		for (j = 0; j < ITE8291_LEDS_PER_ROW_MAX; ++j) {
+			devm_led_classdev_multicolor_unregister(&hdev->dev, &device_data->mcled_cdevs[i][j]);
+		}
+	}
+}
+
+static int ite8291_perkey_add(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+	struct ite8291_driver_data_perkey_t *perkey_data;
+	int result, i, j;
+
+	driver_data = hid_get_drvdata(hdev);
+
+	perkey_data = devm_kzalloc(&hdev->dev, sizeof(*perkey_data), GFP_KERNEL);
+	if (!perkey_data)
+		return -ENOMEM;
+
+	driver_data->device_data = perkey_data;
+
+	perkey_data->brightness = ITE8291_KBD_BRIGHTNESS_DEFAULT;
+	for (i = 0; i < ITE8291_NR_ROWS; ++i) {
+		for (j = 0; j < ITE8291_LEDS_PER_ROW_MAX; ++j) {
+			row_data_set(hdev, perkey_data->row_data, i, j,
+				     ITE8291_KB_COLOR_DEFAULT_RED,
+				     ITE8291_KB_COLOR_DEFAULT_GREEN,
+				     ITE8291_KB_COLOR_DEFAULT_BLUE);
+		}
+	}
+
+	/*
+	for (i = 0; i < ITE8291_NR_ROWS; ++i) {
+		for (j = 0; j < ITE8291_LEDS_PER_ROW_MAX; ++j) {
+			row_data_set(hdev, ite8291_driver_data->row_data, i, j,
+				     ITE8291_KB_COLOR_DEFAULT_RED * ITE8291_KBD_BRIGHTNESS_DEFAULT / ITE8291_KBD_BRIGHTNESS_MAX,
+				     ITE8291_KB_COLOR_DEFAULT_GREEN * ITE8291_KBD_BRIGHTNESS_DEFAULT / ITE8291_KBD_BRIGHTNESS_MAX,
+				     ITE8291_KB_COLOR_DEFAULT_BLUE * ITE8291_KBD_BRIGHTNESS_DEFAULT / ITE8291_KBD_BRIGHTNESS_MAX);
+		}
+	}
+	*/
+
+	result = register_leds(hdev);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static int ite8291_perkey_remove(struct hid_device *hdev)
+{
+	unregister_leds(hdev);
+	return 0;
+}
+
+static int ite8291_perkey_write_on(struct hid_device *hdev)
+{
+	return 0;
+}
+
+static int ite8291_perkey_write_off(struct hid_device *hdev)
+{
+	u8 ctrl_params_off[] = {0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	return ite8291_write_control(hdev, ctrl_params_off);
+}
+
+static int ite8291_perkey_write_state(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_perkey_t *device_data = driver_data->device_data;
+	return ite8291_write_rows(hdev, device_data->row_data, device_data->brightness);
+}
+
+static void leds_zones_set_brightness_mc(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int i;
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hdev = to_hid_device(dev);
+	struct ite8291_driver_data_t *driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_zones_t *device_data = driver_data->device_data;
+
+	pr_debug("leds_set_brightness_mc: channel: %d, brightness: %d, saved brightness: %d, red: %d, green: %d, blue: %d\n",
+		 mcled_cdev->subled_info[0].channel, brightness, device_data->brightness, mcled_cdev->subled_info[0].intensity,
+		 mcled_cdev->subled_info[1].intensity, mcled_cdev->subled_info[2].intensity);
+
+	device_data->brightness = brightness;
+
+	for (i = 0; i < ITE8291_NR_ZONES; ++i) {
+		device_data->mcled_cdevs[i].led_cdev.brightness = brightness;
+	}
+
+	ite8291_zones_write_state(hdev);
+}
+
+static int ite8291_zones_add(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+	struct ite8291_driver_data_zones_t *zones_data;
+	int result, i, k;
+
+	driver_data = hid_get_drvdata(hdev);
+
+	zones_data = devm_kzalloc(&hdev->dev, sizeof(*zones_data), GFP_KERNEL);
+	if (!zones_data)
+		return -ENOMEM;
+
+	driver_data->device_data = zones_data;
+
+	for (i = 0; i < ITE8291_NR_ZONES; ++i) {
+		zones_data->mcled_cdevs[i].led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT;
+		zones_data->mcled_cdevs[i].led_cdev.max_brightness = ITE8291_KBD_ZONES_BRIGHTNESS_MAX;
+		zones_data->mcled_cdevs[i].led_cdev.brightness_set = &leds_zones_set_brightness_mc;
+		zones_data->mcled_cdevs[i].led_cdev.brightness = ITE8291_KBD_ZONES_BRIGHTNESS_DEFAULT;
+		zones_data->mcled_cdevs[i].num_colors = 3;
+		zones_data->mcled_cdevs[i].subled_info = zones_data->mcled_cdevs_subleds[i];
+		zones_data->mcled_cdevs[i].subled_info[0].color_index = LED_COLOR_ID_RED;
+		zones_data->mcled_cdevs[i].subled_info[0].intensity = 255;
+		zones_data->mcled_cdevs[i].subled_info[0].channel = i;
+		zones_data->mcled_cdevs[i].subled_info[1].color_index = LED_COLOR_ID_GREEN;
+		zones_data->mcled_cdevs[i].subled_info[1].intensity = 255;
+		zones_data->mcled_cdevs[i].subled_info[1].channel = i;
+		zones_data->mcled_cdevs[i].subled_info[2].color_index = LED_COLOR_ID_BLUE;
+		zones_data->mcled_cdevs[i].subled_info[2].intensity = 255;
+		zones_data->mcled_cdevs[i].subled_info[2].channel = i;
+
+		result = devm_led_classdev_multicolor_register(&hdev->dev, &zones_data->mcled_cdevs[i]);
+		if (result) {
+			for (k = 0; k < i; ++k)
+				devm_led_classdev_multicolor_unregister(&hdev->dev, &zones_data->mcled_cdevs[k]);
+			return result;
+		}
+	}
+
+	return 0;
+}
+
+static int ite8291_zones_remove(struct hid_device *hdev)
+{
+	int i;
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_zones_t *zones_data = ite8291_driver_data->device_data;
+
+	for (i = 0; i < ITE8291_NR_ZONES; ++i)
+		devm_led_classdev_multicolor_unregister(&hdev->dev, &zones_data->mcled_cdevs[i]);
+
+	return 0;
+}
+
+static int ite8291_zones_write_on(struct hid_device *hdev)
+{
+	ite8291_write_control(hdev, (u8[]){ 0x1a, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01 });
+	return 0;
+}
+
+static int ite8291_zones_write_off(struct hid_device *hdev)
+{
+	ite8291_write_control(hdev, (u8[]){ 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+	ite8291_write_control(hdev, (u8[]){ 0x12, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 });
+	ite8291_write_control(hdev, (u8[]){ 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+	ite8291_write_control(hdev, (u8[]){ 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+	ite8291_write_control(hdev, (u8[]){ 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 });
+	return 0;
+}
+
+static int ite8291_zones_write_state(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct ite8291_driver_data_zones_t *zones_data = ite8291_driver_data->device_data;
+	struct led_classdev_mc *mcled_cdev;
+	int i;
+	u8 red, green, blue;
+
+	u8 brightness  = zones_data->mcled_cdevs[0].led_cdev.brightness;
+
+	for (i = 0; i < ITE8291_NR_ZONES; ++i) {
+		mcled_cdev = &zones_data->mcled_cdevs[i];
+		red = mcled_cdev->subled_info[0].intensity;
+		green = mcled_cdev->subled_info[1].intensity;
+		blue = mcled_cdev->subled_info[2].intensity;
+		color_scaling(hdev, &red, &green, &blue, false, 0, 0);
+		ite8291_write_control(hdev, (u8[]){ 0x14, 0x00, i + 1, red, green, blue, 0x00, 0x00 });
+	}
+
+	ite8291_write_control(hdev, (u8[]){ 0x08, 0x02, 0x01, 0x03, brightness, 0x08, 0x00, 0x00 });
+
+	return 0;
+}
+
+static int ite8291_driver_data_setup(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+
+	struct usb_device *usb_dev;
+	struct usb_device_descriptor *usb_desc;
+
+	driver_data = hid_get_drvdata(hdev);
+
+	usb_dev = to_usb_device(hdev->dev.parent->parent);
+	usb_desc = &(usb_dev->descriptor);
+
+	driver_data->hid_dev = hdev;
+	driver_data->bcd_device = le16_to_cpu(usb_desc->bcdDevice);
+
+	// Initialize device specific data
+	if (hdev->product == 0xce00 && driver_data->bcd_device == 0x0002) {
+		driver_data->device_has_buffer_input_control = false;
+		driver_data->device_add = ite8291_zones_add;
+		driver_data->device_remove = ite8291_zones_remove;
+		driver_data->device_write_on = ite8291_zones_write_on;
+		driver_data->device_write_off = ite8291_zones_write_off;
+		driver_data->device_write_state = ite8291_zones_write_state;
+	} else {
+		driver_data->device_has_buffer_input_control = true;
+		driver_data->device_add = ite8291_perkey_add;
+		driver_data->device_remove = ite8291_perkey_remove;
+		driver_data->device_write_on = ite8291_perkey_write_on;
+		driver_data->device_write_off = ite8291_perkey_write_off;
+		driver_data->device_write_state = ite8291_perkey_write_state;
+	}
+
+	return 0;
+}
+
+static ssize_t buffer_input_show(struct device *device,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct hid_device *hdev;
+	struct ite8291_driver_data_t *driver_data;
+	hdev = container_of(device, struct hid_device, dev);
+	driver_data = hid_get_drvdata(hdev);
+	return sysfs_emit(buf, "%d\n", (bool) driver_data->device_buffer_input);
+
+}
+
+static ssize_t buffer_input_store(struct device *device,
+				  struct device_attribute *attr,
+				  const char *buf,
+				  size_t size)
+{
+	struct hid_device *hdev;
+	struct ite8291_driver_data_t *driver_data;
+	hdev = container_of(device, struct hid_device, dev);
+	driver_data = hid_get_drvdata(hdev);
+
+	if (kstrtobool(buf, &driver_data->device_buffer_input) < 0)
+		return -EINVAL;
+
+	if (!driver_data->device_buffer_input)
+		driver_data->device_write_state(hdev);
+
+	return size;
+}
+
+DEVICE_ATTR_RW(buffer_input);
+
+static struct attribute *control_group_attrs[] = {
+	&dev_attr_buffer_input.attr,
+	NULL
+};
+
+static struct attribute_group control_group = {
+	.name = "controls",
+	.attrs = control_group_attrs
+};
+
+static int driver_probe_callb(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int result;
+	struct ite8291_driver_data_t *ite8291_driver_data;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	// Unused device on Stellaris Intel Gen5 (membrane), avoid binding to it
+	if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05") && hdev->product == 0x5000)
+		return -ENODEV;
+#endif
+
+	result = hid_parse(hdev);
+	if (result) {
+		pr_err("hid_parse failed\n");
+		stop_hw(hdev);
+		return result;
+	}
+
+	result = start_hw(hdev);
+	if (result != 0)
+		return result;
+
+	ite8291_driver_data = devm_kzalloc(&hdev->dev, sizeof(*ite8291_driver_data), GFP_KERNEL);
+	if (!ite8291_driver_data)
+		return -ENOMEM;
+
+	hid_set_drvdata(hdev, ite8291_driver_data);
+
+	result = ite8291_driver_data_setup(hdev);
+	if (result != 0)
+		return result;
+
+	result = ite8291_driver_data->device_add(hdev);
+	if (result != 0)
+		return result;
+
+	ite8291_driver_data->device_write_on(hdev);
+	ite8291_driver_data->device_write_state(hdev);
+
+	if (ite8291_driver_data->device_has_buffer_input_control) {
+		result = sysfs_create_group(&hdev->dev.kobj, &control_group);
+		if (result != 0) {
+			stop_hw(hdev);
+			return result;
+		}
+	}
+
+	return 0;
+}
+
+static void driver_remove_callb(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+	pr_debug("driver remove\n");
+	driver_data = hid_get_drvdata(hdev);
+	driver_data->device_write_off(hdev);
+	driver_data->device_remove(hdev);
+	if (driver_data->device_has_buffer_input_control)
+		sysfs_remove_group(&hdev->dev.kobj, &control_group);
+
+	stop_hw(hdev);
+}
+
+#ifdef CONFIG_PM
+static int driver_suspend_callb(struct hid_device *hdev, pm_message_t message)
+{
+	struct ite8291_driver_data_t *driver_data;
+	pr_debug("driver suspend\n");
+	driver_data = hid_get_drvdata(hdev);
+	driver_data->device_write_off(hdev);
+	return 0;
+}
+
+static int driver_resume_callb(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+	pr_debug("driver resume\n");
+	driver_data = hid_get_drvdata(hdev);
+	driver_data->device_write_on(hdev);
+	return driver_data->device_write_state(hdev);
+}
+
+static int driver_reset_resume_callb(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data;
+	pr_debug("driver reset resume\n");
+	driver_data = hid_get_drvdata(hdev);
+	driver_data->device_write_on(hdev);
+	return driver_data->device_write_state(hdev);
+}
+#endif
+
+static const struct hid_device_id ite8291_device_table[] = {
+	{ HID_USB_DEVICE(0x048d, 0xce00) },
+	{ HID_USB_DEVICE(0x048d, 0x6004) },
+	{ HID_USB_DEVICE(0x048d, 0x600a) },
+	{ HID_USB_DEVICE(0x048d, 0x600b) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, ite8291_device_table);
+
+static struct hid_driver ite8291_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = driver_probe_callb,
+	.remove = driver_remove_callb,
+	.id_table = ite8291_device_table,
+#ifdef CONFIG_PM
+	.suspend = driver_suspend_callb,
+	.resume = driver_resume_callb,
+	.reset_resume = driver_reset_resume_callb
+#endif
+};
+module_hid_driver(ite8291_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for ITE Device(8291) RGB LED keyboard backlight.");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += ite_8291.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291_lb/ite_8291_lb.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291_lb/ite_8291_lb.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291_lb/ite_8291_lb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291_lb/ite_8291_lb.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,639 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/dmi.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+
+// USB HID control data write size
+#define HID_DATA_SIZE 8
+
+#define LIGHTBAR_MAX_BRIGHTNESS		0x64
+#define LIGHTBAR_DEFAULT_BRIGHTNESS	0x00
+#define LIGHTBAR_DEFAULT_COLOR_RED	0xff
+#define LIGHTBAR_DEFAULT_COLOR_GREEN	0xff
+#define LIGHTBAR_DEFAULT_COLOR_BLUE	0xff
+
+struct color_u8 {
+	u8 red;
+	u8 green;
+	u8 blue;
+};
+
+struct ite8291_driver_data_t {
+	struct hid_device *hid_dev;
+	struct led_classdev_mc mcled_cdev_lightbar;
+	struct mc_subled mcled_cdev_subleds_lightbar[3];
+	struct color_u8 *color_list;
+	int color_list_length;
+};
+
+/**
+ * strstr version of dmi_match
+ */
+static bool __attribute__ ((unused)) dmi_string_in(enum dmi_field f, const char *str)
+{
+	const char *info = dmi_get_system_info(f);
+
+	if (info == NULL || str == NULL)
+		return info == str;
+
+	return strstr(info, str) != NULL;
+}
+
+static void stop_hw(struct hid_device *hdev)
+{
+	hid_hw_power(hdev, PM_HINT_NORMAL);
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+}
+
+static int start_hw(struct hid_device *hdev)
+{
+	int result;
+	result = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (result) {
+		pr_err("hid_hw_start failed\n");
+		goto err_stop_hw;
+	}
+
+	hid_hw_power(hdev, PM_HINT_FULLON);
+
+	result = hid_hw_open(hdev);
+	if (result) {
+		pr_err("hid_hw_open failed\n");
+		goto err_stop_hw;
+	}
+
+	return 0;
+
+err_stop_hw:
+	stop_hw(hdev);
+	return result;
+}
+
+/**
+ * Color scaling quirk list
+ */
+static void color_scaling(struct hid_device *hdev, u8 *red, u8 *green, u8 *blue)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	if (dmi_match(DMI_PRODUCT_SKU, "STEPOL1XA04") && hdev->product == 0x6010) {
+		*green = (100 * *green) / 255;
+		*blue = (100 * *blue) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05") && hdev->product == 0x6010) {
+		*green = (100 * *green) / 255;
+		*blue = (100 * *blue) / 255;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS17I06") && hdev->product == 0x6010) {
+		*green = (100 * *green) / 255;
+		*blue = (100 * *blue) / 255;
+	}
+#endif
+}
+
+static int ite8291_set_color_list_entry(struct hid_device *hdev, int index, u8 red, u8 green, u8 blue)
+{
+	struct ite8291_driver_data_t *driver_data = hid_get_drvdata(hdev);
+
+	if (index >= driver_data->color_list_length)
+		return -EINVAL;
+
+	driver_data->color_list[index].red = red;
+	driver_data->color_list[index].green = green;
+	driver_data->color_list[index].blue = blue;
+
+	return 0;
+}
+
+/**
+ * Write control data
+ */
+static int ite8291_write_control(struct hid_device *hdev, u8 *ctrl_data)
+{
+	int result = 0;
+	u8 *buf;
+	if (hdev == NULL)
+		return -ENODEV;
+
+	buf = kzalloc(HID_DATA_SIZE, GFP_KERNEL);
+
+	memcpy(buf, ctrl_data, (size_t) HID_DATA_SIZE);
+
+	result = hid_hw_raw_request(hdev, buf[0], buf, HID_DATA_SIZE,
+				    HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+	kfree(buf);
+
+	return result;
+}
+
+static int ite8291_write_color_list(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *driver_data = hid_get_drvdata(hdev);
+	int i;
+
+	u8 color_ctrl[] = { 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+
+	switch (hdev->product) {
+	case 0x6010:
+		break;
+
+	case 0x7000:
+		color_ctrl[1] = 0x01;
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	for (i = 0; i < driver_data->color_list_length; ++i) {
+		color_ctrl[2] = (u8)i + 1;
+		color_ctrl[3] = driver_data->color_list[i].red;
+		color_ctrl[4] = driver_data->color_list[i].green;
+		color_ctrl[5] = driver_data->color_list[i].blue;
+		color_scaling(hdev, &color_ctrl[3], &color_ctrl[4], &color_ctrl[5]);
+		ite8291_write_control(hdev, color_ctrl);
+	}
+
+	return 0;
+}
+
+/**
+ * Set mono color
+ * 
+ * Note: For now not using color list
+ * 
+ * @param red Range 0x00 - 0xff
+ * @param green Range 0x00 - 0xff
+ * @param blue Range 0x00 - 0xff
+ * @param brightness Range 0x00 - 0x64
+ */
+static int ite8291_write_lightbar_mono(struct hid_device *hdev, u8 red, u8 green, u8 blue, u8 brightness)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	color_scaling(hdev, &red, &green, &blue);
+
+	switch (hdev->product) {
+	case 0x6010:
+		ite8291_write_control(hdev, (u8[]){ 0x14, 0x00, 0x01, red, green, blue, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x02, 0x01, 0x01, brightness, 0x08, 0x00, 0x00 });
+		break;
+
+	case 0x7000:
+		ite8291_write_control(hdev, (u8[]){ 0x14, 0x01, 0x01, red, green, blue, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x21, 0x01, 0x01, brightness, 0x01, 0x00, 0x00 });
+		break;
+
+	case 0x7001:
+		ite8291_write_control(hdev, (u8[]){ 0x14, 0x00, 0x01, red, green, blue, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x22, 0x01, 0x01, brightness, 0x01, 0x00, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/**
+ * Write breathe mode
+ * 
+ * @param brightness Range 0x00 - 0x64
+ * @param speed Range slowest 0x0a to fastest 0x01
+ */
+static int __attribute__ ((unused)) ite8291_write_lightbar_breathe(struct hid_device *hdev, u8 brightness, u8 speed)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+	
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	if (speed < 0x01 || speed > 0x0a)
+		return -EINVAL;
+
+	switch (hdev->product) {
+	case 0x6010:
+		ite8291_write_color_list(hdev);
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x02, 0x02, speed, brightness, 0x08, 0x00, 0x00 });
+		break;
+
+	case 0x7000:
+		ite8291_write_color_list(hdev);
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x21, 0x02, speed, brightness, 0x08, 0x00, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/**
+ * Write wave mode
+ * 
+ * @param brightness Range 0x00 - 0x64
+ * @param speed Range slowest 0x0a to fastest 0x01
+ */
+static int __attribute__ ((unused)) ite8291_write_lightbar_wave(struct hid_device *hdev, u8 brightness, u8 speed)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	if (speed < 0x01 || speed > 0x0a)
+		return -EINVAL;
+
+	switch (hdev->product) {
+
+	case 0x7000:
+		// Reference usage writes previous color but no color is available for mode => skipping
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x21, 0x03, speed, brightness, 0x01, 0x00, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/**
+ * Write clash mode
+ * 
+ * @param brightness Range 0x00 - 0x64
+ * @param speed Range slowest 0x0a to fastest 0x01
+ */
+static int __attribute__ ((unused)) ite8291_write_lightbar_clash(struct hid_device *hdev, u8 brightness, u8 speed)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	if (speed < 0x01 || speed > 0x0a)
+		return -EINVAL;
+
+	switch (hdev->product) {
+
+	case 0x7000:
+		ite8291_write_color_list(hdev);
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x21, 0x04, speed, brightness, 0x08, 0x00, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/**
+ * Write "catch up" mode
+ * 
+ * @param brightness Range 0x00 - 0x64
+ * @param speed Range slowest 0x0a to fastest 0x01
+ */
+static int __attribute__ ((unused)) ite8291_write_lightbar_catchup(struct hid_device *hdev, u8 brightness, u8 speed)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	if (speed < 0x01 || speed > 0x0a)
+		return -EINVAL;
+
+	switch (hdev->product) {
+
+	case 0x7000:
+		// Reference usage writes previous color but no color is available for mode => skipping
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x21, 0x05, speed, brightness, 0x01, 0x00, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+/**
+ * Write flash mode
+ * 
+ * @param brightness Range 0x00 - 0x64
+ * @param speed Range slowest 0x0a to fastest 0x01
+ * @param direction 0x00: no, 0x01: right, 0x02 left
+ */
+static int __attribute__ ((unused)) ite8291_write_lightbar_flash(struct hid_device *hdev, u8 brightness, u8 speed, u8 direction)
+{
+	if (hdev == NULL)
+		return -ENODEV;
+
+	if (brightness > 0x64)
+		return -EINVAL;
+
+	if (speed < 0x01 || speed > 0x0a)
+		return -EINVAL;
+
+	if (direction > 0x02)
+		return -EINVAL;
+
+	switch (hdev->product) {
+	case 0x6010:
+		ite8291_write_color_list(hdev);
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x02, 0x11, speed, brightness, 0x08, direction, 0x00 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+static int ite8291_write_on(struct hid_device *hdev)
+{
+	switch (hdev->product) {
+	case 0x6010:
+		ite8291_write_control(hdev, (u8[]){ 0x1a, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01 });
+		break;
+
+	case 0x7000:
+		ite8291_write_control(hdev, (u8[]){ 0x1a, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x01 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+static int ite8291_write_off(struct hid_device *hdev)
+{
+	switch (hdev->product) {
+	case 0x6010:
+		// Explicitly write mono color "off" due to issue with turning off reliably (especially for sleep)
+		ite8291_write_lightbar_mono(hdev, 0, 0, 0, 0);
+		msleep(50);
+
+		ite8291_write_control(hdev, (u8[]){ 0x12, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 });
+		break;
+
+	case 0x7000:
+		ite8291_write_control(hdev, (u8[]){ 0x12, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 });
+		ite8291_write_control(hdev, (u8[]){ 0x1a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 });
+		break;
+
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+
+static void __attribute__ ((unused)) ite8291_set_testcolors(struct hid_device *hdev)
+{
+	ite8291_set_color_list_entry(hdev, 0, 0xff, 0x00, 0x00);
+	ite8291_set_color_list_entry(hdev, 1, 0xff, 0xff, 0x00);
+	ite8291_set_color_list_entry(hdev, 2, 0x00, 0xff, 0x00);
+	ite8291_set_color_list_entry(hdev, 3, 0xff, 0x00, 0xff);
+	ite8291_set_color_list_entry(hdev, 4, 0xff, 0xff, 0x00);
+	ite8291_set_color_list_entry(hdev, 5, 0x00, 0xff, 0x00);
+	ite8291_set_color_list_entry(hdev, 6, 0x00, 0x00, 0xff);
+}
+
+static int ite8291_write_state(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	struct led_classdev_mc *mcled_cdev = &ite8291_driver_data->mcled_cdev_lightbar;
+
+	// For now only supports mono color state saved in sysfs structure
+	return ite8291_write_lightbar_mono(hdev,
+					   mcled_cdev->subled_info[0].intensity,
+					   mcled_cdev->subled_info[1].intensity,
+					   mcled_cdev->subled_info[2].intensity,
+					   ite8291_driver_data->mcled_cdev_lightbar.led_cdev.brightness);
+}
+
+static void leds_set_brightness_mc_lightbar(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hdev = to_hid_device(dev);
+
+	ite8291_write_state(hdev);
+}
+
+static int ite8291_init_leds(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+	int retval;
+
+	ite8291_driver_data->mcled_cdev_lightbar.led_cdev.name = "rgb:" "lightbar";
+	ite8291_driver_data->mcled_cdev_lightbar.led_cdev.max_brightness = LIGHTBAR_MAX_BRIGHTNESS;
+	ite8291_driver_data->mcled_cdev_lightbar.led_cdev.brightness_set = &leds_set_brightness_mc_lightbar;
+	ite8291_driver_data->mcled_cdev_lightbar.led_cdev.brightness = LIGHTBAR_DEFAULT_BRIGHTNESS;
+	ite8291_driver_data->mcled_cdev_lightbar.num_colors = 3;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info = ite8291_driver_data->mcled_cdev_subleds_lightbar;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[0].color_index = LED_COLOR_ID_RED;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[0].intensity = LIGHTBAR_DEFAULT_COLOR_RED;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[0].channel = 0;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[1].color_index = LED_COLOR_ID_GREEN;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[1].intensity = LIGHTBAR_DEFAULT_COLOR_GREEN;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[1].channel = 0;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[2].color_index = LED_COLOR_ID_BLUE;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[2].intensity = LIGHTBAR_DEFAULT_COLOR_BLUE;
+	ite8291_driver_data->mcled_cdev_lightbar.subled_info[2].channel = 0;
+
+	retval = devm_led_classdev_multicolor_register(&hdev->dev, &ite8291_driver_data->mcled_cdev_lightbar);
+	if (retval != 0)
+		return retval;
+
+	return 0;
+}
+
+static int ite8291_driver_data_setup(struct hid_device *hdev, struct ite8291_driver_data_t *driver_data)
+{
+	int i;
+
+	driver_data->hid_dev = hdev;
+
+	switch (hdev->product) {
+	case 0x6010:
+		// Reference usage writes 9 entries but only 7 seem to be in
+		// effect. Therefore defining 7.
+	case 0x7000:
+		driver_data->color_list_length = 7;
+		break;
+
+	default:
+		driver_data->color_list_length = 0;
+	}
+
+	if (driver_data->color_list_length != 0) {
+		driver_data->color_list = devm_kzalloc(&hdev->dev,
+						       sizeof(struct color_u8) * driver_data->color_list_length,
+						       GFP_KERNEL);
+		if (!driver_data->color_list)
+			return -ENOMEM;
+
+		// Initialize color list
+		for (i = 0; i < driver_data->color_list_length; ++i) {
+			driver_data->color_list[i].red = 0;
+			driver_data->color_list[i].green = 0;
+			driver_data->color_list[i].blue = 0;
+		}
+	}
+
+	return 0;
+}
+
+static int driver_probe_callb(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int result;
+	struct ite8291_driver_data_t *ite8291_driver_data;
+	bool exclude_device = false;
+
+	// Unused devices in Stellaris Gen5 models
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05") &&
+	    !dmi_match(DMI_PRODUCT_FAMILY, "STELLARIS17I05") &&
+	    hdev->product == 0x6010)
+		exclude_device = true;
+#endif
+
+	if (exclude_device) {
+		pr_info("Note: device excluded, not binding to device %0#6x\n", hdev->product);
+		return -ENODEV;
+	}
+
+	result = hid_parse(hdev);
+	if (result) {
+		pr_err("hid_parse failed\n");
+		stop_hw(hdev);
+		return result;
+	}
+
+	result = start_hw(hdev);
+	if (result != 0)
+		return result;
+
+	ite8291_driver_data = devm_kzalloc(&hdev->dev, sizeof(*ite8291_driver_data), GFP_KERNEL);
+	if (!ite8291_driver_data)
+		return -ENOMEM;
+
+	result = ite8291_driver_data_setup(hdev, ite8291_driver_data);
+	if (result != 0)
+		return result;
+
+	hid_set_drvdata(hdev, ite8291_driver_data);
+
+	result = ite8291_init_leds(hdev);
+	if (result != 0)
+		return result;
+
+	ite8291_write_on(hdev);
+	ite8291_write_state(hdev);
+
+	return result;
+}
+
+static void driver_remove_callb(struct hid_device *hdev)
+{
+	struct ite8291_driver_data_t *ite8291_driver_data = hid_get_drvdata(hdev);
+
+	devm_led_classdev_multicolor_unregister(&hdev->dev, &ite8291_driver_data->mcled_cdev_lightbar);
+
+	ite8291_write_off(hdev);
+
+	stop_hw(hdev);
+	pr_debug("driver remove\n");
+}
+
+#ifdef CONFIG_PM
+static int driver_suspend_callb(struct hid_device *hdev, pm_message_t message)
+{
+	ite8291_write_off(hdev);
+	pr_debug("driver suspend\n");
+	return 0;
+}
+
+static int driver_resume_callb(struct hid_device *hdev)
+{
+	pr_debug("driver resume\n");
+	ite8291_write_on(hdev);
+	return ite8291_write_state(hdev);
+}
+
+static int driver_reset_resume_callb(struct hid_device *hdev)
+{
+	pr_debug("driver reset resume\n");
+	ite8291_write_on(hdev);
+	return ite8291_write_state(hdev);
+}
+#endif
+
+static const struct hid_device_id ite8291_device_table[] = {
+	{ HID_USB_DEVICE(0x048d, 0x6010) },
+	{ HID_USB_DEVICE(0x048d, 0x7000) },
+	{ HID_USB_DEVICE(0x048d, 0x7001) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, ite8291_device_table);
+
+static struct hid_driver ite8291_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = driver_probe_callb,
+	.remove = driver_remove_callb,
+	.id_table = ite8291_device_table,
+#ifdef CONFIG_PM
+	.suspend = driver_suspend_callb,
+	.resume = driver_resume_callb,
+	.reset_resume = driver_reset_resume_callb
+#endif
+};
+module_hid_driver(ite8291_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for ITE RGB lightbars");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291_lb/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291_lb/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8291_lb/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8291_lb/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += ite_8291_lb.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8297/ite_8297.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8297/ite_8297.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8297/ite_8297.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8297/ite_8297.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+
+// USB HID feature data write size
+#define HID_DATA_SIZE 64
+
+// led_classdev names, default and max brightness
+#define LED_MAX_BRIGHTNESS		0xff
+#define ITE_8297_DEFAULT_BRIGHTNESS	0x00
+#define LED_NAME_RGB_RED		KBUILD_MODNAME ":1"
+#define LED_NAME_RGB_GREEN		KBUILD_MODNAME ":2"
+#define LED_NAME_RGB_BLUE		KBUILD_MODNAME ":3"
+
+struct color_t {
+	u8 red;
+	u8 green;
+	u8 blue;
+};
+
+struct ite8297_driver_data_t {
+	struct led_classdev cdev_red;
+	struct led_classdev cdev_green;
+	struct led_classdev cdev_blue;
+	struct hid_device *hid_dev;
+	struct color_t current_color;
+};
+
+static int ite8297_write_color(struct hid_device *hdev, u8 red, u8 green, u8 blue)
+{
+	int result = 0;
+	u8 *buf;
+	if (hdev == NULL)
+		return -ENODEV;
+
+	buf = kzalloc(HID_DATA_SIZE, GFP_KERNEL);
+	buf[0] = 0xcc;
+	buf[1] = 0xb0;
+	buf[2] = 0x01;
+	buf[3] = 0x01;
+	buf[4] = red;
+	buf[5] = green;
+	buf[6] = blue;
+
+	result = hid_hw_raw_request(hdev, buf[0], buf, HID_DATA_SIZE,
+				    HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+	kfree(buf);
+
+	return result;
+}
+
+static int ite8297_write_state(struct ite8297_driver_data_t *ite8297_driver_data)
+{
+	return ite8297_write_color(ite8297_driver_data->hid_dev,
+				   ite8297_driver_data->current_color.red,
+				   ite8297_driver_data->current_color.green,
+				   ite8297_driver_data->current_color.blue);
+}
+
+static int lightbar_set_blocking(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	bool led_red = strstr(led_cdev->name, LED_NAME_RGB_RED) != NULL;
+	bool led_green = strstr(led_cdev->name, LED_NAME_RGB_GREEN) != NULL;
+	bool led_blue = strstr(led_cdev->name, LED_NAME_RGB_BLUE) != NULL;
+	struct ite8297_driver_data_t *ite8297_driver_data;
+
+	if (led_red) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_red);
+		ite8297_driver_data->current_color.red = brightness;
+	} else if (led_green) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_green);
+		ite8297_driver_data->current_color.green = brightness;
+	} else if (led_blue) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_blue);
+		ite8297_driver_data->current_color.blue = brightness;
+	}
+	ite8297_write_state(ite8297_driver_data);
+
+	return 0;
+}
+
+static enum led_brightness lightbar_get(struct led_classdev *led_cdev)
+{
+	bool led_red = strstr(led_cdev->name, LED_NAME_RGB_RED) != NULL;
+	bool led_green = strstr(led_cdev->name, LED_NAME_RGB_GREEN) != NULL;
+	bool led_blue = strstr(led_cdev->name, LED_NAME_RGB_BLUE) != NULL;
+	struct ite8297_driver_data_t *ite8297_driver_data;
+
+	if (led_red) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_red);
+		return ite8297_driver_data->current_color.red;
+	} else if (led_green) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_green);
+		return ite8297_driver_data->current_color.green;
+	} else if (led_blue) {
+		ite8297_driver_data = container_of(led_cdev, struct ite8297_driver_data_t, cdev_blue);
+		return ite8297_driver_data->current_color.blue;
+	}
+
+	return 0;
+}
+
+static void stop_hw(struct hid_device *hdev)
+{
+	hid_hw_power(hdev, PM_HINT_NORMAL);
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+}
+
+static int start_hw(struct hid_device *hdev)
+{
+	int result;
+	result = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (result) {
+		pr_err("hid_hw_start failed\n");
+		goto err_stop_hw;
+	}
+
+	hid_hw_power(hdev, PM_HINT_FULLON);
+
+	result = hid_hw_open(hdev);
+	if (result) {
+		pr_err("hid_hw_open failed\n");
+		goto err_stop_hw;
+	}
+
+	return 0;
+
+err_stop_hw:
+	stop_hw(hdev);
+	return result;
+}
+
+static int driver_probe_callb(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int result;
+	struct ite8297_driver_data_t *ite8297_driver_data;
+
+	result = hid_parse(hdev);
+	if (result) {
+		pr_err("hid_parse failed\n");
+		stop_hw(hdev);
+		return result;
+	}
+
+	result = start_hw(hdev);
+	if (result != 0)
+		return result;
+
+	ite8297_driver_data = devm_kzalloc(&hdev->dev, sizeof(*ite8297_driver_data), GFP_KERNEL);
+	if (!ite8297_driver_data)
+		return -ENOMEM;
+
+	ite8297_driver_data->cdev_red.name = LED_NAME_RGB_RED;
+	ite8297_driver_data->cdev_red.max_brightness = LED_MAX_BRIGHTNESS;
+	ite8297_driver_data->cdev_red.brightness_set_blocking = &lightbar_set_blocking;
+	ite8297_driver_data->cdev_red.brightness_get = &lightbar_get;
+
+	ite8297_driver_data->cdev_green.name = LED_NAME_RGB_GREEN;
+	ite8297_driver_data->cdev_green.max_brightness = LED_MAX_BRIGHTNESS;
+	ite8297_driver_data->cdev_green.brightness_set_blocking = &lightbar_set_blocking;
+	ite8297_driver_data->cdev_green.brightness_get = &lightbar_get;
+
+	ite8297_driver_data->cdev_blue.name = LED_NAME_RGB_BLUE;
+	ite8297_driver_data->cdev_blue.max_brightness = LED_MAX_BRIGHTNESS;
+	ite8297_driver_data->cdev_blue.brightness_set_blocking = &lightbar_set_blocking;
+	ite8297_driver_data->cdev_blue.brightness_get = &lightbar_get;
+
+	ite8297_driver_data->hid_dev = hdev;
+	ite8297_driver_data->current_color.red = ITE_8297_DEFAULT_BRIGHTNESS;
+	ite8297_driver_data->current_color.green = ITE_8297_DEFAULT_BRIGHTNESS;
+	ite8297_driver_data->current_color.blue = ITE_8297_DEFAULT_BRIGHTNESS;
+
+	led_classdev_register(&hdev->dev, &ite8297_driver_data->cdev_red);
+	led_classdev_register(&hdev->dev, &ite8297_driver_data->cdev_green);
+	led_classdev_register(&hdev->dev, &ite8297_driver_data->cdev_blue);
+
+	hid_set_drvdata(hdev, ite8297_driver_data);
+
+	result = ite8297_write_state(ite8297_driver_data);
+	if (result < 0)
+		return result;
+
+	return 0;
+}
+
+static void driver_remove_callb(struct hid_device *hdev)
+{
+	struct ite8297_driver_data_t *ite8297_driver_data = hid_get_drvdata(hdev);
+	if (!IS_ERR_OR_NULL(ite8297_driver_data)) {
+		led_classdev_unregister(&ite8297_driver_data->cdev_red);
+		led_classdev_unregister(&ite8297_driver_data->cdev_green);
+		led_classdev_unregister(&ite8297_driver_data->cdev_blue);
+	} else {
+		pr_debug("driver data not found\n");
+	}
+	stop_hw(hdev);
+	pr_debug("driver remove\n");
+}
+
+#ifdef CONFIG_PM
+static int driver_suspend_callb(struct hid_device *hdev, pm_message_t message)
+{
+	pr_debug("driver suspend\n");
+	return 0;
+}
+
+static int driver_resume_callb(struct hid_device *hdev)
+{
+	struct ite8297_driver_data_t *ite8297_driver_data = hid_get_drvdata(hdev);
+	pr_debug("driver resume\n");
+	return ite8297_write_state(ite8297_driver_data);
+}
+
+static int driver_reset_resume_callb(struct hid_device *hdev)
+{
+	struct ite8297_driver_data_t *ite8297_driver_data = hid_get_drvdata(hdev);
+	pr_debug("driver reset resume\n");
+	return ite8297_write_state(ite8297_driver_data);
+}
+#endif
+
+static const struct hid_device_id ite8297_device_table[] = {
+	{ HID_USB_DEVICE(0x048d, 0x8297) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, ite8297_device_table);
+
+static struct hid_driver ite8297_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = driver_probe_callb,
+	.remove = driver_remove_callb,
+	.id_table = ite8297_device_table,
+#ifdef CONFIG_PM
+	.suspend = driver_suspend_callb,
+	.resume = driver_resume_callb,
+	.reset_resume = driver_reset_resume_callb
+#endif
+};
+module_hid_driver(ite8297_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for IT8297 RGB LED Controller");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_8297/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8297/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_8297/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_8297/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += ite_8297.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_829x/ite_829x.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_829x/ite_829x.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_829x/ite_829x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_829x/ite_829x.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,410 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2019-2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/hid.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/keyboard.h>
+#include <linux/dmi.h>
+#include <linux/led-class-multicolor.h>
+
+MODULE_DESCRIPTION("TUXEDO Computers, ITE backlight driver");
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_LICENSE("GPL");
+
+#define KEYBOARD_ROWS       6
+#define KEYBOARD_COLUMNS    20
+
+#define get_led_id(row, col)    (u8)( ((row & 0x07) << 5) | (col & 0x1f) )
+
+#define HID_DATA_SIZE 6
+
+// Keyboard events
+#define INT_KEY_B_NEXT		KEY_LIGHTS_TOGGLE
+
+static struct hid_device *kbdev = NULL;
+static struct mutex dev_lock;
+static struct mutex input_lock;
+
+// Brightness (0-10)
+#define ITE829X_KBD_BRIGHTNESS_MAX	0x0a
+#define ITE829X_KBD_BRIGHTNESS_DEFAULT	0x00
+// Default mode (index to mode_to_color array) or extra modes
+#define DEFAULT_MODE        6
+
+static struct ite8291_data {
+	int brightness;
+	int mode;
+} ti_data = {
+	.brightness = ITE829X_KBD_BRIGHTNESS_DEFAULT,
+	.mode = DEFAULT_MODE
+};
+
+static struct led_classdev_mc clevo_mcled_cdevs[KEYBOARD_ROWS][KEYBOARD_COLUMNS];
+static struct mc_subled clevo_mcled_cdevs_subleds[KEYBOARD_ROWS][KEYBOARD_COLUMNS][3];
+
+// Color mode definition
+static int mode_to_color[] = { 0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff };
+// Length of color mode array
+static const int MODE_MAP_LENGTH = sizeof(mode_to_color)/sizeof(mode_to_color[0]);
+// Amount of extra modes in addition to the color ones
+static const int MODE_EXTRAS_LENGTH = 2;
+
+static int keyb_send_data(struct hid_device *dev, u8 cmd, u8 d0, u8 d1, u8 d2, u8 d3)
+{
+	int result = 0;
+	u8 *buf;
+
+	pr_debug("keyb_send_data: cmd: %hhu, d0: %hhu, d1: %hhu, d2: %hhu, d3: %hhu\n", cmd, d0, d1, d2, d3);
+
+	if (dev == NULL) {
+		return -ENODEV;
+	}
+
+	mutex_lock(&dev_lock);
+
+	buf = kzalloc(HID_DATA_SIZE, GFP_KERNEL);
+	buf[0] = 0xcc;
+	buf[1] = cmd;
+	buf[2] = d0;
+	buf[3] = d1;
+	buf[4] = d2;
+	buf[5] = d3;
+
+	result = hid_hw_raw_request(dev, buf[0], buf, HID_DATA_SIZE, HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+	kfree(buf);
+
+	mutex_unlock(&dev_lock);
+
+	return result;
+}
+
+static void keyb_set_all(struct hid_device *dev, u8 color_red, u8 color_green, u8 color_blue)
+{
+	int row, col;
+	for (row = 0; row < KEYBOARD_ROWS; ++row) {
+		for (col = 0; col < KEYBOARD_COLUMNS; ++col) {
+			clevo_mcled_cdevs[row][col].subled_info[0].intensity = color_red;
+			clevo_mcled_cdevs[row][col].subled_info[1].intensity = color_green;
+			clevo_mcled_cdevs[row][col].subled_info[2].intensity = color_blue;
+			keyb_send_data(dev, 0x01, get_led_id(row, col), color_red, color_green, color_blue);
+		}
+	}
+}
+
+static void send_mode(struct hid_device *dev, int mode)
+{
+	int row, col;
+	u8 color_red, color_green, color_blue;
+	
+	if (dev == NULL) {
+		return;
+	}
+
+	if (mode < MODE_MAP_LENGTH) {
+		// Color modes, mode is index to mode_to_color array map
+		color_red = (mode_to_color[mode] >> 0x10) & 0xff;
+		color_green = (mode_to_color[mode] >> 0x08) & 0xff;
+		color_blue = (mode_to_color[mode] >> 0x00) & 0xff;
+		keyb_set_all(dev, color_red, color_green, color_blue);
+	} else if (mode == MODE_MAP_LENGTH) {
+		// White background, TUXEDO letters in red
+		for (row = 0; row < KEYBOARD_ROWS; ++row) {
+			for (col = 0; col < KEYBOARD_COLUMNS; ++col) {
+				if (
+					(row == 2 && col == 6) ||   // T
+					(row == 2 && col == 8) ||   // U
+					(row == 4 && col == 4) ||   // X
+					(row == 2 && col == 4) ||   // E
+					(row == 3 && col == 4) ||   // D
+					(row == 2 && col == 10)     // O
+				) {
+					clevo_mcled_cdevs[row][col].subled_info[0].intensity = 0xff;
+					clevo_mcled_cdevs[row][col].subled_info[1].intensity = 0x00;
+					clevo_mcled_cdevs[row][col].subled_info[2].intensity = 0x00;
+					keyb_send_data(dev, 0x01, get_led_id(row, col), 0xff, 0x00, 0x00);
+				} else {
+					clevo_mcled_cdevs[row][col].subled_info[0].intensity = 0xff;
+					clevo_mcled_cdevs[row][col].subled_info[1].intensity = 0xff;
+					clevo_mcled_cdevs[row][col].subled_info[2].intensity = 0xff;
+					keyb_send_data(dev, 0x01, get_led_id(row, col), 0xff, 0xff, 0xff);
+				}
+			}
+		}
+	} else if (mode == MODE_MAP_LENGTH + 1) {
+		// Random color animating effect, special mode
+		keyb_send_data(dev, 0x00, 0x09, 0x00, 0x00, 0x00);
+	}
+}
+
+static void stop_hw(struct hid_device *dev)
+{
+	hid_hw_power(dev, PM_HINT_NORMAL);
+	kbdev = NULL;
+	hid_hw_close(dev);
+	hid_hw_stop(dev);
+}
+
+static int start_hw(struct hid_device *dev)
+{
+	int result;
+	result = hid_hw_start(dev, HID_CONNECT_DEFAULT);
+	if (result) {
+		pr_err("hid_hw_start failed\n");
+		goto err_stop_hw;
+	}
+
+	hid_hw_power(dev, PM_HINT_FULLON);
+
+	result = hid_hw_open(dev);
+	if (result) {
+		pr_err("hid_hw_open failed\n");
+		goto err_stop_hw;
+	}
+
+	kbdev = dev;
+	return 0;
+
+err_stop_hw:
+	stop_hw(dev);
+	return result;
+}
+
+static void leds_set_brightness_mc(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int i, j;
+	struct led_classdev_mc *led_cdev_mc = lcdev_to_mccdev(led_cdev);
+
+	pr_debug("leds_set_brightness_mc: channel: %d, brightness: %d, saved brightness: %d, red: %d, green: %d, blue: %d\n",
+		 led_cdev_mc->subled_info[0].channel, brightness, ti_data.brightness, led_cdev_mc->subled_info[0].intensity,
+		 led_cdev_mc->subled_info[1].intensity, led_cdev_mc->subled_info[2].intensity);
+
+	ti_data.brightness = brightness;
+
+	for (i = 0; i < KEYBOARD_ROWS; ++i) {
+		for (j = 0; j < KEYBOARD_COLUMNS; ++j) {
+			clevo_mcled_cdevs[i][j].led_cdev.brightness = brightness;
+		}
+	}
+
+	keyb_send_data(kbdev, 0x09, brightness, 0x02, 0x00, 0x00);
+
+	keyb_send_data(kbdev, 0x01, led_cdev_mc->subled_info[0].channel,
+		       led_cdev_mc->subled_info[0].intensity,
+		       led_cdev_mc->subled_info[1].intensity,
+		       led_cdev_mc->subled_info[2].intensity);
+}
+
+static void key_actions(unsigned long key_code)
+{
+	mutex_lock(&input_lock);
+
+	switch (key_code) {
+	case INT_KEY_B_NEXT:
+		// Next mode
+		ti_data.mode += 1;
+
+		if (ti_data.mode >= MODE_MAP_LENGTH + MODE_EXTRAS_LENGTH) {
+			ti_data.mode = 0;
+		}
+
+		send_mode(kbdev, ti_data.mode);
+		break;
+	}
+
+	mutex_unlock(&input_lock);
+}
+
+static volatile unsigned long last_key = 0;
+
+static void ite_829x_key_work_handler(struct work_struct *work)
+{
+	key_actions(last_key);
+}
+
+static DECLARE_WORK(ite_829x_key_work, ite_829x_key_work_handler);
+
+static int keyboard_notifier_callb(struct notifier_block *nb, unsigned long code, void *_param)
+{
+	struct keyboard_notifier_param *param = _param;
+	int ret = NOTIFY_OK;
+
+	if (!param->down) {
+		return ret;
+	}
+
+	if (mutex_is_locked(&input_lock)) {
+		return ret;
+	}
+
+	if (code == KBD_KEYCODE) {
+		last_key = param->value;
+		schedule_work(&ite_829x_key_work);
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block keyboard_notifier_block = {
+	.notifier_call = keyboard_notifier_callb
+};
+
+static int probe_callb(struct hid_device *dev, const struct hid_device_id *id)
+{
+	int result, i, j;
+
+	result = hid_parse(dev);
+	if (result) {
+		pr_err("hid_parse failed\n");
+		stop_hw(dev);
+		return result;
+	}
+
+	mutex_init(&dev_lock);
+
+	result = start_hw(dev);
+	if (result != 0) {
+		return result;
+	}
+
+	keyb_send_data(kbdev, 0x09, ti_data.brightness, 0x02, 0x00, 0x00);
+	for (i = 0; i < KEYBOARD_ROWS; ++i) {
+		for (j = 0; j < KEYBOARD_COLUMNS; ++j) {
+			pr_debug("Initialize led %d to %d %d %d.\n", get_led_id(i, j), 255, 255, 255);
+
+			keyb_send_data(dev, 0x01, get_led_id(i, j), 255, 255, 255);
+		}
+	}
+
+	for (i = 0; i < KEYBOARD_ROWS; ++i) {
+		for (j = 0; j < KEYBOARD_COLUMNS; ++j) {
+			clevo_mcled_cdevs[i][j].led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT;
+			clevo_mcled_cdevs[i][j].led_cdev.max_brightness = ITE829X_KBD_BRIGHTNESS_MAX;
+			clevo_mcled_cdevs[i][j].led_cdev.brightness_set = &leds_set_brightness_mc;
+			clevo_mcled_cdevs[i][j].led_cdev.brightness = ITE829X_KBD_BRIGHTNESS_DEFAULT;
+			clevo_mcled_cdevs[i][j].num_colors = 3;
+			clevo_mcled_cdevs[i][j].subled_info = clevo_mcled_cdevs_subleds[i][j];
+			clevo_mcled_cdevs[i][j].subled_info[0].color_index = LED_COLOR_ID_RED;
+			clevo_mcled_cdevs[i][j].subled_info[0].intensity = 255;
+			clevo_mcled_cdevs[i][j].subled_info[0].channel = get_led_id(i, j);
+			clevo_mcled_cdevs[i][j].subled_info[1].color_index = LED_COLOR_ID_GREEN;
+			clevo_mcled_cdevs[i][j].subled_info[1].intensity = 255;
+			clevo_mcled_cdevs[i][j].subled_info[1].channel = get_led_id(i, j);
+			clevo_mcled_cdevs[i][j].subled_info[2].color_index = LED_COLOR_ID_BLUE;
+			clevo_mcled_cdevs[i][j].subled_info[2].intensity = 255;
+			clevo_mcled_cdevs[i][j].subled_info[2].channel = get_led_id(i, j);
+
+			devm_led_classdev_multicolor_register(&dev->dev, &clevo_mcled_cdevs[i][j]);
+		}
+	}
+
+	register_keyboard_notifier(&keyboard_notifier_block);
+
+	return 0;
+}
+
+static void remove_callb(struct hid_device *dev)
+{
+	int i, j;
+	unregister_keyboard_notifier(&keyboard_notifier_block);
+	for (i = 0; i < KEYBOARD_ROWS; ++i) {
+		for (j = 0; j < KEYBOARD_COLUMNS; ++j) {
+			devm_led_classdev_multicolor_unregister(&dev->dev, &clevo_mcled_cdevs[i][j]);
+		}
+	}
+	stop_hw(dev);
+	pr_debug("driver remove\n");
+}
+
+static int driver_suspend_callb(struct device *dev)
+{
+	pr_debug("driver suspend\n");
+	return 0;
+}
+
+static int driver_resume_callb(struct device *dev)
+{
+	int i, j;
+	pr_debug("driver resume\n");
+	keyb_send_data(kbdev, 0x09, ti_data.brightness, 0x02, 0x00, 0x00);
+	for (i = 0; i < KEYBOARD_ROWS; ++i) {
+		for (j = 0; j < KEYBOARD_COLUMNS; ++j) {
+			keyb_send_data(kbdev, 0x01, get_led_id(i, j),
+				       clevo_mcled_cdevs[i][j].subled_info[0].intensity,
+				       clevo_mcled_cdevs[i][j].subled_info[1].intensity,
+				       clevo_mcled_cdevs[i][j].subled_info[2].intensity);
+		}
+	}
+	send_mode(kbdev, ti_data.mode);
+	return 0;
+}
+
+static const struct hid_device_id ite829x_device_table[] = {
+	{ HID_USB_DEVICE(0x048d, 0x8910) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, ite829x_device_table);
+
+static struct hid_driver ite829x_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = probe_callb,
+	.remove = remove_callb,
+	.id_table = ite829x_device_table,
+};
+
+static const struct dev_pm_ops ite8291_pm = {
+	SET_SYSTEM_SLEEP_PM_OPS(driver_suspend_callb, driver_resume_callb)
+};
+
+static int __init ite8291_init(void)
+{
+	pr_debug("module init\n");
+
+	// Known not compatible/broken device, do not even load module
+	if (dmi_match(DMI_SYS_VENDOR, "TUXEDO") &&
+	    (dmi_match(DMI_PRODUCT_SKU, "SIRIUS1601") || dmi_match(DMI_PRODUCT_SKU, "SIRIUS1602")))
+		return -ENODEV;
+
+	mutex_init(&input_lock);
+	
+	ite829x_driver.driver.pm = &ite8291_pm;
+
+	return hid_register_driver(&ite829x_driver);
+}
+
+static void __exit ite8291_exit(void)
+{
+	hid_unregister_driver(&ite829x_driver);
+	pr_debug("module exit\n");
+}
+
+// ---
+// Module bootstrap
+// ---
+module_init(ite8291_init);
+module_exit(ite8291_exit);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/ite_829x/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_829x/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/ite_829x/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/ite_829x/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += ite_829x.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,17 @@
+obj-m += clevo_acpi.o
+obj-m += clevo_wmi.o
+obj-m += tuxedo_keyboard.o
+obj-m += uniwill_wmi.o
+
+obj-y += ite_8291/
+obj-y += ite_8291_lb/
+obj-y += ite_8297/
+obj-y += ite_829x/
+obj-y += tuxedo_compatibility_check/
+obj-y += tuxedo_io/
+obj-y += tuxedo_nb02_nvidia_power_ctrl/
+obj-y += tuxedo_nb05/
+obj-y += tuxedo_nb04/
+obj-y += tuxedo_tuxi/
+obj-y += stk8321/
+obj-y += gxtp7380/
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/Kconfig linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Kconfig
--- linux-6.17.13/drivers/platform/x86/tuxedo/Kconfig	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Kconfig	2025-12-19 19:34:10.995596156 +0100
@@ -1,8 +1,8 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# Copyright (C) 2024-2025 Werner Sembach wse@tuxedocomputers.com
-#
-# TUXEDO X86 Platform Specific Drivers
-#
+# Tuxedo platform drivers
+# Built unconditionally via Kbuild
 
-source "drivers/platform/x86/tuxedo/nb04/Kconfig"
+menu "Tuxedo platform support"
+
+comment "Tuxedo drivers are built-in"
+
+endmenu
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/Makefile linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Makefile
--- linux-6.17.13/drivers/platform/x86/tuxedo/Makefile	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# Copyright (C) 2024-2025 Werner Sembach wse@tuxedocomputers.com
-#
-# TUXEDO X86 Platform Specific Drivers
-#
-
-obj-y	+= nb04/
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/nb04/Kconfig linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/Kconfig
--- linux-6.17.13/drivers/platform/x86/tuxedo/nb04/Kconfig	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/Kconfig	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# Copyright (C) 2024-2025 Werner Sembach wse@tuxedocomputers.com
-#
-# TUXEDO X86 Platform Specific Drivers
-#
-
-config TUXEDO_NB04_WMI_AB
-	tristate "TUXEDO NB04 WMI AB Platform Driver"
-	depends on ACPI_WMI
-	depends on HID
-	help
-	  This driver implements the WMI AB device found on TUXEDO notebooks
-	  with board vendor NB04. This enables keyboard backlight control via a
-	  virtual HID LampArray device.
-
-	  When compiled as a module it will be called tuxedo_nb04_wmi_ab.
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/nb04/Makefile linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/Makefile
--- linux-6.17.13/drivers/platform/x86/tuxedo/nb04/Makefile	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-or-later
-#
-# Copyright (C) 2024-2025 Werner Sembach wse@tuxedocomputers.com
-#
-# TUXEDO X86 Platform Specific Drivers
-#
-
-tuxedo_nb04_wmi_ab-y			:= wmi_ab.o
-tuxedo_nb04_wmi_ab-y			+= wmi_util.o
-obj-$(CONFIG_TUXEDO_NB04_WMI_AB)	+= tuxedo_nb04_wmi_ab.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_ab.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_ab.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_ab.c	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_ab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,923 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * This driver implements the WMI AB device found on TUXEDO notebooks with board
- * vendor NB04.
- *
- * Copyright (C) 2024-2025 Werner Sembach <wse@tuxedocomputers.com>
- */
-
-#include <linux/dmi.h>
-#include <linux/hid.h>
-#include <linux/minmax.h>
-#include <linux/module.h>
-#include <linux/wmi.h>
-
-#include "wmi_util.h"
-
-static const struct wmi_device_id tuxedo_nb04_wmi_ab_device_ids[] = {
-	{ .guid_string = "80C9BAA6-AC48-4538-9234-9F81A55E7C85" },
-	{ }
-};
-MODULE_DEVICE_TABLE(wmi, tuxedo_nb04_wmi_ab_device_ids);
-
-enum {
-	LAMP_ARRAY_ATTRIBUTES_REPORT_ID		= 0x01,
-	LAMP_ATTRIBUTES_REQUEST_REPORT_ID	= 0x02,
-	LAMP_ATTRIBUTES_RESPONSE_REPORT_ID	= 0x03,
-	LAMP_MULTI_UPDATE_REPORT_ID		= 0x04,
-	LAMP_RANGE_UPDATE_REPORT_ID		= 0x05,
-	LAMP_ARRAY_CONTROL_REPORT_ID		= 0x06,
-};
-
-static u8 tux_report_descriptor[327] = {
-	0x05, 0x59,			// Usage Page (Lighting and Illumination)
-	0x09, 0x01,			// Usage (Lamp Array)
-	0xa1, 0x01,			// Collection (Application)
-	0x85, LAMP_ARRAY_ATTRIBUTES_REPORT_ID, //  Report ID (1)
-	0x09, 0x02,			//  Usage (Lamp Array Attributes Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x03,			//   Usage (Lamp Count)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0x00, 0x00,	//   Logical Maximum (65535)
-	0x75, 0x10,			//   Report Size (16)
-	0x95, 0x01,			//   Report Count (1)
-	0xb1, 0x03,			//   Feature (Cnst,Var,Abs)
-	0x09, 0x04,			//   Usage (Bounding Box Width In Micrometers)
-	0x09, 0x05,			//   Usage (Bounding Box Height In Micrometers)
-	0x09, 0x06,			//   Usage (Bounding Box Depth In Micrometers)
-	0x09, 0x07,			//   Usage (Lamp Array Kind)
-	0x09, 0x08,			//   Usage (Min Update Interval In Microseconds)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0xff, 0x7f,	//   Logical Maximum (2147483647)
-	0x75, 0x20,			//   Report Size (32)
-	0x95, 0x05,			//   Report Count (5)
-	0xb1, 0x03,			//   Feature (Cnst,Var,Abs)
-	0xc0,				//  End Collection
-	0x85, LAMP_ATTRIBUTES_REQUEST_REPORT_ID, //  Report ID (2)
-	0x09, 0x20,			//  Usage (Lamp Attributes Request Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x21,			//   Usage (Lamp Id)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0x00, 0x00,	//   Logical Maximum (65535)
-	0x75, 0x10,			//   Report Size (16)
-	0x95, 0x01,			//   Report Count (1)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0xc0,				//  End Collection
-	0x85, LAMP_ATTRIBUTES_RESPONSE_REPORT_ID, //  Report ID (3)
-	0x09, 0x22,			//  Usage (Lamp Attributes Response Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x21,			//   Usage (Lamp Id)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0x00, 0x00,	//   Logical Maximum (65535)
-	0x75, 0x10,			//   Report Size (16)
-	0x95, 0x01,			//   Report Count (1)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x23,			//   Usage (Position X In Micrometers)
-	0x09, 0x24,			//   Usage (Position Y In Micrometers)
-	0x09, 0x25,			//   Usage (Position Z In Micrometers)
-	0x09, 0x27,			//   Usage (Update Latency In Microseconds)
-	0x09, 0x26,			//   Usage (Lamp Purposes)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0xff, 0x7f,	//   Logical Maximum (2147483647)
-	0x75, 0x20,			//   Report Size (32)
-	0x95, 0x05,			//   Report Count (5)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x28,			//   Usage (Red Level Count)
-	0x09, 0x29,			//   Usage (Green Level Count)
-	0x09, 0x2a,			//   Usage (Blue Level Count)
-	0x09, 0x2b,			//   Usage (Intensity Level Count)
-	0x09, 0x2c,			//   Usage (Is Programmable)
-	0x09, 0x2d,			//   Usage (Input Binding)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x26, 0xff, 0x00,		//   Logical Maximum (255)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x06,			//   Report Count (6)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0xc0,				//  End Collection
-	0x85, LAMP_MULTI_UPDATE_REPORT_ID, //  Report ID (4)
-	0x09, 0x50,			//  Usage (Lamp Multi Update Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x03,			//   Usage (Lamp Count)
-	0x09, 0x55,			//   Usage (Lamp Update Flags)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x25, 0x08,			//   Logical Maximum (8)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x02,			//   Report Count (2)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x21,			//   Usage (Lamp Id)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0x00, 0x00,	//   Logical Maximum (65535)
-	0x75, 0x10,			//   Report Size (16)
-	0x95, 0x08,			//   Report Count (8)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x26, 0xff, 0x00,		//   Logical Maximum (255)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x20,			//   Report Count (32)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0xc0,				//  End Collection
-	0x85, LAMP_RANGE_UPDATE_REPORT_ID, //  Report ID (5)
-	0x09, 0x60,			//  Usage (Lamp Range Update Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x55,			//   Usage (Lamp Update Flags)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x25, 0x08,			//   Logical Maximum (8)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x01,			//   Report Count (1)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x61,			//   Usage (Lamp Id Start)
-	0x09, 0x62,			//   Usage (Lamp Id End)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x27, 0xff, 0xff, 0x00, 0x00,	//   Logical Maximum (65535)
-	0x75, 0x10,			//   Report Size (16)
-	0x95, 0x02,			//   Report Count (2)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0x09, 0x51,			//   Usage (Red Update Channel)
-	0x09, 0x52,			//   Usage (Green Update Channel)
-	0x09, 0x53,			//   Usage (Blue Update Channel)
-	0x09, 0x54,			//   Usage (Intensity Update Channel)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x26, 0xff, 0x00,		//   Logical Maximum (255)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x04,			//   Report Count (4)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0xc0,				//  End Collection
-	0x85, LAMP_ARRAY_CONTROL_REPORT_ID, //  Report ID (6)
-	0x09, 0x70,			//  Usage (Lamp Array Control Report)
-	0xa1, 0x02,			//  Collection (Logical)
-	0x09, 0x71,			//   Usage (Autonomous Mode)
-	0x15, 0x00,			//   Logical Minimum (0)
-	0x25, 0x01,			//   Logical Maximum (1)
-	0x75, 0x08,			//   Report Size (8)
-	0x95, 0x01,			//   Report Count (1)
-	0xb1, 0x02,			//   Feature (Data,Var,Abs)
-	0xc0,				//  End Collection
-	0xc0				// End Collection
-};
-
-struct tux_kbl_map_entry_t {
-	u8 code;
-	struct {
-		u32 x;
-		u32 y;
-		u32 z;
-	} pos;
-};
-
-static const struct tux_kbl_map_entry_t sirius_16_ansii_kbl_map[] = {
-	{ 0x29, {  25000,  53000, 5000 } },
-	{ 0x3a, {  41700,  53000, 5000 } },
-	{ 0x3b, {  58400,  53000, 5000 } },
-	{ 0x3c, {  75100,  53000, 5000 } },
-	{ 0x3d, {  91800,  53000, 5000 } },
-	{ 0x3e, { 108500,  53000, 5000 } },
-	{ 0x3f, { 125200,  53000, 5000 } },
-	{ 0x40, { 141900,  53000, 5000 } },
-	{ 0x41, { 158600,  53000, 5000 } },
-	{ 0x42, { 175300,  53000, 5000 } },
-	{ 0x43, { 192000,  53000, 5000 } },
-	{ 0x44, { 208700,  53000, 5000 } },
-	{ 0x45, { 225400,  53000, 5000 } },
-	{ 0xf1, { 242100,  53000, 5000 } },
-	{ 0x46, { 258800,  53000, 5000 } },
-	{ 0x4c, { 275500,  53000, 5000 } },
-	{ 0x4a, { 294500,  53000, 5000 } },
-	{ 0x4d, { 311200,  53000, 5000 } },
-	{ 0x4b, { 327900,  53000, 5000 } },
-	{ 0x4e, { 344600,  53000, 5000 } },
-	{ 0x35, {  24500,  67500, 5250 } },
-	{ 0x1e, {  42500,  67500, 5250 } },
-	{ 0x1f, {  61000,  67500, 5250 } },
-	{ 0x20, {  79500,  67500, 5250 } },
-	{ 0x21, {  98000,  67500, 5250 } },
-	{ 0x22, { 116500,  67500, 5250 } },
-	{ 0x23, { 135000,  67500, 5250 } },
-	{ 0x24, { 153500,  67500, 5250 } },
-	{ 0x25, { 172000,  67500, 5250 } },
-	{ 0x26, { 190500,  67500, 5250 } },
-	{ 0x27, { 209000,  67500, 5250 } },
-	{ 0x2d, { 227500,  67500, 5250 } },
-	{ 0x2e, { 246000,  67500, 5250 } },
-	{ 0x2a, { 269500,  67500, 5250 } },
-	{ 0x53, { 294500,  67500, 5250 } },
-	{ 0x55, { 311200,  67500, 5250 } },
-	{ 0x54, { 327900,  67500, 5250 } },
-	{ 0x56, { 344600,  67500, 5250 } },
-	{ 0x2b, {  31000,  85500, 5500 } },
-	{ 0x14, {  51500,  85500, 5500 } },
-	{ 0x1a, {  70000,  85500, 5500 } },
-	{ 0x08, {  88500,  85500, 5500 } },
-	{ 0x15, { 107000,  85500, 5500 } },
-	{ 0x17, { 125500,  85500, 5500 } },
-	{ 0x1c, { 144000,  85500, 5500 } },
-	{ 0x18, { 162500,  85500, 5500 } },
-	{ 0x0c, { 181000,  85500, 5500 } },
-	{ 0x12, { 199500,  85500, 5500 } },
-	{ 0x13, { 218000,  85500, 5500 } },
-	{ 0x2f, { 236500,  85500, 5500 } },
-	{ 0x30, { 255000,  85500, 5500 } },
-	{ 0x31, { 273500,  85500, 5500 } },
-	{ 0x5f, { 294500,  85500, 5500 } },
-	{ 0x60, { 311200,  85500, 5500 } },
-	{ 0x61, { 327900,  85500, 5500 } },
-	{ 0x39, {  33000, 103500, 5750 } },
-	{ 0x04, {  57000, 103500, 5750 } },
-	{ 0x16, {  75500, 103500, 5750 } },
-	{ 0x07, {  94000, 103500, 5750 } },
-	{ 0x09, { 112500, 103500, 5750 } },
-	{ 0x0a, { 131000, 103500, 5750 } },
-	{ 0x0b, { 149500, 103500, 5750 } },
-	{ 0x0d, { 168000, 103500, 5750 } },
-	{ 0x0e, { 186500, 103500, 5750 } },
-	{ 0x0f, { 205000, 103500, 5750 } },
-	{ 0x33, { 223500, 103500, 5750 } },
-	{ 0x34, { 242000, 103500, 5750 } },
-	{ 0x28, { 267500, 103500, 5750 } },
-	{ 0x5c, { 294500, 103500, 5750 } },
-	{ 0x5d, { 311200, 103500, 5750 } },
-	{ 0x5e, { 327900, 103500, 5750 } },
-	{ 0x57, { 344600,  94500, 5625 } },
-	{ 0xe1, {  37000, 121500, 6000 } },
-	{ 0x1d, {  66000, 121500, 6000 } },
-	{ 0x1b, {  84500, 121500, 6000 } },
-	{ 0x06, { 103000, 121500, 6000 } },
-	{ 0x19, { 121500, 121500, 6000 } },
-	{ 0x05, { 140000, 121500, 6000 } },
-	{ 0x11, { 158500, 121500, 6000 } },
-	{ 0x10, { 177000, 121500, 6000 } },
-	{ 0x36, { 195500, 121500, 6000 } },
-	{ 0x37, { 214000, 121500, 6000 } },
-	{ 0x38, { 232500, 121500, 6000 } },
-	{ 0xe5, { 251500, 121500, 6000 } },
-	{ 0x52, { 273500, 129000, 6125 } },
-	{ 0x59, { 294500, 121500, 6000 } },
-	{ 0x5a, { 311200, 121500, 6000 } },
-	{ 0x5b, { 327900, 121500, 6000 } },
-	{ 0xe0, {  28000, 139500, 6250 } },
-	{ 0xfe, {  47500, 139500, 6250 } },
-	{ 0xe3, {  66000, 139500, 6250 } },
-	{ 0xe2, {  84500, 139500, 6250 } },
-	{ 0x2c, { 140000, 139500, 6250 } },
-	{ 0xe6, { 195500, 139500, 6250 } },
-	{ 0x65, { 214000, 139500, 6250 } },
-	{ 0xe4, { 234000, 139500, 6250 } },
-	{ 0x50, { 255000, 147000, 6375 } },
-	{ 0x51, { 273500, 147000, 6375 } },
-	{ 0x4f, { 292000, 147000, 6375 } },
-	{ 0x62, { 311200, 139500, 6250 } },
-	{ 0x63, { 327900, 139500, 6250 } },
-	{ 0x58, { 344600, 130500, 6125 } },
-};
-
-static const struct tux_kbl_map_entry_t sirius_16_iso_kbl_map[] = {
-	{ 0x29, {  25000,  53000, 5000 } },
-	{ 0x3a, {  41700,  53000, 5000 } },
-	{ 0x3b, {  58400,  53000, 5000 } },
-	{ 0x3c, {  75100,  53000, 5000 } },
-	{ 0x3d, {  91800,  53000, 5000 } },
-	{ 0x3e, { 108500,  53000, 5000 } },
-	{ 0x3f, { 125200,  53000, 5000 } },
-	{ 0x40, { 141900,  53000, 5000 } },
-	{ 0x41, { 158600,  53000, 5000 } },
-	{ 0x42, { 175300,  53000, 5000 } },
-	{ 0x43, { 192000,  53000, 5000 } },
-	{ 0x44, { 208700,  53000, 5000 } },
-	{ 0x45, { 225400,  53000, 5000 } },
-	{ 0xf1, { 242100,  53000, 5000 } },
-	{ 0x46, { 258800,  53000, 5000 } },
-	{ 0x4c, { 275500,  53000, 5000 } },
-	{ 0x4a, { 294500,  53000, 5000 } },
-	{ 0x4d, { 311200,  53000, 5000 } },
-	{ 0x4b, { 327900,  53000, 5000 } },
-	{ 0x4e, { 344600,  53000, 5000 } },
-	{ 0x35, {  24500,  67500, 5250 } },
-	{ 0x1e, {  42500,  67500, 5250 } },
-	{ 0x1f, {  61000,  67500, 5250 } },
-	{ 0x20, {  79500,  67500, 5250 } },
-	{ 0x21, {  98000,  67500, 5250 } },
-	{ 0x22, { 116500,  67500, 5250 } },
-	{ 0x23, { 135000,  67500, 5250 } },
-	{ 0x24, { 153500,  67500, 5250 } },
-	{ 0x25, { 172000,  67500, 5250 } },
-	{ 0x26, { 190500,  67500, 5250 } },
-	{ 0x27, { 209000,  67500, 5250 } },
-	{ 0x2d, { 227500,  67500, 5250 } },
-	{ 0x2e, { 246000,  67500, 5250 } },
-	{ 0x2a, { 269500,  67500, 5250 } },
-	{ 0x53, { 294500,  67500, 5250 } },
-	{ 0x55, { 311200,  67500, 5250 } },
-	{ 0x54, { 327900,  67500, 5250 } },
-	{ 0x56, { 344600,  67500, 5250 } },
-	{ 0x2b, {  31000,  85500, 5500 } },
-	{ 0x14, {  51500,  85500, 5500 } },
-	{ 0x1a, {  70000,  85500, 5500 } },
-	{ 0x08, {  88500,  85500, 5500 } },
-	{ 0x15, { 107000,  85500, 5500 } },
-	{ 0x17, { 125500,  85500, 5500 } },
-	{ 0x1c, { 144000,  85500, 5500 } },
-	{ 0x18, { 162500,  85500, 5500 } },
-	{ 0x0c, { 181000,  85500, 5500 } },
-	{ 0x12, { 199500,  85500, 5500 } },
-	{ 0x13, { 218000,  85500, 5500 } },
-	{ 0x2f, { 234500,  85500, 5500 } },
-	{ 0x30, { 251000,  85500, 5500 } },
-	{ 0x5f, { 294500,  85500, 5500 } },
-	{ 0x60, { 311200,  85500, 5500 } },
-	{ 0x61, { 327900,  85500, 5500 } },
-	{ 0x39, {  33000, 103500, 5750 } },
-	{ 0x04, {  57000, 103500, 5750 } },
-	{ 0x16, {  75500, 103500, 5750 } },
-	{ 0x07, {  94000, 103500, 5750 } },
-	{ 0x09, { 112500, 103500, 5750 } },
-	{ 0x0a, { 131000, 103500, 5750 } },
-	{ 0x0b, { 149500, 103500, 5750 } },
-	{ 0x0d, { 168000, 103500, 5750 } },
-	{ 0x0e, { 186500, 103500, 5750 } },
-	{ 0x0f, { 205000, 103500, 5750 } },
-	{ 0x33, { 223500, 103500, 5750 } },
-	{ 0x34, { 240000, 103500, 5750 } },
-	{ 0x32, { 256500, 103500, 5750 } },
-	{ 0x28, { 271500,  94500, 5750 } },
-	{ 0x5c, { 294500, 103500, 5750 } },
-	{ 0x5d, { 311200, 103500, 5750 } },
-	{ 0x5e, { 327900, 103500, 5750 } },
-	{ 0x57, { 344600,  94500, 5625 } },
-	{ 0xe1, {  28000, 121500, 6000 } },
-	{ 0x64, {  47500, 121500, 6000 } },
-	{ 0x1d, {  66000, 121500, 6000 } },
-	{ 0x1b, {  84500, 121500, 6000 } },
-	{ 0x06, { 103000, 121500, 6000 } },
-	{ 0x19, { 121500, 121500, 6000 } },
-	{ 0x05, { 140000, 121500, 6000 } },
-	{ 0x11, { 158500, 121500, 6000 } },
-	{ 0x10, { 177000, 121500, 6000 } },
-	{ 0x36, { 195500, 121500, 6000 } },
-	{ 0x37, { 214000, 121500, 6000 } },
-	{ 0x38, { 232500, 121500, 6000 } },
-	{ 0xe5, { 251500, 121500, 6000 } },
-	{ 0x52, { 273500, 129000, 6125 } },
-	{ 0x59, { 294500, 121500, 6000 } },
-	{ 0x5a, { 311200, 121500, 6000 } },
-	{ 0x5b, { 327900, 121500, 6000 } },
-	{ 0xe0, {  28000, 139500, 6250 } },
-	{ 0xfe, {  47500, 139500, 6250 } },
-	{ 0xe3, {  66000, 139500, 6250 } },
-	{ 0xe2, {  84500, 139500, 6250 } },
-	{ 0x2c, { 140000, 139500, 6250 } },
-	{ 0xe6, { 195500, 139500, 6250 } },
-	{ 0x65, { 214000, 139500, 6250 } },
-	{ 0xe4, { 234000, 139500, 6250 } },
-	{ 0x50, { 255000, 147000, 6375 } },
-	{ 0x51, { 273500, 147000, 6375 } },
-	{ 0x4f, { 292000, 147000, 6375 } },
-	{ 0x62, { 311200, 139500, 6250 } },
-	{ 0x63, { 327900, 139500, 6250 } },
-	{ 0x58, { 344600, 130500, 6125 } },
-};
-
-struct tux_driver_data_t {
-	struct hid_device *hdev;
-};
-
-struct tux_hdev_driver_data_t {
-	u8 lamp_count;
-	const struct tux_kbl_map_entry_t *kbl_map;
-	u8 next_lamp_id;
-	union tux_wmi_xx_496in_80out_in_t next_kbl_set_multiple_keys_in;
-};
-
-static int tux_ll_start(struct hid_device *hdev)
-{
-	struct wmi_device *wdev = to_wmi_device(hdev->dev.parent);
-	struct tux_hdev_driver_data_t *driver_data;
-	union tux_wmi_xx_8in_80out_out_t out;
-	union tux_wmi_xx_8in_80out_in_t in;
-	u8 keyboard_type;
-	int ret;
-
-	driver_data = devm_kzalloc(&hdev->dev, sizeof(*driver_data), GFP_KERNEL);
-	if (!driver_data)
-		return -ENOMEM;
-
-	in.get_device_status_in.device_type = TUX_GET_DEVICE_STATUS_DEVICE_ID_KEYBOARD;
-	ret = tux_wmi_xx_8in_80out(wdev, TUX_GET_DEVICE_STATUS, &in, &out);
-	if (ret)
-		return ret;
-
-	keyboard_type = out.get_device_status_out.keyboard_physical_layout;
-	if (keyboard_type == TUX_GET_DEVICE_STATUS_KEYBOARD_LAYOUT_ANSII) {
-		driver_data->lamp_count = ARRAY_SIZE(sirius_16_ansii_kbl_map);
-		driver_data->kbl_map = sirius_16_ansii_kbl_map;
-	} else if (keyboard_type == TUX_GET_DEVICE_STATUS_KEYBOARD_LAYOUT_ISO) {
-		driver_data->lamp_count = ARRAY_SIZE(sirius_16_iso_kbl_map);
-		driver_data->kbl_map = sirius_16_iso_kbl_map;
-	} else {
-		return -EINVAL;
-	}
-	driver_data->next_lamp_id = 0;
-
-	dev_set_drvdata(&hdev->dev, driver_data);
-
-	return ret;
-}
-
-static void tux_ll_stop(struct hid_device *hdev __always_unused)
-{
-}
-
-static int tux_ll_open(struct hid_device *hdev __always_unused)
-{
-	return 0;
-}
-
-static void tux_ll_close(struct hid_device *hdev __always_unused)
-{
-}
-
-static int tux_ll_parse(struct hid_device *hdev)
-{
-	return hid_parse_report(hdev, tux_report_descriptor,
-				sizeof(tux_report_descriptor));
-}
-
-struct __packed lamp_array_attributes_report_t {
-	const u8 report_id;
-	u16 lamp_count;
-	u32 bounding_box_width_in_micrometers;
-	u32 bounding_box_height_in_micrometers;
-	u32 bounding_box_depth_in_micrometers;
-	u32 lamp_array_kind;
-	u32 min_update_interval_in_microseconds;
-};
-
-static int handle_lamp_array_attributes_report(struct hid_device *hdev,
-					       struct lamp_array_attributes_report_t *rep)
-{
-	struct tux_hdev_driver_data_t *driver_data = dev_get_drvdata(&hdev->dev);
-
-	rep->lamp_count = driver_data->lamp_count;
-	rep->bounding_box_width_in_micrometers = 368000;
-	rep->bounding_box_height_in_micrometers = 266000;
-	rep->bounding_box_depth_in_micrometers = 30000;
-	/*
-	 * LampArrayKindKeyboard, see "26.2.1 LampArrayKind Values" of
-	 * "HID Usage Tables v1.5"
-	 */
-	rep->lamp_array_kind = 1;
-	// Some guessed value for interval microseconds
-	rep->min_update_interval_in_microseconds = 500;
-
-	return sizeof(*rep);
-}
-
-struct __packed lamp_attributes_request_report_t {
-	const u8 report_id;
-	u16 lamp_id;
-};
-
-static int handle_lamp_attributes_request_report(struct hid_device *hdev,
-						 struct lamp_attributes_request_report_t *rep)
-{
-	struct tux_hdev_driver_data_t *driver_data = dev_get_drvdata(&hdev->dev);
-
-	if (rep->lamp_id < driver_data->lamp_count)
-		driver_data->next_lamp_id = rep->lamp_id;
-	else
-		driver_data->next_lamp_id = 0;
-
-	return sizeof(*rep);
-}
-
-struct __packed lamp_attributes_response_report_t {
-	const u8 report_id;
-	u16 lamp_id;
-	u32 position_x_in_micrometers;
-	u32 position_y_in_micrometers;
-	u32 position_z_in_micrometers;
-	u32 update_latency_in_microseconds;
-	u32 lamp_purpose;
-	u8 red_level_count;
-	u8 green_level_count;
-	u8 blue_level_count;
-	u8 intensity_level_count;
-	u8 is_programmable;
-	u8 input_binding;
-};
-
-static int handle_lamp_attributes_response_report(struct hid_device *hdev,
-						  struct lamp_attributes_response_report_t *rep)
-{
-	struct tux_hdev_driver_data_t *driver_data = dev_get_drvdata(&hdev->dev);
-	u16 lamp_id = driver_data->next_lamp_id;
-
-	rep->lamp_id = lamp_id;
-	// Some guessed value for latency microseconds
-	rep->update_latency_in_microseconds = 100;
-	/*
-	 * LampPurposeControl, see "26.3.1 LampPurposes Flags" of
-	 * "HID Usage Tables v1.5"
-	 */
-	rep->lamp_purpose = 1;
-	rep->red_level_count = 0xff;
-	rep->green_level_count = 0xff;
-	rep->blue_level_count = 0xff;
-	rep->intensity_level_count = 0xff;
-	rep->is_programmable = 1;
-
-	if (driver_data->kbl_map[lamp_id].code <= 0xe8) {
-		rep->input_binding = driver_data->kbl_map[lamp_id].code;
-	} else {
-		/*
-		 * Everything bigger is reserved/undefined, see
-		 * "10 Keyboard/Keypad Page (0x07)" of "HID Usage Tables v1.5"
-		 * and should return 0, see "26.8.3 Lamp Attributes" of the same
-		 * document.
-		 */
-		rep->input_binding = 0;
-	}
-	rep->position_x_in_micrometers = driver_data->kbl_map[lamp_id].pos.x;
-	rep->position_y_in_micrometers = driver_data->kbl_map[lamp_id].pos.y;
-	rep->position_z_in_micrometers = driver_data->kbl_map[lamp_id].pos.z;
-
-	driver_data->next_lamp_id = (driver_data->next_lamp_id + 1) % driver_data->lamp_count;
-
-	return sizeof(*rep);
-}
-
-#define LAMP_UPDATE_FLAGS_LAMP_UPDATE_COMPLETE	BIT(0)
-
-struct __packed lamp_rgbi_tuple_t {
-	u8 red;
-	u8 green;
-	u8 blue;
-	u8 intensity;
-};
-
-#define LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX	8
-
-struct __packed lamp_multi_update_report_t {
-	const u8 report_id;
-	u8 lamp_count;
-	u8 lamp_update_flags;
-	u16 lamp_id[LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX];
-	struct lamp_rgbi_tuple_t update_channels[LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX];
-};
-
-static int handle_lamp_multi_update_report(struct hid_device *hdev,
-					   struct lamp_multi_update_report_t *rep)
-{
-	struct tux_hdev_driver_data_t *driver_data = dev_get_drvdata(&hdev->dev);
-	union tux_wmi_xx_496in_80out_in_t *next = &driver_data->next_kbl_set_multiple_keys_in;
-	struct tux_kbl_set_multiple_keys_in_rgb_config_t *rgb_configs_j;
-	struct wmi_device *wdev = to_wmi_device(hdev->dev.parent);
-	union tux_wmi_xx_496in_80out_out_t out;
-	u8 key_id, key_id_j, intensity_i, red_i, green_i, blue_i;
-	int ret;
-
-	/*
-	 * Catching misformatted lamp_multi_update_report and fail silently
-	 * according to "HID Usage Tables v1.5"
-	 */
-	for (unsigned int i = 0; i < rep->lamp_count; ++i) {
-		if (rep->lamp_id[i] > driver_data->lamp_count) {
-			hid_dbg(hdev, "Out of bounds lamp_id in lamp_multi_update_report. Skipping whole report!\n");
-			return sizeof(*rep);
-		}
-
-		for (unsigned int j = i + 1; j < rep->lamp_count; ++j) {
-			if (rep->lamp_id[i] == rep->lamp_id[j]) {
-				hid_dbg(hdev, "Duplicate lamp_id in lamp_multi_update_report. Skipping whole report!\n");
-				return sizeof(*rep);
-			}
-		}
-	}
-
-	for (unsigned int i = 0; i < rep->lamp_count; ++i) {
-		key_id = driver_data->kbl_map[rep->lamp_id[i]].code;
-
-		for (unsigned int j = 0;
-		     j < TUX_KBL_SET_MULTIPLE_KEYS_LIGHTING_SETTINGS_COUNT_MAX;
-		     ++j) {
-			rgb_configs_j = &next->kbl_set_multiple_keys_in.rgb_configs[j];
-			key_id_j = rgb_configs_j->key_id;
-			if (key_id_j != 0x00 && key_id_j != key_id)
-				continue;
-
-			if (key_id_j == 0x00)
-				next->kbl_set_multiple_keys_in.rgb_configs_cnt =
-					j + 1;
-			rgb_configs_j->key_id = key_id;
-			/*
-			 * While this driver respects update_channel.intensity
-			 * according to "HID Usage Tables v1.5" also on RGB
-			 * leds, the Microsoft MacroPad reference implementation
-			 * (https://github.com/microsoft/RP2040MacropadHidSample
-			 * 1d6c3ad) does not and ignores it. If it turns out
-			 * that Windows writes intensity = 0 for RGB leds
-			 * instead of intensity = 255, this driver should also
-			 * ignore the update_channel.intensity.
-			 */
-			intensity_i = rep->update_channels[i].intensity;
-			red_i = rep->update_channels[i].red;
-			green_i = rep->update_channels[i].green;
-			blue_i = rep->update_channels[i].blue;
-			rgb_configs_j->red = red_i * intensity_i / 0xff;
-			rgb_configs_j->green = green_i * intensity_i / 0xff;
-			rgb_configs_j->blue = blue_i * intensity_i / 0xff;
-
-			break;
-		}
-	}
-
-	if (rep->lamp_update_flags & LAMP_UPDATE_FLAGS_LAMP_UPDATE_COMPLETE) {
-		ret = tux_wmi_xx_496in_80out(wdev, TUX_KBL_SET_MULTIPLE_KEYS,
-					     next, &out);
-		memset(next, 0, sizeof(*next));
-		if (ret)
-			return ret;
-	}
-
-	return sizeof(*rep);
-}
-
-struct __packed lamp_range_update_report_t {
-	const u8 report_id;
-	u8 lamp_update_flags;
-	u16 lamp_id_start;
-	u16 lamp_id_end;
-	struct lamp_rgbi_tuple_t update_channel;
-};
-
-static int handle_lamp_range_update_report(struct hid_device *hdev,
-					   struct lamp_range_update_report_t *rep)
-{
-	struct tux_hdev_driver_data_t *driver_data = dev_get_drvdata(&hdev->dev);
-	struct lamp_multi_update_report_t lamp_multi_update_report = {
-		.report_id = LAMP_MULTI_UPDATE_REPORT_ID,
-	};
-	struct lamp_rgbi_tuple_t *update_channels_j;
-	int ret;
-
-	/*
-	 * Catching misformatted lamp_range_update_report and fail silently
-	 * according to "HID Usage Tables v1.5"
-	 */
-	if (rep->lamp_id_start > rep->lamp_id_end) {
-		hid_dbg(hdev, "lamp_id_start > lamp_id_end in lamp_range_update_report. Skipping whole report!\n");
-		return sizeof(*rep);
-	}
-
-	if (rep->lamp_id_end > driver_data->lamp_count - 1) {
-		hid_dbg(hdev, "Out of bounds lamp_id_end in lamp_range_update_report. Skipping whole report!\n");
-		return sizeof(*rep);
-	}
-
-	/*
-	 * Break handle_lamp_range_update_report call down to multiple
-	 * handle_lamp_multi_update_report calls to easily ensure that mixing
-	 * handle_lamp_range_update_report and handle_lamp_multi_update_report
-	 * does not break things.
-	 */
-	for (unsigned int i = rep->lamp_id_start; i < rep->lamp_id_end + 1;
-	     i = i + LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX) {
-		lamp_multi_update_report.lamp_count =
-			min(rep->lamp_id_end + 1 - i,
-			    LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX);
-		lamp_multi_update_report.lamp_update_flags =
-			i + LAMP_MULTI_UPDATE_REPORT_LAMP_COUNT_MAX >=
-			rep->lamp_id_end + 1 ?
-				LAMP_UPDATE_FLAGS_LAMP_UPDATE_COMPLETE : 0;
-
-		for (unsigned int j = 0; j < lamp_multi_update_report.lamp_count; ++j) {
-			lamp_multi_update_report.lamp_id[j] = i + j;
-			update_channels_j =
-				&lamp_multi_update_report.update_channels[j];
-			update_channels_j->red = rep->update_channel.red;
-			update_channels_j->green = rep->update_channel.green;
-			update_channels_j->blue = rep->update_channel.blue;
-			update_channels_j->intensity = rep->update_channel.intensity;
-		}
-
-		ret = handle_lamp_multi_update_report(hdev, &lamp_multi_update_report);
-		if (ret < 0)
-			return ret;
-		if (ret != sizeof(lamp_multi_update_report))
-			return -EIO;
-	}
-
-	return sizeof(*rep);
-}
-
-struct __packed lamp_array_control_report_t {
-	const u8 report_id;
-	u8 autonomous_mode;
-};
-
-static int handle_lamp_array_control_report(struct hid_device *hdev __always_unused,
-					    struct lamp_array_control_report_t *rep)
-{
-	/*
-	 * The keyboards firmware doesn't have any built in controls and the
-	 * built in effects are not implemented so this is a NOOP.
-	 * According to the HID Documentation (HID Usage Tables v1.5) this
-	 * function is optional and can be removed from the HID Report
-	 * Descriptor, but it should first be confirmed that userspace respects
-	 * this possibility too. The Microsoft MacroPad reference implementation
-	 * (https://github.com/microsoft/RP2040MacropadHidSample 1d6c3ad)
-	 * already deviates from the spec at another point, see
-	 * handle_lamp_*_update_report.
-	 */
-
-	return sizeof(*rep);
-}
-
-static int tux_ll_raw_request(struct hid_device *hdev, u8 reportnum, u8 *buf,
-			      size_t len, unsigned char rtype, int reqtype)
-{
-	if (rtype != HID_FEATURE_REPORT)
-		return -EINVAL;
-
-	switch (reqtype) {
-	case HID_REQ_GET_REPORT:
-		switch (reportnum) {
-		case LAMP_ARRAY_ATTRIBUTES_REPORT_ID:
-			if (len != sizeof(struct lamp_array_attributes_report_t))
-				return -EINVAL;
-			return handle_lamp_array_attributes_report(hdev,
-				(struct lamp_array_attributes_report_t *)buf);
-		case LAMP_ATTRIBUTES_RESPONSE_REPORT_ID:
-			if (len != sizeof(struct lamp_attributes_response_report_t))
-				return -EINVAL;
-			return handle_lamp_attributes_response_report(hdev,
-				(struct lamp_attributes_response_report_t *)buf);
-		}
-		break;
-	case HID_REQ_SET_REPORT:
-		switch (reportnum) {
-		case LAMP_ATTRIBUTES_REQUEST_REPORT_ID:
-			if (len != sizeof(struct lamp_attributes_request_report_t))
-				return -EINVAL;
-			return handle_lamp_attributes_request_report(hdev,
-				(struct lamp_attributes_request_report_t *)buf);
-		case LAMP_MULTI_UPDATE_REPORT_ID:
-			if (len != sizeof(struct lamp_multi_update_report_t))
-				return -EINVAL;
-			return handle_lamp_multi_update_report(hdev,
-				(struct lamp_multi_update_report_t *)buf);
-		case LAMP_RANGE_UPDATE_REPORT_ID:
-			if (len != sizeof(struct lamp_range_update_report_t))
-				return -EINVAL;
-			return handle_lamp_range_update_report(hdev,
-				(struct lamp_range_update_report_t *)buf);
-		case LAMP_ARRAY_CONTROL_REPORT_ID:
-			if (len != sizeof(struct lamp_array_control_report_t))
-				return -EINVAL;
-			return handle_lamp_array_control_report(hdev,
-				(struct lamp_array_control_report_t *)buf);
-		}
-		break;
-	}
-
-	return -EINVAL;
-}
-
-static const struct hid_ll_driver tux_ll_driver = {
-	.start = &tux_ll_start,
-	.stop = &tux_ll_stop,
-	.open = &tux_ll_open,
-	.close = &tux_ll_close,
-	.parse = &tux_ll_parse,
-	.raw_request = &tux_ll_raw_request,
-};
-
-static int tux_virt_lamparray_add_device(struct wmi_device *wdev,
-					 struct hid_device **hdev_out)
-{
-	struct hid_device *hdev;
-	int ret;
-
-	dev_dbg(&wdev->dev, "Adding TUXEDO NB04 Virtual LampArray device.\n");
-
-	hdev = hid_allocate_device();
-	if (IS_ERR(hdev))
-		return PTR_ERR(hdev);
-	*hdev_out = hdev;
-
-	strscpy(hdev->name, "TUXEDO NB04 RGB Lighting", sizeof(hdev->name));
-
-	hdev->ll_driver = &tux_ll_driver;
-	hdev->bus = BUS_VIRTUAL;
-	hdev->vendor = 0x21ba;
-	hdev->product = 0x0400;
-	hdev->dev.parent = &wdev->dev;
-
-	ret = hid_add_device(hdev);
-	if (ret)
-		hid_destroy_device(hdev);
-	return ret;
-}
-
-static int tux_probe(struct wmi_device *wdev, const void *context __always_unused)
-{
-	struct tux_driver_data_t *driver_data;
-
-	driver_data = devm_kzalloc(&wdev->dev, sizeof(*driver_data), GFP_KERNEL);
-	if (!driver_data)
-		return -ENOMEM;
-
-	dev_set_drvdata(&wdev->dev, driver_data);
-
-	return tux_virt_lamparray_add_device(wdev, &driver_data->hdev);
-}
-
-static void tux_remove(struct wmi_device *wdev)
-{
-	struct tux_driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
-
-	hid_destroy_device(driver_data->hdev);
-}
-
-static struct wmi_driver tuxedo_nb04_wmi_tux_driver = {
-	.driver = {
-		.name = "tuxedo_nb04_wmi_ab",
-		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
-	},
-	.id_table = tuxedo_nb04_wmi_ab_device_ids,
-	.probe = tux_probe,
-	.remove = tux_remove,
-	.no_singleton = true,
-};
-
-/*
- * We don't know if the WMI API is stable and how unique the GUID is for this
- * ODM. To be on the safe side we therefore only run this driver on tested
- * devices defined by this list.
- */
-static const struct dmi_system_id tested_devices_dmi_table[] __initconst = {
-	{
-		// TUXEDO Sirius 16 Gen1
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "APX958"),
-		},
-	},
-	{
-		// TUXEDO Sirius 16 Gen2
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AHP958"),
-		},
-	},
-	{ }
-};
-
-static int __init tuxedo_nb04_wmi_tux_init(void)
-{
-	if (!dmi_check_system(tested_devices_dmi_table))
-		return -ENODEV;
-
-	return wmi_driver_register(&tuxedo_nb04_wmi_tux_driver);
-}
-module_init(tuxedo_nb04_wmi_tux_init);
-
-static void __exit tuxedo_nb04_wmi_tux_exit(void)
-{
-	return wmi_driver_unregister(&tuxedo_nb04_wmi_tux_driver);
-}
-module_exit(tuxedo_nb04_wmi_tux_exit);
-
-MODULE_DESCRIPTION("Virtual HID LampArray interface for TUXEDO NB04 devices");
-MODULE_AUTHOR("Werner Sembach <wse@tuxedocomputers.com>");
-MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_util.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_util.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_util.c	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_util.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * This code gives functions to avoid code duplication while interacting with
- * the TUXEDO NB04 wmi interfaces.
- *
- * Copyright (C) 2024-2025 Werner Sembach <wse@tuxedocomputers.com>
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/cleanup.h>
-#include <linux/wmi.h>
-
-#include "wmi_util.h"
-
-static int __wmi_method_acpi_object_out(struct wmi_device *wdev,
-					u32 wmi_method_id,
-					u8 *in,
-					acpi_size in_len,
-					union acpi_object **out)
-{
-	struct acpi_buffer acpi_buffer_in = { in_len, in };
-	struct acpi_buffer acpi_buffer_out = { ACPI_ALLOCATE_BUFFER, NULL };
-
-	dev_dbg(&wdev->dev, "Evaluate WMI method: %u in:\n", wmi_method_id);
-	print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, in, in_len);
-
-	acpi_status status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
-						    &acpi_buffer_in,
-						    &acpi_buffer_out);
-	if (ACPI_FAILURE(status)) {
-		dev_err(&wdev->dev, "Failed to evaluate WMI method.\n");
-		return -EIO;
-	}
-	if (!acpi_buffer_out.pointer) {
-		dev_err(&wdev->dev, "Unexpected empty out buffer.\n");
-		return -ENODATA;
-	}
-
-	*out = acpi_buffer_out.pointer;
-
-	return 0;
-}
-
-static int __wmi_method_buffer_out(struct wmi_device *wdev,
-				   u32 wmi_method_id,
-				   u8 *in,
-				   acpi_size in_len,
-				   u8 *out,
-				   acpi_size out_len)
-{
-	int ret;
-
-	union acpi_object *acpi_object_out __free(kfree) = NULL;
-
-	ret = __wmi_method_acpi_object_out(wdev, wmi_method_id,
-					   in, in_len,
-					   &acpi_object_out);
-	if (ret)
-		return ret;
-
-	if (acpi_object_out->type != ACPI_TYPE_BUFFER) {
-		dev_err(&wdev->dev, "Unexpected out buffer type. Expected: %u Got: %u\n",
-			ACPI_TYPE_BUFFER, acpi_object_out->type);
-		return -EIO;
-	}
-	if (acpi_object_out->buffer.length < out_len) {
-		dev_err(&wdev->dev, "Unexpected out buffer length.\n");
-		return -EIO;
-	}
-
-	memcpy(out, acpi_object_out->buffer.pointer, out_len);
-
-	return 0;
-}
-
-int tux_wmi_xx_8in_80out(struct wmi_device *wdev,
-			 enum tux_wmi_xx_8in_80out_methods method,
-			 union tux_wmi_xx_8in_80out_in_t *in,
-			 union tux_wmi_xx_8in_80out_out_t *out)
-{
-	return __wmi_method_buffer_out(wdev, method, in->raw, 8, out->raw, 80);
-}
-
-int tux_wmi_xx_496in_80out(struct wmi_device *wdev,
-			   enum tux_wmi_xx_496in_80out_methods method,
-			   union tux_wmi_xx_496in_80out_in_t *in,
-			   union tux_wmi_xx_496in_80out_out_t *out)
-{
-	return __wmi_method_buffer_out(wdev, method, in->raw, 496, out->raw, 80);
-}
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_util.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_util.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/nb04/wmi_util.h	2025-12-18 14:00:17.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/nb04/wmi_util.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * This code gives functions to avoid code duplication while interacting with
- * the TUXEDO NB04 wmi interfaces.
- *
- * Copyright (C) 2024-2025 Werner Sembach <wse@tuxedocomputers.com>
- */
-
-#ifndef TUXEDO_NB04_WMI_UTIL_H
-#define TUXEDO_NB04_WMI_UTIL_H
-
-#include <linux/wmi.h>
-
-#define TUX_GET_DEVICE_STATUS_DEVICE_ID_TOUCHPAD	1
-#define TUX_GET_DEVICE_STATUS_DEVICE_ID_KEYBOARD	2
-#define TUX_GET_DEVICE_STATUS_DEVICE_ID_APP_PAGES	3
-
-#define TUX_GET_DEVICE_STATUS_KBL_TYPE_NONE		0
-#define TUX_GET_DEVICE_STATUS_KBL_TYPE_PER_KEY		1
-#define TUX_GET_DEVICE_STATUS_KBL_TYPE_FOUR_ZONE	2
-#define TUX_GET_DEVICE_STATUS_KBL_TYPE_WHITE_ONLY	3
-
-#define TUX_GET_DEVICE_STATUS_KEYBOARD_LAYOUT_ANSII	0
-#define TUX_GET_DEVICE_STATUS_KEYBOARD_LAYOUT_ISO	1
-
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_RED		1
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_GREEN		2
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_YELLOW		3
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_BLUE		4
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_PURPLE		5
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_INDIGO		6
-#define TUX_GET_DEVICE_STATUS_COLOR_ID_WHITE		7
-
-#define TUX_GET_DEVICE_STATUS_APP_PAGES_DASHBOARD	BIT(0)
-#define TUX_GET_DEVICE_STATUS_APP_PAGES_SYSTEMINFOS	BIT(1)
-#define TUX_GET_DEVICE_STATUS_APP_PAGES_KBL		BIT(2)
-#define TUX_GET_DEVICE_STATUS_APP_PAGES_HOTKEYS		BIT(3)
-
-union tux_wmi_xx_8in_80out_in_t {
-	u8 raw[8];
-	struct __packed {
-		u8 device_type;
-		u8 reserved[7];
-	} get_device_status_in;
-};
-
-union tux_wmi_xx_8in_80out_out_t {
-	u8 raw[80];
-	struct __packed {
-		u16 return_status;
-		u8 device_enabled;
-		u8 kbl_type;
-		u8 kbl_side_bar_supported;
-		u8 keyboard_physical_layout;
-		u8 app_pages;
-		u8 per_key_kbl_default_color;
-		u8 four_zone_kbl_default_color_1;
-		u8 four_zone_kbl_default_color_2;
-		u8 four_zone_kbl_default_color_3;
-		u8 four_zone_kbl_default_color_4;
-		u8 light_bar_kbl_default_color;
-		u8 reserved_0[1];
-		u16 dedicated_gpu_id;
-		u8 reserved_1[64];
-	} get_device_status_out;
-};
-
-enum tux_wmi_xx_8in_80out_methods {
-	TUX_GET_DEVICE_STATUS	= 2,
-};
-
-#define TUX_KBL_SET_MULTIPLE_KEYS_LIGHTING_SETTINGS_COUNT_MAX	120
-
-union tux_wmi_xx_496in_80out_in_t {
-	u8 raw[496];
-	struct __packed {
-		u8 reserved[15];
-		u8 rgb_configs_cnt;
-		struct tux_kbl_set_multiple_keys_in_rgb_config_t {
-			u8 key_id;
-			u8 red;
-			u8 green;
-			u8 blue;
-		} rgb_configs[TUX_KBL_SET_MULTIPLE_KEYS_LIGHTING_SETTINGS_COUNT_MAX];
-	}  kbl_set_multiple_keys_in;
-};
-
-union tux_wmi_xx_496in_80out_out_t {
-	u8 raw[80];
-	struct __packed {
-		u8 return_value;
-		u8 reserved[79];
-	} kbl_set_multiple_keys_out;
-};
-
-enum tux_wmi_xx_496in_80out_methods {
-	TUX_KBL_SET_MULTIPLE_KEYS	= 6,
-};
-
-int tux_wmi_xx_8in_80out(struct wmi_device *wdev,
-			 enum tux_wmi_xx_8in_80out_methods method,
-			 union tux_wmi_xx_8in_80out_in_t *in,
-			 union tux_wmi_xx_8in_80out_out_t *out);
-int tux_wmi_xx_496in_80out(struct wmi_device *wdev,
-			   enum tux_wmi_xx_496in_80out_methods method,
-			   union tux_wmi_xx_496in_80out_in_t *in,
-			   union tux_wmi_xx_496in_80out_out_t *out);
-
-#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/stk8321/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/stk8321/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/stk8321/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/stk8321/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += stk8321.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/stk8321/stk8321.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/stk8321/stk8321.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/stk8321/stk8321.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/stk8321/stk8321.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,513 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/version.h>
+
+// Backport
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+const struct i2c_device_id *i2c_client_get_device_id(const struct i2c_client *client)
+{
+	const struct i2c_driver *drv = to_i2c_driver(client->dev.driver);
+
+	return i2c_match_id(drv->id_table, client);
+}
+#endif
+
+#define STK8321_DRIVER_NAME "stk8321"
+
+#define STK8321_REG_CHIP_ID		0x00
+#define STK8321_REG_XOUT1		0x02
+#define STK8321_REG_XOUT2		0x03
+#define STK8321_REG_YOUT1		0x04
+#define STK8321_REG_YOUT2		0x05
+#define STK8321_REG_ZOUT1		0x06
+#define STK8321_REG_ZOUT2		0x07
+#define STK8321_REG_RANGESEL		0x0f
+#define STK8321_REG_BWSEL		0x10
+#define STK8321_REG_POWMODE		0x11
+#define STK8321_REG_DATASETUP		0x13
+#define STK8321_REG_SWRST		0x14
+
+#define STK8321_DATA_FILTER_MASK	0x80
+#define STK8321_DATA_PROTECT_MASK	0x40
+
+enum rangesel {
+	STK8321_RANGESEL_2G = 0x03,
+	STK8321_RANGESEL_4G = 0x05,
+	STK8321_RANGESEL_8G = 0x08,
+};
+
+enum powmode {
+	STK8321_POWMODE_NORMAL		= 0x00,
+	STK8321_POWMODE_SUSPEND		= 0x80,
+	STK8321_POWMODE_LOWPOWER	= 0x40,
+};
+
+enum bandwidth {
+	STK8321_BW_HZ_7_81	= 0x08,
+	STK8321_BW_HZ_15_63 	= 0x09,
+	STK8321_BW_HZ_31_25 	= 0x0a,
+	STK8321_BW_HZ_62_5 	= 0x0b,
+	STK8321_BW_HZ_125 	= 0x0c,
+	STK8321_BW_HZ_250 	= 0x0d,
+	STK8321_BW_HZ_500 	= 0x0e,
+	STK8321_BW_HZ_1000 	= 0x0f,
+};
+
+static const struct {
+	int val;
+	int val2;
+	u8 reg_bits;
+} stk8321_samp_freq_table[] = {
+	{ 7, 810000, STK8321_BW_HZ_7_81 },
+	{ 15, 630000, STK8321_BW_HZ_15_63 },
+	{ 31, 250000, STK8321_BW_HZ_31_25 },
+	{ 62, 500000, STK8321_BW_HZ_62_5 },
+	{ 125, 0, STK8321_BW_HZ_125 },
+	{ 250, 0, STK8321_BW_HZ_250 },
+	{ 500, 0, STK8321_BW_HZ_500 },
+	{ 1000, 0, STK8321_BW_HZ_1000 },
+};
+
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
+	"7.810000 15.630000 31.250000 62.500000 125 250 500 1000");
+
+static struct attribute *stk8321_accel_attributes[] = {
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group stk8321_accel_attrs_group = {
+	.attrs = stk8321_accel_attributes,
+};
+
+struct stk8321_data {
+	struct i2c_client *client;
+	struct i2c_client *second_client;
+	struct iio_mount_matrix orientation;
+	struct mutex lock;
+	int samp_freq;
+};
+
+static const struct iio_mount_matrix iio_mount_zeromatrix = {
+	.rotation = {
+		"0", "0", "0",
+		"0", "0", "0",
+		"0", "0", "0"
+	}
+};
+
+static int stk8321_read_axis(struct i2c_client *client, u8 reg1, u8 reg2)
+{
+	int low_byte, high_byte, result;
+	low_byte = i2c_smbus_read_byte_data(client, reg1);
+	if (low_byte < 0)
+		return low_byte;
+	high_byte = i2c_smbus_read_byte_data(client, reg2);
+	if (high_byte < 0)
+		return high_byte;
+
+	result = (high_byte << 4) | (low_byte >> 4);
+	return result;
+}
+
+static int stk8321_read_x(struct i2c_client *client)
+{
+	return stk8321_read_axis(client, STK8321_REG_XOUT1, STK8321_REG_XOUT2);
+}
+
+static int stk8321_read_y(struct i2c_client *client)
+{
+	return stk8321_read_axis(client, STK8321_REG_YOUT1, STK8321_REG_YOUT2);
+}
+
+static int stk8321_read_z(struct i2c_client *client)
+{
+	return stk8321_read_axis(client, STK8321_REG_ZOUT1, STK8321_REG_ZOUT2);
+}
+
+static int stk8321_set_range(struct i2c_client *client, enum rangesel range)
+{
+	return i2c_smbus_write_byte_data(client, STK8321_REG_RANGESEL, range);
+}
+
+static int stk8321_set_power_mode(struct i2c_client *client, enum powmode mode)
+{
+	return i2c_smbus_write_byte_data(client, STK8321_REG_POWMODE, mode);
+}
+
+static int stk8321_set_bandwidth(struct i2c_client *client, enum bandwidth bw)
+{
+	return i2c_smbus_write_byte_data(client, STK8321_REG_BWSEL, bw);
+}
+
+static const struct iio_mount_matrix *
+stk8321_accel_get_mount_matrix(const struct iio_dev *indio_dev,
+			       const struct iio_chan_spec *chan)
+{
+	struct stk8321_data *data = iio_priv(indio_dev);
+	return &data->orientation;
+}
+
+static const struct iio_chan_spec_ext_info stk8321_ext_info[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, stk8321_accel_get_mount_matrix),
+	{ }
+};
+
+#define STK8321_ACCEL_CHANNEL(index, axis) {				\
+	.type = IIO_ACCEL,						\
+	.address = index,						\
+	.modified = 1,							\
+	.channel2 = IIO_MOD_##axis,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),			\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+	.scan_type = {							\
+		.realbits = 12,						\
+	},								\
+	.ext_info = stk8321_ext_info,					\
+}
+
+static const struct iio_chan_spec stk8321_channels[] = {
+	STK8321_ACCEL_CHANNEL(0, X),
+	STK8321_ACCEL_CHANNEL(1, Y),
+	STK8321_ACCEL_CHANNEL(2, Z),
+};
+
+static int stk8321_read_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int *val, int *val2, long mask)
+{
+	struct stk8321_data *data = iio_priv(indio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		switch (chan->address) {
+		case 0:
+			mutex_lock(&data->lock);
+			ret = stk8321_read_x(data->client);
+			mutex_unlock(&data->lock);
+			break;
+		case 1:
+			mutex_lock(&data->lock);
+			ret = stk8321_read_y(data->client);
+			mutex_unlock(&data->lock);
+			break;
+		case 2:
+			mutex_lock(&data->lock);
+			ret = stk8321_read_z(data->client);
+			mutex_unlock(&data->lock);
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (ret < 0)
+			return ret;
+
+		*val = sign_extend32(ret, chan->scan_type.realbits - 1);
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = stk8321_samp_freq_table[data->samp_freq].val;
+		*val2 = stk8321_samp_freq_table[data->samp_freq].val2;
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stk8321_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val, int val2, long mask)
+{
+	struct stk8321_data *data = iio_priv(indio_dev);
+	int i, ret, matching_index;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		matching_index = -1;
+		for (i = 0; i < ARRAY_SIZE(stk8321_samp_freq_table); ++i) {
+			if (val == stk8321_samp_freq_table[i].val &&
+			    val2 == stk8321_samp_freq_table[i].val2) {
+				matching_index = i;
+			}
+		}
+		if (matching_index < 0)
+			return -EINVAL;
+
+		mutex_lock(&data->lock);
+		data->samp_freq = matching_index;
+		stk8321_set_power_mode(data->client, STK8321_POWMODE_SUSPEND);
+		ret = stk8321_set_bandwidth(
+			data->client,
+			stk8321_samp_freq_table[data->samp_freq].reg_bits);
+		stk8321_set_power_mode(data->client, STK8321_POWMODE_NORMAL);
+		mutex_unlock(&data->lock);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info stk8321_info = {
+	.attrs		= &stk8321_accel_attrs_group,
+	.read_raw	= stk8321_read_raw,
+	.write_raw	= stk8321_write_raw,
+};
+
+#ifdef CONFIG_ACPI
+static int stk8321_apply_acpi_orientation(struct device *dev,
+					  char *method_name,
+					  struct iio_mount_matrix *orientation)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	int i, axis;
+	char *value;
+
+	if (!adev) {
+		pr_debug("no acpi object\n");
+		return -ENODEV;
+	}
+
+	if (!acpi_has_method(adev->handle, method_name)) {
+		pr_debug("acpi object does not have method\n");
+		return -ENODEV;
+	}
+
+	status = acpi_evaluate_object(adev->handle, method_name, NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	obj = (union acpi_object *)buffer.pointer;
+	if (!obj || obj->type != ACPI_TYPE_BUFFER || obj->buffer.length != 3) {
+		pr_err("unexpected object\n");
+		kfree(buffer.pointer);
+		return -EIO;
+	}
+
+	*orientation = iio_mount_zeromatrix;
+
+	// Format is: three values, one for each axis, where each value
+	// map to selected axis (bits 0-1) and possibly flips the sign
+	// (bit 4)
+	for (i = 0; i < 3; ++i) {
+		axis = (obj->buffer.pointer[i] & 0x3) * 3;
+		if (obj->buffer.pointer[i] & (1 << 4))
+			value = "-1";
+		else
+			value = "1";
+
+		orientation->rotation[i + axis] = value;
+	}
+
+	kfree(buffer.pointer);
+
+	return 0;
+}
+#else
+static int stk8321_apply_acpi_orientation(struct device *dev,
+					  const char *method_name,
+					  struct iio_mount_matrix *orientation)
+{
+	return -ENODEV;
+}
+#endif
+
+static int stk8321_apply_orientation(struct iio_dev *indio_dev)
+{
+	struct stk8321_data *data = iio_priv(indio_dev);
+	struct i2c_client *client = data->client;
+	struct device *dev = &client->dev;
+	int ret = 1;
+
+	if (strstr(dev_name(&client->dev), ":00")) {
+		indio_dev->label = "accel-display";
+		ret = stk8321_apply_acpi_orientation(dev, "GETO",
+						     &data->orientation);
+	} else if (strstr(dev_name(&client->dev), ":01")) {
+		// Note: There is a GETR ACPI method that doesn't comply with
+		// the Linux defined orientation for base accelerometers, this
+		// mount matrix need to be configured in 60-sensors.hwdb
+		indio_dev->label = "accel-base";
+	}
+
+	// If no ACPI info is available, default to reading mount matrix from kernel
+	if (ret) {
+		pr_debug("[%02x] no acpi method found\n", client->addr);
+		ret = iio_read_mount_matrix(&client->dev, &data->orientation);
+	}
+
+	return ret;
+}
+
+static void stk8321_dual_probe(struct i2c_client *client)
+{
+	struct stk8321_data *data = iio_priv(i2c_get_clientdata(client));
+	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
+	char dev_name[16];
+	struct i2c_board_info board_info = {
+		.type = "stkh8321",
+		.dev_name = dev_name,
+		.fwnode = client->dev.fwnode,
+	};
+
+	snprintf(dev_name, sizeof(dev_name), "%s:01", acpi_device_hid(adev));
+
+	data->second_client = i2c_acpi_new_device(&client->dev, 1, &board_info);
+}
+
+static void stk8321_dual_remove(struct i2c_client *client)
+{
+	struct stk8321_data *data = iio_priv(i2c_get_clientdata(client));
+	if (!IS_ERR_OR_NULL(data->second_client))
+		i2c_unregister_device(data->second_client);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int stk8321_probe(struct i2c_client *client, const struct i2c_device_id *dummy_id)
+#else
+static int stk8321_probe(struct i2c_client *client)
+#endif
+{
+	int ret;
+	struct iio_dev *indio_dev;
+	struct stk8321_data *data;
+	const struct i2c_device_id *id = i2c_client_get_device_id(client);
+
+	// Initialize iio device
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev) {
+		dev_err(&client->dev, "iio device allocation failed!\n");
+		return -ENOMEM;
+	}
+
+	data = iio_priv(indio_dev);
+	dev_set_drvdata(&client->dev, indio_dev);
+
+	ret = i2c_smbus_write_byte_data(client, STK8321_REG_SWRST, 0x00);
+	if (ret < 0) {
+		pr_err("[%02x] failed to reset sensor\n", client->addr);
+		return ret;
+	}
+
+	mutex_init(&data->lock);
+	data->client = client;
+	data->samp_freq = 0;
+
+	// Setup sensor in suspend mode
+	stk8321_set_power_mode(client, STK8321_POWMODE_SUSPEND);
+	stk8321_set_range(client, STK8321_RANGESEL_2G);
+	stk8321_set_bandwidth(
+		client, stk8321_samp_freq_table[data->samp_freq].reg_bits);
+	i2c_smbus_write_byte_data(client, STK8321_REG_DATASETUP, 0);
+	stk8321_set_power_mode(client, STK8321_POWMODE_NORMAL);
+
+	indio_dev->name = "stk8321";
+	indio_dev->info = &stk8321_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = stk8321_channels;
+	indio_dev->num_channels = ARRAY_SIZE(stk8321_channels);
+
+	ret = stk8321_apply_orientation(indio_dev);
+	if (ret)
+		return ret;
+
+	if (!id && has_acpi_companion(&client->dev))
+		stk8321_dual_probe(client);
+
+	return devm_iio_device_register(&client->dev, indio_dev);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
+static int stk8321_remove(struct i2c_client *client)
+#else
+static void stk8321_remove(struct i2c_client *client)
+#endif
+{
+	stk8321_dual_remove(client);
+	stk8321_set_power_mode(client, STK8321_POWMODE_SUSPEND);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
+	return 0;
+#endif
+}
+
+static int stk8321_suspend(struct device *dev)
+{
+	struct stk8321_data *data = iio_priv(dev_get_drvdata(dev));
+	struct i2c_client *client = data->client;
+	mutex_lock(&data->lock);
+	stk8321_set_power_mode(client, STK8321_POWMODE_SUSPEND);
+	mutex_unlock(&data->lock);
+	return 0;
+}
+
+static int stk8321_resume(struct device *dev)
+{
+	struct stk8321_data *data = iio_priv(dev_get_drvdata(dev));
+	struct i2c_client *client = data->client;
+	mutex_lock(&data->lock);
+	stk8321_set_power_mode(client, STK8321_POWMODE_NORMAL);
+	mutex_unlock(&data->lock);
+	return 0;
+}
+
+static DEFINE_SIMPLE_DEV_PM_OPS(stk8321_pm_ops, stk8321_suspend,
+				stk8321_resume);
+
+static const struct i2c_device_id stk8321_i2c_id[] = {
+	{ "stk8321", 0 },
+	{ "stkh8321", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, stk8321_i2c_id);
+
+static const struct acpi_device_id stk8321_acpi_match[] = {
+	{ "STKH8321" },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, stk8321_acpi_match);
+
+static struct i2c_driver stk8321_driver = {
+	.driver = {
+		.name = STK8321_DRIVER_NAME,
+		.pm = pm_sleep_ptr(&stk8321_pm_ops),
+		.acpi_match_table = stk8321_acpi_match,
+	},
+	.probe = stk8321_probe,
+	.remove = stk8321_remove,
+	.id_table = stk8321_i2c_id,
+};
+
+module_i2c_driver(stk8321_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("STK8321 3-Axis Accelerometer driver");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += tuxedo_compatibility_check.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,234 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include "tuxedo_compatibility_check.h"
+
+#include <linux/module.h>
+#include <linux/dmi.h>
+#include <asm/cpu_device_id.h>
+#include <linux/mod_devicetable.h>
+#include <asm/intel-family.h>
+#include <linux/version.h>
+
+// Defines that might be missing in older kernel headers
+#define INTEL_FAM6_SAPPHIRERAPIDS_X	0x8F
+#define INTEL_FAM6_ALDERLAKE		0x97
+#define INTEL_FAM6_ALDERLAKE_L		0x9A
+#define INTEL_FAM6_ALDERLAKE_N		0xBE
+
+// This check was not in place before 2023, so we continue to assume
+// compatibility for devices <= Intel Core i 12th Gen and <= AMD Ryzen 5th Gen
+static const struct x86_cpu_id skip_tuxedo_dmi_string_check_match[] = {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 12, 0)
+	X86_MATCH_INTEL_FAM6_MODEL(CORE_YONAH, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(CORE2_MEROM, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(CORE2_MEROM_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(CORE2_PENRYN, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(CORE2_DUNNINGTON, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(NEHALEM, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(NEHALEM_G, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(NEHALEM_EP, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(NEHALEM_EX, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(WESTMERE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(WESTMERE_EP, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(WESTMERE_EX, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(HASWELL, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(HASWELL_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(HASWELL_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(HASWELL_G, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_G, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_NNPI, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(LAKEFIELD, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ROCKETLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_N, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_BONNELL, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_BONNELL_MID, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_MID, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_TABLET, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_D, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_MID, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_NP, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_D, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_L, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL, NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(INTEL, 5, INTEL_FAM5_QUARK_X1000, NULL),
+#else
+	X86_MATCH_VFM(INTEL_CORE_YONAH, NULL),
+	X86_MATCH_VFM(INTEL_CORE2_MEROM, NULL),
+	X86_MATCH_VFM(INTEL_CORE2_MEROM_L, NULL),
+	X86_MATCH_VFM(INTEL_CORE2_PENRYN, NULL),
+	X86_MATCH_VFM(INTEL_CORE2_DUNNINGTON, NULL),
+	X86_MATCH_VFM(INTEL_NEHALEM, NULL),
+	X86_MATCH_VFM(INTEL_NEHALEM_G, NULL),
+	X86_MATCH_VFM(INTEL_NEHALEM_EP, NULL),
+	X86_MATCH_VFM(INTEL_NEHALEM_EX, NULL),
+	X86_MATCH_VFM(INTEL_WESTMERE, NULL),
+	X86_MATCH_VFM(INTEL_WESTMERE_EP, NULL),
+	X86_MATCH_VFM(INTEL_WESTMERE_EX, NULL),
+	X86_MATCH_VFM(INTEL_SANDYBRIDGE, NULL),
+	X86_MATCH_VFM(INTEL_SANDYBRIDGE_X, NULL),
+	X86_MATCH_VFM(INTEL_IVYBRIDGE, NULL),
+	X86_MATCH_VFM(INTEL_IVYBRIDGE_X, NULL),
+	X86_MATCH_VFM(INTEL_HASWELL, NULL),
+	X86_MATCH_VFM(INTEL_HASWELL_X, NULL),
+	X86_MATCH_VFM(INTEL_HASWELL_L, NULL),
+	X86_MATCH_VFM(INTEL_HASWELL_G, NULL),
+	X86_MATCH_VFM(INTEL_BROADWELL, NULL),
+	X86_MATCH_VFM(INTEL_BROADWELL_G, NULL),
+	X86_MATCH_VFM(INTEL_BROADWELL_X, NULL),
+	X86_MATCH_VFM(INTEL_BROADWELL_D, NULL),
+	X86_MATCH_VFM(INTEL_SKYLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_SKYLAKE, NULL),
+	X86_MATCH_VFM(INTEL_SKYLAKE_X, NULL),
+	X86_MATCH_VFM(INTEL_KABYLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_KABYLAKE, NULL),
+	X86_MATCH_VFM(INTEL_COMETLAKE, NULL),
+	X86_MATCH_VFM(INTEL_COMETLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_CANNONLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_ICELAKE_X, NULL),
+	X86_MATCH_VFM(INTEL_ICELAKE_D, NULL),
+	X86_MATCH_VFM(INTEL_ICELAKE, NULL),
+	X86_MATCH_VFM(INTEL_ICELAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_ICELAKE_NNPI, NULL),
+	X86_MATCH_VFM(INTEL_LAKEFIELD, NULL),
+	X86_MATCH_VFM(INTEL_ROCKETLAKE, NULL),
+	X86_MATCH_VFM(INTEL_TIGERLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_TIGERLAKE, NULL),
+	X86_MATCH_VFM(INTEL_SAPPHIRERAPIDS_X, NULL),
+	X86_MATCH_VFM(INTEL_ALDERLAKE, NULL),
+	X86_MATCH_VFM(INTEL_ALDERLAKE_L, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_GRACEMONT, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_BONNELL, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_BONNELL_MID, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SALTWELL, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SALTWELL_MID, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SALTWELL_TABLET, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SILVERMONT, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SILVERMONT_D, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_SILVERMONT_MID, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_AIRMONT, NULL),
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 15, 0)
+	X86_MATCH_VFM(INTEL_ATOM_AIRMONT_MID, NULL),
+#else
+	X86_MATCH_VFM(INTEL_ATOM_SILVERMONT_MID2, NULL),
+#endif
+	X86_MATCH_VFM(INTEL_ATOM_AIRMONT_NP, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_GOLDMONT, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_GOLDMONT_D, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_GOLDMONT_PLUS, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_TREMONT_D, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_TREMONT, NULL),
+	X86_MATCH_VFM(INTEL_ATOM_TREMONT_L, NULL),
+	X86_MATCH_VFM(INTEL_XEON_PHI_KNL, NULL),
+	X86_MATCH_VFM(INTEL_XEON_PHI_KNM, NULL),
+	X86_MATCH_VFM(INTEL_QUARK_X1000, NULL),
+#endif
+	X86_MATCH_VENDOR_FAM(AMD, 5, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 6, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 15, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 16, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 17, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 18, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 19, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 20, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 21, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 22, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 23, NULL),
+	X86_MATCH_VENDOR_FAM(AMD, 24, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x01, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x08, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x21, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x40, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x44, NULL),
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 0x50, NULL),
+	{ }
+};
+
+// Placeholder for potential future exemptions
+static const struct x86_cpu_id force_tuxedo_dmi_string_check_match[] = {
+	{ }
+};
+
+// Going forward we only run the drivers on in house tested devices
+static const struct dmi_system_id tuxedo_dmi_string_match[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "TUXEDO"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_CHASSIS_VENDOR, "TUXEDO"),
+		},
+	},
+	{ }
+};
+
+bool tuxedo_is_compatible(void) {
+	if (dmi_check_system(tuxedo_dmi_string_match)
+	    || (x86_match_cpu(skip_tuxedo_dmi_string_check_match)
+	    && !x86_match_cpu(force_tuxedo_dmi_string_check_match))) {
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(tuxedo_is_compatible);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Provide check for other modules if driver package is known compatible");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_compatibility_check/tuxedo_compatibility_check.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_COMPATIBILITY_CHECK_H
+#define TUXEDO_COMPATIBILITY_CHECK_H
+
+#include <linux/kernel.h>
+
+bool tuxedo_is_compatible(void);
+
+#endif // TUXEDO_COMPATIBILITY_CHECK_H
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m += tuxedo_io.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,1016 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2019-2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/dmi.h>
+#include "../clevo_interfaces.h"
+#include "../uniwill_interfaces.h"
+#include "tuxedo_io_ioctl.h"
+
+MODULE_DESCRIPTION("Hardware interface for TUXEDO laptops");
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_VERSION("0.3.9");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS_CLEVO_INTERFACES();
+MODULE_ALIAS("wmi:" CLEVO_WMI_METHOD_GUID);
+MODULE_ALIAS("wmi:" UNIWILL_WMI_MGMT_GUID_BA);
+MODULE_ALIAS("wmi:" UNIWILL_WMI_MGMT_GUID_BB);
+MODULE_ALIAS("wmi:" UNIWILL_WMI_MGMT_GUID_BC);
+
+#define NB01_FAN_SPEED_MAX 0xff
+#define NB02_FAN_SPEED_MAX 0xc8
+#define FAN_ON_MIN_SPEED_PERCENT 25
+
+// Initialized in module init, global for ioctl interface
+static u32 id_check_clevo;
+static u32 id_check_uniwill;
+
+static struct uniwill_device_features_t *uw_feats;
+
+enum uw_perf_profiles_v1 {
+	PROFILE_POWERSAVE = 1,
+	PROFILE_ENTHUSIAST = 2,
+	PROFILE_OVERBOOST = 3,
+};
+
+static int set_full_fan_mode(bool enable);
+static int uw_init_fan(void);
+static u32 uw_set_fan(u32 fan_index, u8 fan_speed);
+static u32 uw_set_fan_auto(void);
+static int uw_get_tdp_min(u8 tdp_index);
+static int uw_get_tdp_max(u8 tdp_index);
+static int uw_get_tdp(u8 tdp_index);
+static int uw_set_tdp(u8 tdp_index, int tdp_value);
+static u32 uw_set_performance_profile_v1(enum uw_perf_profiles_v1 profile);
+
+/**
+ * strstr version of dmi_match
+ */
+static bool __attribute__ ((unused)) dmi_string_in(enum dmi_field f, const char *str)
+{
+	const char *info = dmi_get_system_info(f);
+
+	if (info == NULL || str == NULL)
+		return info == str;
+
+	return strstr(info, str) != NULL;
+}
+
+static u32 clevo_identify(void)
+{
+	return clevo_get_active_interface_id(NULL) == 0 ? 1 : 0;
+}
+
+/*
+ * TDP boundary definitions per device
+ */
+static int tdp_min_ph4tux[] = { 0x05, 0x05, 0x00 };
+static int tdp_max_ph4tux[] = { 0x26, 0x26, 0x00 };
+
+static int tdp_min_ph4trx[] = { 0x05, 0x05, 0x00 };
+static int tdp_max_ph4trx[] = { 0x32, 0x32, 0x00 };
+
+static int tdp_min_ph4tqx[] = { 0x05, 0x05, 0x00 };
+static int tdp_max_ph4tqx[] = { 0x32, 0x32, 0x00 };
+
+static int tdp_min_phxaxx_mk1[] = { 0x05, 0x05, 0x00 };
+static int tdp_max_phxaxx_mk1[] = { 0x32, 0x3c, 0x00 };
+
+static int tdp_min_phxaxx_mk2[] = { 0x05, 0x05, 0x00 };
+static int tdp_max_phxaxx_mk2[] = { 0x37, 0x64, 0x00 };
+
+static int tdp_min_phxpxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_phxpxx[] = { 0x2d, 0x3c, 0x6e };
+
+static int tdp_min_pfxluxg[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_pfxluxg[] = { 0x23, 0x23, 0x28 };
+
+static int tdp_min_gmxngxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxngxx[] = { 0x50, 0x50, 0x5f };
+
+static int tdp_min_gmxmgxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxmgxx[] = { 0x78, 0x78, 0xc8 };
+
+static int tdp_min_gmxtgxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxtgxx[] = { 0x78, 0x78, 0xc8 };
+
+static int tdp_min_gmxzgxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxzgxx[] = { 0x50, 0x50, 0x5f };
+
+static int tdp_min_gmxagxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxagxx[] = { 0x78, 0x78, 0xd7 };
+
+static int tdp_min_gmxrgxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxrgxx[] = { 0x64, 0x64, 0x6e };
+
+static int tdp_min_gmxpxxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxpxxx[] = { 0x82, 0x82, 0xc8 };
+
+static int tdp_min_gmxxgxx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxxgxx[] = { 0x50, 0x50, 0x64 };
+
+static int tdp_min_gmxixxb_mb1[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxixxb_mb1[] = { 0xcd, 0xcd, 0x190 };
+
+static int tdp_min_gmxixxb_mb2[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxixxb_mb2[] = { 0xa0, 0xa0, 0xfa };
+
+static int tdp_min_gmxixxn[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxixxn[] = { 0xa0, 0xa0, 0xfa };
+
+static int tdp_min_gmxixxa[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxixxa[] = { 0x8c, 0x8c, 0xc8 };
+
+static int tdp_min_gmxhgxa[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_gmxhgxa[] = { 0x5a, 0x5a, 0x64 };
+
+static int tdp_min_x6ar5xx[] = { 0x05, 0x05, 0x05 };
+static int tdp_max_x6ar5xx[] = { 0xd2, 0xd2, 0x1a4 };
+
+// Actual min TDP from NB02 CC is 10 W, but 25 W was suggested after testing.
+static int tdp_min_x6fr5xx[] = { 0x19, 0x19, 0x19 };
+static int tdp_max_x6fr5xx[] = { 0xa2, 0xa2, 0xc3 };
+
+static int tdp_min_xxxx45xs[] = { 0x0a, 0x0a, 0x0a };
+static int tdp_max_xxxx45xs[] = { 0x64, 0x64, 0x69 };
+
+static int *tdp_min_defs = NULL;
+static int *tdp_max_defs = NULL;
+
+static void uw_id_tdp(void)
+{
+	if (uw_feats->model == UW_MODEL_PH4TUX) {
+		tdp_min_defs = tdp_min_ph4tux;
+		tdp_max_defs = tdp_max_ph4tux;
+	} else if (uw_feats->model == UW_MODEL_PH4TRX) {
+		tdp_min_defs = tdp_min_ph4trx;
+		tdp_max_defs = tdp_max_ph4trx;
+	} else if (uw_feats->model == UW_MODEL_PH4TQF) {
+		tdp_min_defs = tdp_min_ph4tqx;
+		tdp_max_defs = tdp_max_ph4tqx;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+	} else if (dmi_match(DMI_PRODUCT_SKU, "IBP1XI07MK1")) {
+		tdp_min_defs = tdp_min_phxaxx_mk1;
+		tdp_max_defs = tdp_max_phxaxx_mk1;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "IBP1XI07MK2")) {
+		tdp_min_defs = tdp_min_phxaxx_mk2;
+		tdp_max_defs = tdp_max_phxaxx_mk2;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "IBP1XI08MK1") ||
+		   dmi_match(DMI_PRODUCT_SKU, "IBP1XI08MK2") ||
+		   dmi_match(DMI_PRODUCT_SKU, "IBP14I08MK2") ||
+		   dmi_match(DMI_PRODUCT_SKU, "IBP16I08MK2") ||
+		   dmi_match(DMI_PRODUCT_SKU, "OMNIA08IMK2")) {
+		tdp_min_defs = tdp_min_phxpxx;
+		tdp_max_defs = tdp_max_phxpxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "PULSE1502")) {
+		tdp_min_defs = tdp_min_pfxluxg;
+		tdp_max_defs = tdp_max_pfxluxg;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "POLARIS1XA02")) {
+		tdp_min_defs = tdp_min_gmxngxx;
+		tdp_max_defs = tdp_max_gmxngxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "POLARIS1XI02")) {
+		tdp_min_defs = tdp_min_gmxmgxx;
+		tdp_max_defs = tdp_max_gmxmgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "POLARIS1XI03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI03")) {
+		tdp_min_defs = tdp_min_gmxtgxx;
+		tdp_max_defs = tdp_max_gmxtgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "POLARIS1XA03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XA03")) {
+		tdp_min_defs = tdp_min_gmxzgxx;
+		tdp_max_defs = tdp_max_gmxzgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI04")) {
+		tdp_min_defs = tdp_min_gmxagxx;
+		tdp_max_defs = tdp_max_gmxagxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STEPOL1XA04")) {
+		tdp_min_defs = tdp_min_gmxrgxx;
+		tdp_max_defs = tdp_max_gmxrgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI05")) {
+		tdp_min_defs = tdp_min_gmxpxxx;
+		tdp_max_defs = tdp_max_gmxpxxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "POLARIS1XA05")) {
+		tdp_min_defs = tdp_min_gmxxgxx;
+		tdp_max_defs = tdp_max_gmxxgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XA05")) {
+		tdp_min_defs = tdp_min_gmxxgxx;
+		tdp_max_defs = tdp_max_gmxxgxx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I06") &&
+		   dmi_match(DMI_BOARD_NAME, "GM6IXxB_MB1")) {
+		tdp_min_defs = tdp_min_gmxixxb_mb1;
+		tdp_max_defs = tdp_max_gmxixxb_mb1;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I06") &&
+		   dmi_match(DMI_BOARD_NAME, "GM6IXxB_MB2")) {
+		tdp_min_defs = tdp_min_gmxixxb_mb2;
+		tdp_max_defs = tdp_max_gmxixxb_mb2;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS17I06")) {
+		tdp_min_defs = tdp_min_gmxixxn;
+		tdp_max_defs = tdp_max_gmxixxn;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLSL15I06")) {
+		tdp_min_defs = tdp_min_gmxixxa;
+		tdp_max_defs = tdp_max_gmxixxa;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLSL15A06")) {
+		tdp_min_defs = tdp_min_gmxhgxa;
+		tdp_max_defs = tdp_max_gmxhgxa;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I07")) {
+		tdp_min_defs = tdp_min_x6ar5xx;
+		tdp_max_defs = tdp_max_x6ar5xx;
+	} else if (dmi_match(DMI_PRODUCT_SKU, "STELLARIS16A07")) {
+		tdp_min_defs = tdp_min_x6fr5xx;
+		tdp_max_defs = tdp_max_x6fr5xx;
+	} else if (dmi_match(DMI_BOARD_NAME, "X5KK45xS_X5SP45xS")) {
+		tdp_min_defs = tdp_min_xxxx45xs;
+		tdp_max_defs = tdp_max_xxxx45xs;
+#endif
+	} else {
+		tdp_min_defs = NULL;
+		tdp_max_defs = NULL;
+	}
+}
+
+static u32 uniwill_identify(void)
+{
+	u32 result = uniwill_get_active_interface_id(NULL) == 0 ? 1 : 0;
+	if (result) {
+		uw_feats = uniwill_get_device_features();
+		uw_id_tdp();
+	}
+	return result;
+}
+
+/*static int fop_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fop_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}*/
+
+static long clevo_ioctl_interface(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	u32 result = 0, status;
+	u32 copy_result;
+	u32 argument = (u32) arg;
+	int i;
+
+	u32 clevo_arg;
+
+	const char str_no_if[] = "";
+	char *str_clevo_if;
+
+	switch (cmd) {
+		case R_CL_HW_IF_STR:
+			if (clevo_get_active_interface_id(&str_clevo_if) == 0) {
+				copy_result = copy_to_user((char *) arg, str_clevo_if, strlen(str_clevo_if) + 1);
+			} else {
+				copy_result = copy_to_user((char *) arg, str_no_if, strlen(str_no_if) + 1);
+			}
+			break;
+		case R_CL_FANINFO1:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_FANINFO1, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+		case R_CL_FANINFO2:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_FANINFO2, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+		case R_CL_FANINFO3:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_FANINFO3, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+		/*case R_CL_FANINFO4:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_FANINFO4, 0);
+			copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;*/
+		case R_CL_WEBCAM_SW:
+			if (dmi_match(DMI_PRODUCT_SKU, "AURA14GEN3") ||
+			    dmi_match(DMI_PRODUCT_SKU, "AURA15GEN3") ||
+			    dmi_match(DMI_PRODUCT_SKU, "AURA14GEN4 / AURA15GEN4"))
+				return -ENODEV;
+			status = clevo_evaluate_method(CLEVO_CMD_GET_WEBCAM_SW, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+		case R_CL_FLIGHTMODE_SW:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_FLIGHTMODE_SW, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+		case R_CL_TOUCHPAD_SW:
+			status = clevo_evaluate_method(CLEVO_CMD_GET_TOUCHPAD_SW, 0, &result);
+			copy_result = copy_to_user((int32_t *) arg, &result, sizeof(result));
+			break;
+	}
+
+	switch (cmd) {
+		case W_CL_FANSPEED:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+
+			// Don't allow vallues between fan-off and minimum fan-on-speed
+			u8 fanspeeds[3] = { argument & 0xff, argument >> 8 & 0xff, argument >> 16 & 0xff };
+			for (i = 0; i < 3; ++i) {
+				if (fanspeeds[i] < FAN_ON_MIN_SPEED_PERCENT * NB01_FAN_SPEED_MAX / 2 / 100)
+					fanspeeds[i] = 0;
+				else if (fanspeeds[i] < FAN_ON_MIN_SPEED_PERCENT * NB01_FAN_SPEED_MAX / 100)
+					fanspeeds[i] = FAN_ON_MIN_SPEED_PERCENT * NB01_FAN_SPEED_MAX / 100;
+			}
+			argument = fanspeeds[0];
+			argument |= fanspeeds[1] << 8;
+			argument |= fanspeeds[2] << 16;
+
+			clevo_evaluate_method(CLEVO_CMD_SET_FANSPEED_VALUE, argument, &result);
+			// Note: Delay needed to let hardware catch up with the written value.
+			// No known ready flag. If the value is read too soon, the old value
+			// will still be read out.
+			// (Theoretically needed for other methods as well.)
+			// Can it be lower? 50ms is too low
+			msleep(100);
+			break;
+		case W_CL_FANAUTO:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			clevo_evaluate_method(CLEVO_CMD_SET_FANSPEED_AUTO, argument, &result);
+			break;
+		case W_CL_WEBCAM_SW:
+			if (dmi_match(DMI_PRODUCT_SKU, "AURA14GEN3") ||
+			    dmi_match(DMI_PRODUCT_SKU, "AURA15GEN3"))
+				return -ENODEV;
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			status = clevo_evaluate_method(CLEVO_CMD_GET_WEBCAM_SW, 0, &result);
+			// Only set status if it isn't already the right value
+			// (workaround for old and/or buggy WMI interfaces that toggle on write)
+			if ((argument & 0x01) != (result & 0x01)) {
+				clevo_evaluate_method(CLEVO_CMD_SET_WEBCAM_SW, argument, &result);
+			}
+			break;
+		case W_CL_FLIGHTMODE_SW:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			clevo_evaluate_method(CLEVO_CMD_SET_FLIGHTMODE_SW, argument, &result);
+			break;
+		case W_CL_TOUCHPAD_SW:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			clevo_evaluate_method(CLEVO_CMD_SET_TOUCHPAD_SW, argument, &result);
+			break;
+		case W_CL_PERF_PROFILE:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			clevo_arg = (CLEVO_CMD_OPT_SUB_SET_PERF_PROF << 0x18) | (argument & 0xff);
+			clevo_evaluate_method(CLEVO_CMD_OPT, clevo_arg, &result);
+			break;
+	}
+
+	return 0;
+}
+
+static int set_full_fan_mode(bool enable) {
+	u8 mode_data;
+
+	uniwill_read_ec_ram(0x0751, &mode_data);
+
+	if (enable && !(mode_data & 0x40)) {
+		// If not "full fan mode" (i.e. 0x40 bit not set) switch to it (required for old fancontrol)
+		return uniwill_write_ec_ram(0x0751, mode_data | 0x40);
+	}
+	else if (mode_data & 0x40){
+		// If "full fan mode" (i.e. 0x40 bit set) turn it off (required for new fancontrol)
+		return uniwill_write_ec_ram(0x0751, mode_data & ~0x40);
+	}
+
+	return 0;
+}
+
+static bool fans_initialized = false;
+
+static int uw_init_fan(void) {
+	int i, temp_offset;
+
+	u16 addr_use_custom_fan_table_0 = 0x07c5; // use different tables for both fans (0x0f00-0x0f2f and 0x0f30-0x0f5f respectivly)
+	u16 addr_use_custom_fan_table_1 = 0x07c6; // enable 0x0fxx fantables
+	u8 offset_use_custom_fan_table_0 = 7;
+	u8 offset_use_custom_fan_table_1 = 2;
+	u8 value_use_custom_fan_table_0;
+	u8 value_use_custom_fan_table_1;
+	u16 addr_cpu_custom_fan_table_end_temp = 0x0f00;
+	u16 addr_cpu_custom_fan_table_start_temp = 0x0f10;
+	u16 addr_cpu_custom_fan_table_fan_speed = 0x0f20;
+	u16 addr_gpu_custom_fan_table_end_temp = 0x0f30;
+	u16 addr_gpu_custom_fan_table_start_temp = 0x0f40;
+	u16 addr_gpu_custom_fan_table_fan_speed = 0x0f50;
+
+	if (!fans_initialized && uw_feats->uniwill_has_universal_ec_fan_control) {
+		set_full_fan_mode(false);
+
+		uniwill_read_ec_ram(addr_use_custom_fan_table_0, &value_use_custom_fan_table_0);
+		if (!((value_use_custom_fan_table_0 >> offset_use_custom_fan_table_0) & 1)) {
+			uniwill_write_ec_ram_with_retry(addr_use_custom_fan_table_0, value_use_custom_fan_table_0 + (1 << offset_use_custom_fan_table_0), 3);
+		}
+
+		// Setup
+		// - one controllable zone 0-115 deg
+		// - rest 116-117, 117-118 etc single non reachable dummy zones
+		//   with increasing ranges and max fan (same or increasing)
+		uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_end_temp, 115, 3);
+		uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_start_temp, 0, 3);
+		uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_fan_speed, 0x00, 3);
+		uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_end_temp, 120, 3);
+		uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_start_temp, 0, 3);
+		uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_fan_speed, 0x00, 3);
+		temp_offset = 115;
+		for (i = 0x1; i <= 0xf; ++i) {
+			uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_end_temp + i, temp_offset + i + 1, 3);
+			uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_start_temp + i, temp_offset + i, 3);
+			uniwill_write_ec_ram_with_retry(addr_cpu_custom_fan_table_fan_speed + i, 0xc8, 3);
+			uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_end_temp + i, temp_offset + i + 1, 3);
+			uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_start_temp + i, temp_offset + i, 3);
+			uniwill_write_ec_ram_with_retry(addr_gpu_custom_fan_table_fan_speed + i, 0xc8, 3);
+		}
+
+		uniwill_read_ec_ram(addr_use_custom_fan_table_1, &value_use_custom_fan_table_1);
+		if (!((value_use_custom_fan_table_1 >> offset_use_custom_fan_table_1) & 1)) {
+			uniwill_write_ec_ram_with_retry(addr_use_custom_fan_table_1, value_use_custom_fan_table_1 + (1 << offset_use_custom_fan_table_1), 3);
+		}
+	}
+
+	fans_initialized = true;
+
+	return 0;
+}
+
+static int direct_fan_control(u32 fan_index, u8 fan_speed, bool prevent_rampup)
+{
+	int i;
+	u8 mode_data;
+	u16 addr_for_fan;
+	u16 addr_fan0 = 0x1804;
+	u16 addr_fan1 = 0x1809;
+
+	if (fan_index == 0)
+		addr_for_fan = addr_fan0;
+	else if (fan_index == 1)
+		addr_for_fan = addr_fan1;
+	else
+		return -EINVAL;
+
+	if (prevent_rampup) {
+		// Check current mode
+		uniwill_read_ec_ram(0x0751, &mode_data);
+		prevent_rampup = !(mode_data & 0x40);
+	}
+
+	if (prevent_rampup) {
+		// If not "full fan mode" (i.e. 0x40 bit set) switch to it (required for fancontrol)
+		set_full_fan_mode(true);
+		// Attempt to write both fans as quick as possible before complete ramp-up
+		pr_debug("prevent ramp-up start\n");
+		for (i = 0; i < 10; ++i) {
+			uniwill_write_ec_ram(addr_fan0, fan_speed & 0xff);
+			uniwill_write_ec_ram(addr_fan1, fan_speed & 0xff);
+			msleep(10);
+		}
+		pr_debug("prevent ramp-up done\n");
+	} else {
+		// Otherwise just set the chosen fan
+		uniwill_write_ec_ram(addr_for_fan, fan_speed & 0xff);
+	}
+
+	return 0;
+}
+
+static u32 uw_set_fan(u32 fan_index, u8 fan_speed)
+{
+	u16 addr_for_fan;
+
+	u16 addr_cpu_custom_fan_table_fan_speed = 0x0f20;
+	u16 addr_gpu_custom_fan_table_fan_speed = 0x0f50;
+
+	u8 byte_data;
+
+	if (uw_feats->uniwill_has_universal_ec_fan_control) {
+		uniwill_read_ec_ram(0x0751, &byte_data);
+		if (!(byte_data & 0x40)) {
+			uw_init_fan();
+
+			if (fan_index == 0)
+				addr_for_fan = addr_cpu_custom_fan_table_fan_speed;
+			else if (fan_index == 1)
+				addr_for_fan = addr_gpu_custom_fan_table_fan_speed;
+			else
+				return -EINVAL;
+
+			if (fan_speed > NB02_FAN_SPEED_MAX)
+				return -EINVAL;
+
+			// Don't allow vallues between fan-off and minimum fan-on-speed
+			if (fan_speed < FAN_ON_MIN_SPEED_PERCENT * NB02_FAN_SPEED_MAX / 2 / 100)
+				fan_speed = 0;
+			else if (fan_speed < FAN_ON_MIN_SPEED_PERCENT * NB02_FAN_SPEED_MAX / 100)
+				fan_speed = FAN_ON_MIN_SPEED_PERCENT * NB02_FAN_SPEED_MAX / 100;
+
+			if (fan_speed == 0 &&
+			!dmi_match(DMI_BOARD_NAME, "GXxMRXx")) {
+				// Avoid hard coded EC behaviour: Setting fan speed = 0x00 spins the fan up
+				// to 0x3c (30%) for 3 minutes before going to 0x00. Setting fan speed = 1
+				// also causes the fan to stop since on 2020 or later TF devices the
+				// microcontroller in the fan itself is intelligent enough to not try to
+				// start up the motor when the speed is to slow. Older devices don't use
+				// this fan controll anyway, but the else case below.
+				fan_speed = 1;
+			}
+
+			uniwill_write_ec_ram(addr_for_fan, fan_speed & 0xff);
+
+			direct_fan_control(fan_index, fan_speed, false);
+		}
+	}
+	else { // old workaround using full fan mode
+		direct_fan_control(fan_index, fan_speed, true);
+	}
+
+	return 0;
+}
+
+static u32 uw_set_fan_auto(void)
+{
+	u8 mode_data;
+
+	if (uw_feats->uniwill_has_universal_ec_fan_control) {
+		u16 addr_use_custom_fan_table_0 = 0x07c5; // use different tables for both fans (0x0f00-0x0f2f and 0x0f30-0x0f5f respectivly)
+		u16 addr_use_custom_fan_table_1 = 0x07c6; // enable 0x0fxx fantables
+		u8 offset_use_custom_fan_table_0 = 7;
+		u8 offset_use_custom_fan_table_1 = 2;
+		u8 value_use_custom_fan_table_0;
+		u8 value_use_custom_fan_table_1;
+		uniwill_read_ec_ram(addr_use_custom_fan_table_1, &value_use_custom_fan_table_1);
+		if ((value_use_custom_fan_table_1 >> offset_use_custom_fan_table_1) & 1) {
+			uniwill_write_ec_ram_with_retry(addr_use_custom_fan_table_1, value_use_custom_fan_table_1 - (1 << offset_use_custom_fan_table_1), 3);
+		}
+		uniwill_read_ec_ram(addr_use_custom_fan_table_0, &value_use_custom_fan_table_0);
+		if ((value_use_custom_fan_table_0 >> offset_use_custom_fan_table_0) & 1) {
+			uniwill_write_ec_ram_with_retry(addr_use_custom_fan_table_0, value_use_custom_fan_table_0 - (1 << offset_use_custom_fan_table_0), 3);
+		}
+		fans_initialized = false;
+	}
+	else {
+		// Get current mode
+		uniwill_read_ec_ram(0x0751, &mode_data);
+		// Switch off "full fan mode" (i.e. unset 0x40 bit)
+		uniwill_write_ec_ram(0x0751, mode_data & 0xbf);
+	}
+
+	return 0;
+}
+
+static int uw_get_tdp_min(u8 tdp_index)
+{
+	if (tdp_index > 2)
+		return -EINVAL;
+
+	if (tdp_min_defs == NULL)
+		return -ENODEV;
+
+	if (tdp_min_defs[tdp_index] <= 0) {
+		return -ENODEV;
+	}
+
+	return tdp_min_defs[tdp_index];
+}
+
+static int uw_get_tdp_max(u8 tdp_index)
+{
+	if (tdp_index > 2)
+		return -EINVAL;
+
+	if (tdp_max_defs == NULL)
+		return -ENODEV;
+
+	if (tdp_max_defs[tdp_index] <= 0) {
+		return -ENODEV;
+	}
+
+	return tdp_max_defs[tdp_index];
+}
+
+static int uw_get_tdp(u8 tdp_index)
+{
+	u8 tdp_data;
+	int tdp_value;
+	u16 tdp_base_addr = 0x0783;
+	u16 tdp_current_addr = tdp_base_addr + tdp_index;
+	int status;
+
+	// Use min tdp to detect support for chosen tdp parameter
+	int min_tdp_status = uw_get_tdp_min(tdp_index);
+	if (min_tdp_status < 0)
+		return min_tdp_status;
+
+	status = uniwill_read_ec_ram(tdp_current_addr, &tdp_data);
+	if (status < 0)
+		return status;
+
+	if (tdp_index == 2 && uw_feats->uniwill_has_double_pl4)
+		tdp_value = (int)tdp_data * 2;
+	else
+		tdp_value = tdp_data;
+
+	return tdp_value;
+}
+
+static int uw_set_tdp(u8 tdp_index, int tdp_value)
+{
+	int tdp_min, tdp_max;
+	u8 tdp_data;
+	u16 tdp_base_addr = 0x0783;
+	u16 tdp_current_addr = tdp_base_addr + tdp_index;
+
+	if (uw_feats->uniwill_custom_profile_mode_needed) {
+		// Ensure that "enthusiast" profile is chosen when using TDP set
+		// for devices that require this
+		uw_set_performance_profile_v1(PROFILE_ENTHUSIAST);
+	}
+
+	// Use min tdp to detect support for chosen tdp parameter
+	int min_tdp_status = uw_get_tdp_min(tdp_index);
+	if (min_tdp_status < 0)
+		return min_tdp_status;
+
+	tdp_min = uw_get_tdp_min(tdp_index);
+	tdp_max = uw_get_tdp_max(tdp_index);
+	if (tdp_value < tdp_min || tdp_value > tdp_max)
+		return -EINVAL;
+
+	if (tdp_index == 2 && uw_feats->uniwill_has_double_pl4)
+		tdp_data = tdp_value / 2;
+	else
+		tdp_data = tdp_value;
+
+	uniwill_write_ec_ram(tdp_current_addr, tdp_data);
+
+	return 0;
+}
+
+/**
+ * Set profile 1-3 to 0xa0, 0x00 or 0x10 depending on
+ * device support.
+ */
+static u32 uw_set_performance_profile_v1(enum uw_perf_profiles_v1 profile)
+{
+	u8 current_value = 0x00, next_value;
+	u8 clear_bits = 0xa0 | 0x10;
+	u32 result;
+	result = uniwill_read_ec_ram(0x0751, &current_value);
+	if (result >= 0) {
+		next_value = current_value & ~clear_bits;
+		switch (profile) {
+		case 0x01:
+			next_value |= 0xa0;
+			break;
+		case 0x02:
+			next_value |= 0x00;
+			break;
+		case 0x03:
+			next_value |= 0x10;
+			break;
+		default:
+			result = -EINVAL;
+			break;
+		}
+
+		if (result != -EINVAL) {
+			result = uniwill_write_ec_ram(0x0751, next_value);
+		}
+	}
+
+	return result;
+}
+
+static long uniwill_ioctl_interface(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	u32 result = 0;
+	u32 copy_result;
+	u32 argument;
+	u8 byte_data;
+	const char str_no_if[] = "";
+	char *str_uniwill_if;
+
+#ifdef DEBUG
+	union uw_ec_read_return reg_read_return;
+	union uw_ec_write_return reg_write_return;
+	u32 uw_arg[10];
+	u32 uw_result[10];
+	int i;
+	for (i = 0; i < 10; ++i) {
+		uw_result[i] = 0xdeadbeef;
+	}
+#endif
+
+	switch (cmd) {
+		case R_UW_HW_IF_STR:
+			if (uniwill_get_active_interface_id(&str_uniwill_if) == 0) {
+				copy_result = copy_to_user((char *) arg, str_uniwill_if, strlen(str_uniwill_if) + 1);
+			} else {
+				copy_result = copy_to_user((char *) arg, str_no_if, strlen(str_no_if) + 1);
+			}
+			break;
+		case R_UW_MODEL_ID:
+			result = uw_feats->model;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FANSPEED:
+			uniwill_read_ec_ram(0x1804, &byte_data);
+			if (uw_feats->uniwill_has_universal_ec_fan_control && byte_data == 1)
+				byte_data = 0; // 1 is 0 behaviour see: uw_set_fan
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FANSPEED2:
+			uniwill_read_ec_ram(0x1809, &byte_data);
+			if (uw_feats->uniwill_has_universal_ec_fan_control && byte_data == 1)
+				byte_data = 0; // 1 is 0 behaviour see: uw_set_fan
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FAN_TEMP:
+			uniwill_read_ec_ram(0x043e, &byte_data);
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FAN_TEMP2:
+			uniwill_read_ec_ram(0x044f, &byte_data);
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_MODE:
+			uniwill_read_ec_ram(0x0751, &byte_data);
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_MODE_ENABLE:
+			uniwill_read_ec_ram(0x0741, &byte_data);
+			result = byte_data;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FANS_OFF_AVAILABLE:
+			/*result = uw_feats->uniwill_has_universal_ec_fan_control ? 1 : 0;
+			if (result == 1) {
+				result = 0;
+			}
+			else if (result == 0) {
+				result = 1;
+			}*/
+			result = 1;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_FANS_MIN_SPEED:
+			/*result = uw_feats->uniwill_has_universal_ec_fan_control? 1 : 0;
+			if (result == 1) {
+				result = 20;
+			}
+			else if (result == 0) {
+				result = 0;
+			}*/
+			result = FAN_ON_MIN_SPEED_PERCENT;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP0:
+			result = uw_get_tdp(0);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP1:
+			result = uw_get_tdp(1);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP2:
+			result = uw_get_tdp(2);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP0_MIN:
+			result = uw_get_tdp_min(0);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP1_MIN:
+			result = uw_get_tdp_min(1);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP2_MIN:
+			result = uw_get_tdp_min(2);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP0_MAX:
+			result = uw_get_tdp_max(0);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP1_MAX:
+			result = uw_get_tdp_max(1);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_TDP2_MAX:
+			result = uw_get_tdp_max(2);
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+		case R_UW_PROFS_AVAILABLE:
+			result = 0;
+			if (uw_feats->uniwill_profile_v1_two_profs)
+				result = 2;
+			else if (uw_feats->uniwill_profile_v1_three_profs || uw_feats->uniwill_profile_v1_three_profs_leds_only)
+				result = 3;
+			copy_result = copy_to_user((void *) arg, &result, sizeof(result));
+			break;
+#ifdef DEBUG
+		case R_TF_BC:
+			copy_result = copy_from_user(&uw_arg, (void *) arg, sizeof(uw_arg));
+			reg_read_return.dword = 0;
+			result = uniwill_read_ec_ram((uw_arg[1] << 8) | uw_arg[0], &reg_read_return.bytes.data_low);
+			copy_result = copy_to_user((void *) arg, &reg_read_return.dword, sizeof(reg_read_return.dword));
+			// pr_info("R_TF_BC args [%0#2x, %0#2x, %0#2x, %0#2x]\n", uw_arg[0], uw_arg[1], uw_arg[2], uw_arg[3]);
+			/*if (uniwill_ec_direct) {
+				result = uw_ec_read_addr_direct(uw_arg[0], uw_arg[1], &reg_read_return);
+				copy_result = copy_to_user((void *) arg, &reg_read_return.dword, sizeof(reg_read_return.dword));
+			} else {
+				result = uw_wmi_ec_evaluate(uw_arg[0], uw_arg[1], uw_arg[2], uw_arg[3], 1, uw_result);
+				copy_result = copy_to_user((void *) arg, &uw_result, sizeof(uw_result));
+			}*/
+			break;
+#endif
+	}
+
+	switch (cmd) {
+		case W_UW_FANSPEED:
+		case W_UW_FANSPEED2:
+			// Get fan speed argument
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			u8 fan_select = (cmd == W_UW_FANSPEED2);
+			uw_set_fan(fan_select, argument);
+			break;
+		case W_UW_MODE:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uniwill_write_ec_ram(0x0751, argument & 0xff);
+			break;
+		case W_UW_MODE_ENABLE:
+			// Note: Is for the moment set and cleared on init/exit of module (uniwill mode)
+			/*
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uniwill_write_ec_ram(0x0741, argument & 0x01);
+			*/
+			break;
+		case W_UW_FANAUTO:
+			uw_set_fan_auto();
+			break;
+		case W_UW_TDP0:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uw_set_tdp(0, argument);
+			break;
+		case W_UW_TDP1:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uw_set_tdp(1, argument);
+			break;
+		case W_UW_TDP2:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uw_set_tdp(2, argument);
+			break;
+		case W_UW_PERF_PROF:
+			copy_result = copy_from_user(&argument, (int32_t *) arg, sizeof(argument));
+			uw_set_performance_profile_v1(argument);
+			break;
+#ifdef DEBUG
+		case W_TF_BC:
+			reg_write_return.dword = 0;
+			copy_result = copy_from_user(&uw_arg, (void *) arg, sizeof(uw_arg));
+			uniwill_write_ec_ram((uw_arg[1] << 8) | uw_arg[0], uw_arg[2]);
+			copy_result = copy_to_user((void *) arg, &reg_write_return.dword, sizeof(reg_write_return.dword));
+			/*if (uniwill_ec_direct) {
+				result = uw_ec_write_addr_direct(uw_arg[0], uw_arg[1], uw_arg[2], uw_arg[3], &reg_write_return);
+				copy_result = copy_to_user((void *) arg, &reg_write_return.dword, sizeof(reg_write_return.dword));
+			} else {
+				result = uw_wmi_ec_evaluate(uw_arg[0], uw_arg[1], uw_arg[2], uw_arg[3], 0, uw_result);
+				copy_result = copy_to_user((void *) arg, &uw_result, sizeof(uw_result));
+				reg_write_return.dword = uw_result[0];
+			}*/
+			/*pr_info("data_high %0#2x\n", reg_write_return.bytes.data_high);
+			pr_info("data_low %0#2x\n", reg_write_return.bytes.data_low);
+			pr_info("addr_high %0#2x\n", reg_write_return.bytes.addr_high);
+			pr_info("addr_low %0#2x\n", reg_write_return.bytes.addr_low);*/
+			break;
+#endif
+	}
+
+	return 0;
+}
+
+static long fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	u32 status;
+	// u32 result = 0;
+	u32 copy_result;
+
+	const char *module_version = THIS_MODULE->version;
+	switch (cmd) {
+		case R_MOD_VERSION:
+			copy_result = copy_to_user((char *) arg, module_version, strlen(module_version) + 1);
+			break;
+		// Hardware id checks, 1 = positive, 0 = negative
+		case R_HWCHECK_CL:
+			id_check_clevo = clevo_identify();
+			copy_result = copy_to_user((void *) arg, (void *) &id_check_clevo, sizeof(id_check_clevo));
+			break;
+		case R_HWCHECK_UW:
+			id_check_uniwill = uniwill_identify();
+			copy_result = copy_to_user((void *) arg, (void *) &id_check_uniwill, sizeof(id_check_uniwill));
+			break;
+	}
+
+	status = clevo_ioctl_interface(file, cmd, arg);
+	if (status != 0) return status;
+	status = uniwill_ioctl_interface(file, cmd, arg);
+	if (status != 0) return status;
+
+	return 0;
+}
+
+static struct file_operations fops_dev = {
+	.owner              = THIS_MODULE,
+	.unlocked_ioctl     = fop_ioctl
+//	.open               = fop_open,
+//	.release            = fop_release
+};
+
+struct class *tuxedo_io_device_class;
+dev_t tuxedo_io_device_handle;
+
+static struct cdev tuxedo_io_cdev;
+
+static int __init tuxedo_io_init(void)
+{
+	int err;
+
+	// Hardware identification
+	id_check_clevo = clevo_identify();
+	id_check_uniwill = uniwill_identify();
+
+#ifdef DEBUG
+	pr_debug("DEBUG is defined\n");
+
+	if (id_check_clevo == 0 && id_check_uniwill == 0) {
+		pr_debug("No matching hardware found on module load\n");
+	}
+#endif
+
+	err = alloc_chrdev_region(&tuxedo_io_device_handle, 0, 1, "tuxedo_io_cdev");
+	if (err != 0) {
+		pr_err("Failed to allocate chrdev region\n");
+		return err;
+	}
+	cdev_init(&tuxedo_io_cdev, &fops_dev);
+	err = (cdev_add(&tuxedo_io_cdev, tuxedo_io_device_handle, 1));
+	if (err < 0) {
+		pr_err("Failed to add cdev\n");
+		unregister_chrdev_region(tuxedo_io_device_handle, 1);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
+	tuxedo_io_device_class = class_create(THIS_MODULE, "tuxedo_io");
+#else
+	tuxedo_io_device_class = class_create("tuxedo_io");
+#endif
+
+	device_create(tuxedo_io_device_class, NULL, tuxedo_io_device_handle, NULL, "tuxedo_io");
+	pr_debug("Module init successful\n");
+	
+	return 0;
+}
+
+static void __exit tuxedo_io_exit(void)
+{
+	device_destroy(tuxedo_io_device_class, tuxedo_io_device_handle);
+	class_destroy(tuxedo_io_device_class);
+	cdev_del(&tuxedo_io_cdev);
+	unregister_chrdev_region(tuxedo_io_device_handle, 1);
+	pr_debug("Module exit\n");
+}
+
+module_init(tuxedo_io_init);
+module_exit(tuxedo_io_exit);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io_ioctl.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io_ioctl.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_io/tuxedo_io_ioctl.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2019-2022 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_IO_IOCTL_H
+#define TUXEDO_IO_IOCTL_H
+
+#define IOCTL_MAGIC 0xEC
+
+#define MAGIC_READ_CL	IOCTL_MAGIC + 1
+#define MAGIC_WRITE_CL	IOCTL_MAGIC + 2
+
+#define MAGIC_READ_UW	IOCTL_MAGIC + 3
+#define MAGIC_WRITE_UW	IOCTL_MAGIC + 4
+
+#define MOD_API_MIN_VERSION "0.2.6" // IMPORTANT: Needs to be updated when a new ioctl is added
+
+// General
+#define R_MOD_VERSION		_IOR(IOCTL_MAGIC, 0x00, char*)
+
+#define R_HWCHECK_CL		_IOR(IOCTL_MAGIC, 0x05, int32_t*)
+#define R_HWCHECK_UW		_IOR(IOCTL_MAGIC, 0x06, int32_t*)
+
+/**
+ * Clevo interface
+ */
+
+// Read
+#define R_CL_HW_IF_STR		_IOR(MAGIC_READ_CL, 0x00, char*)
+#define R_CL_FANINFO1		_IOR(MAGIC_READ_CL, 0x10, int32_t*)
+#define R_CL_FANINFO2		_IOR(MAGIC_READ_CL, 0x11, int32_t*)
+#define R_CL_FANINFO3		_IOR(MAGIC_READ_CL, 0x12, int32_t*)
+// #define R_FANINFO4		_IOR(MAGIC_READ_CL, 0x04, int32_t*)
+
+#define R_CL_WEBCAM_SW		_IOR(MAGIC_READ_CL, 0x13, int32_t*)
+#define R_CL_FLIGHTMODE_SW	_IOR(MAGIC_READ_CL, 0x14, int32_t*)
+#define R_CL_TOUCHPAD_SW	_IOR(MAGIC_READ_CL, 0x15, int32_t*)
+
+#ifdef DEBUG
+#define R_TF_BC			_IOW(MAGIC_READ_CL, 0x91, uint32_t*)
+#endif
+
+// Write
+#define W_CL_FANSPEED		_IOW(MAGIC_WRITE_CL, 0x10, int32_t*)
+#define W_CL_FANAUTO		_IOW(MAGIC_WRITE_CL, 0x11, int32_t*)
+
+#define W_CL_WEBCAM_SW		_IOW(MAGIC_WRITE_CL, 0x12, int32_t*)
+#define W_CL_FLIGHTMODE_SW	_IOW(MAGIC_WRITE_CL, 0x13, int32_t*)
+#define W_CL_TOUCHPAD_SW	_IOW(MAGIC_WRITE_CL, 0x14, int32_t*)
+#define W_CL_PERF_PROFILE	_IOW(MAGIC_WRITE_CL, 0x15, int32_t*)
+
+#ifdef DEBUG
+#define W_TF_BC			_IOW(MAGIC_WRITE_CL, 0x91, uint32_t*)
+#endif
+
+/**
+ * Uniwill interface
+ */
+
+// Read
+#define R_UW_HW_IF_STR		_IOR(MAGIC_READ_UW, 0x00, char*)
+#define R_UW_MODEL_ID		_IOR(MAGIC_READ_UW, 0x01, int32_t*)
+#define R_UW_FANSPEED		_IOR(MAGIC_READ_UW, 0x10, int32_t*)
+#define R_UW_FANSPEED2		_IOR(MAGIC_READ_UW, 0x11, int32_t*)
+#define R_UW_FAN_TEMP		_IOR(MAGIC_READ_UW, 0x12, int32_t*)
+#define R_UW_FAN_TEMP2		_IOR(MAGIC_READ_UW, 0x13, int32_t*)
+
+#define R_UW_MODE		_IOR(MAGIC_READ_UW, 0x14, int32_t*)
+#define R_UW_MODE_ENABLE	_IOR(MAGIC_READ_UW, 0x15, int32_t*)
+#define R_UW_FANS_OFF_AVAILABLE	_IOR(MAGIC_READ_UW, 0x16, int32_t*)
+#define R_UW_FANS_MIN_SPEED	_IOR(MAGIC_READ_UW, 0x17, int32_t*)
+
+#define R_UW_TDP0		_IOR(MAGIC_READ_UW, 0x18, int32_t*)
+#define R_UW_TDP1		_IOR(MAGIC_READ_UW, 0x19, int32_t*)
+#define R_UW_TDP2		_IOR(MAGIC_READ_UW, 0x1a, int32_t*)
+#define R_UW_TDP0_MIN		_IOR(MAGIC_READ_UW, 0x1b, int32_t*)
+#define R_UW_TDP1_MIN		_IOR(MAGIC_READ_UW, 0x1c, int32_t*)
+#define R_UW_TDP2_MIN		_IOR(MAGIC_READ_UW, 0x1d, int32_t*)
+#define R_UW_TDP0_MAX		_IOR(MAGIC_READ_UW, 0x1e, int32_t*)
+#define R_UW_TDP1_MAX		_IOR(MAGIC_READ_UW, 0x1f, int32_t*)
+#define R_UW_TDP2_MAX		_IOR(MAGIC_READ_UW, 0x20, int32_t*)
+
+#define R_UW_PROFS_AVAILABLE	_IOR(MAGIC_READ_UW, 0x21, int32_t*)
+
+// Write
+#define W_UW_FANSPEED		_IOW(MAGIC_WRITE_UW, 0x10, int32_t*)
+#define W_UW_FANSPEED2		_IOW(MAGIC_WRITE_UW, 0x11, int32_t*)
+#define W_UW_MODE		_IOW(MAGIC_WRITE_UW, 0x12, int32_t*)
+#define W_UW_MODE_ENABLE	_IOW(MAGIC_WRITE_UW, 0x13, int32_t*)
+#define W_UW_FANAUTO		_IO(MAGIC_WRITE_UW, 0x14) // undo all previous calls of W_UW_FANSPEED and W_UW_FANSPEED2
+
+#define W_UW_TDP0		_IOW(MAGIC_WRITE_UW, 0x15, int32_t*)
+#define W_UW_TDP1		_IOW(MAGIC_WRITE_UW, 0x16, int32_t*)
+#define W_UW_TDP2		_IOW(MAGIC_WRITE_UW, 0x17, int32_t*)
+
+#define W_UW_PERF_PROF		_IOW(MAGIC_WRITE_UW, 0x18, int32_t*)
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_keyboard.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_keyboard.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_keyboard.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_keyboard.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2018-2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) "tuxedo_keyboard" ": " fmt
+
+#include "tuxedo_keyboard_common.h"
+#include "clevo_keyboard.h"
+#include "uniwill_keyboard.h"
+#include "tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+#include <linux/mutex.h>
+#include <asm/cpu_device_id.h>
+#include <asm/intel-family.h>
+#include <linux/mod_devicetable.h>
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers keyboard & keyboard backlight Driver");
+MODULE_LICENSE("GPL");
+
+static DEFINE_MUTEX(tuxedo_keyboard_init_driver_lock);
+
+// sysfs device function
+static ssize_t fn_lock_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	// one sysfs device for clevo or uniwill
+	return current_driver->fn_lock_show(dev, attr, buf);
+}
+
+// sysfs device function
+static ssize_t fn_lock_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	return current_driver->fn_lock_store(dev, attr, buf, size);
+}
+
+static DEVICE_ATTR_RW(fn_lock);
+
+// static struct tuxedo_keyboard_driver *driver_list[] = { };
+
+static int tuxedo_input_init(const struct key_entry key_map[])
+{
+	int err;
+
+	tuxedo_input_device = input_allocate_device();
+	if (unlikely(!tuxedo_input_device)) {
+		TUXEDO_ERROR("Error allocating input device\n");
+		return -ENOMEM;
+	}
+
+	tuxedo_input_device->name = "TUXEDO Keyboard";
+	tuxedo_input_device->phys = DRIVER_NAME "/input0";
+	tuxedo_input_device->id.bustype = BUS_HOST;
+	tuxedo_input_device->dev.parent = &tuxedo_platform_device->dev;
+
+	if (key_map != NULL) {
+		err = sparse_keymap_setup(tuxedo_input_device, key_map, NULL);
+		if (err) {
+			TUXEDO_ERROR("Failed to setup sparse keymap\n");
+			goto err_free_input_device;
+		}
+	}
+
+	err = input_register_device(tuxedo_input_device);
+	if (unlikely(err)) {
+		TUXEDO_ERROR("Error registering input device\n");
+		goto err_free_input_device;
+	}
+
+	return 0;
+
+err_free_input_device:
+	input_free_device(tuxedo_input_device);
+
+	return err;
+}
+
+struct platform_device *tuxedo_keyboard_init_driver(struct tuxedo_keyboard_driver *tk_driver)
+{
+	int err;
+	struct platform_device *new_platform_device = NULL;
+
+	TUXEDO_DEBUG("init driver start\n");
+
+	mutex_lock(&tuxedo_keyboard_init_driver_lock);
+
+	if (!IS_ERR_OR_NULL(tuxedo_platform_device)) {
+		// If already initialized, don't proceed
+		TUXEDO_DEBUG("platform device already initialized\n");
+		goto init_driver_exit;
+	} else {
+		// Otherwise, attempt to initialize structures
+		TUXEDO_DEBUG("create platform bundle\n");
+		new_platform_device = platform_create_bundle(
+			tk_driver->platform_driver, tk_driver->probe, NULL, 0, NULL, 0);
+
+		tuxedo_platform_device = new_platform_device;
+
+		if (IS_ERR_OR_NULL(tuxedo_platform_device)) {
+			// Normal case probe failed, no init
+			goto init_driver_exit;
+		}
+
+		TUXEDO_DEBUG("initialize input device\n");
+		if (tk_driver->key_map != NULL) {
+			err = tuxedo_input_init(tk_driver->key_map);
+			if (unlikely(err)) {
+				TUXEDO_ERROR("Could not register input device\n");
+				tk_driver->input_device = NULL;
+			} else {
+				TUXEDO_DEBUG("input device registered\n");
+				tk_driver->input_device = tuxedo_input_device;
+			}
+		}
+
+		// set current driver (clevo or uniwill)
+		current_driver = tk_driver;
+
+		// test for fn lock and create sysfs device
+		if (current_driver->fn_lock_available()) {
+			err = device_create_file(&tuxedo_platform_device->dev, &dev_attr_fn_lock);
+			if(err)
+				pr_err("device_create_file for fn_lock failed\n");
+		} else {
+			pr_debug("FnLock not available\n");
+		}
+	}
+
+init_driver_exit:
+	mutex_unlock(&tuxedo_keyboard_init_driver_lock);
+	return new_platform_device;
+}
+EXPORT_SYMBOL(tuxedo_keyboard_init_driver);
+
+static void __exit tuxedo_input_exit(void)
+{
+	if (unlikely(!tuxedo_input_device)) {
+		return;
+	}
+
+	input_unregister_device(tuxedo_input_device);
+	{
+		tuxedo_input_device = NULL;
+	}
+
+}
+
+void tuxedo_keyboard_remove_driver(struct tuxedo_keyboard_driver *tk_driver)
+{
+	bool specified_driver_differ_from_used =
+		tk_driver != NULL && 
+		(
+			strcmp(
+				tk_driver->platform_driver->driver.name,
+				current_driver->platform_driver->driver.name
+			) != 0
+		);
+
+	if (specified_driver_differ_from_used)
+		return;
+
+	device_remove_file(&tuxedo_platform_device->dev, &dev_attr_fn_lock);
+
+	TUXEDO_DEBUG("tuxedo_input_exit()\n");
+	tuxedo_input_exit();
+	TUXEDO_DEBUG("platform_device_unregister()\n");
+	if (!IS_ERR_OR_NULL(tuxedo_platform_device)) {
+		platform_device_unregister(tuxedo_platform_device);
+		tuxedo_platform_device = NULL;
+	}
+	TUXEDO_DEBUG("platform_driver_unregister()\n");
+	if (!IS_ERR_OR_NULL(current_driver)) {
+		platform_driver_unregister(current_driver->platform_driver);
+		current_driver = NULL;
+	}
+
+}
+EXPORT_SYMBOL(tuxedo_keyboard_remove_driver);
+
+static int __init tuxedo_keyboard_init(void)
+{
+	TUXEDO_INFO("module init\n");
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	return 0;
+}
+
+static void __exit tuxedo_keyboard_exit(void)
+{
+	TUXEDO_INFO("module exit\n");
+
+	if (tuxedo_platform_device != NULL)
+		tuxedo_keyboard_remove_driver(NULL);
+}
+
+module_init(tuxedo_keyboard_init);
+module_exit(tuxedo_keyboard_exit);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_keyboard_common.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_keyboard_common.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_keyboard_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_keyboard_common.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2018-2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_KEYBOARD_COMMON_H
+#define TUXEDO_KEYBOARD_COMMON_H
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+
+/* ::::  Module specific Constants and simple Macros   :::: */
+#define __TUXEDO_PR(lvl, fmt, ...) do { pr_##lvl(fmt, ##__VA_ARGS__); } while (0)
+#define TUXEDO_INFO(fmt, ...) __TUXEDO_PR(info, fmt, ##__VA_ARGS__)
+#define TUXEDO_ERROR(fmt, ...) __TUXEDO_PR(err, fmt, ##__VA_ARGS__)
+#define TUXEDO_DEBUG(fmt, ...) __TUXEDO_PR(debug, "[%s:%u] " fmt, __func__, __LINE__, ##__VA_ARGS__)
+
+#ifndef DRIVER_NAME
+#define DRIVER_NAME "tuxedo_keyboard"
+#endif
+
+struct tuxedo_keyboard_driver {
+	// Platform driver provided by driver
+	struct platform_driver *platform_driver;
+	// Probe method provided by driver
+	int (*probe)(struct platform_device *);
+	// Keymap provided by driver
+	struct key_entry *key_map;
+	// Input device reference filled in on module init after probe success
+	struct input_dev *input_device;
+	// test if acpi or wmi functions for fn lock are exposed and functional
+	bool (*fn_lock_available)(void);
+	// show function for sysfs device fn_lock
+	ssize_t (*fn_lock_show)(struct device *, struct device_attribute *, char *);
+	// store function for sysfs device fn_lock
+	ssize_t (*fn_lock_store)(struct device *, struct device_attribute *, const char *, size_t);
+};
+
+// Global module devices
+static struct platform_device *tuxedo_platform_device = NULL;
+static struct input_dev *tuxedo_input_device = NULL;
+
+// Currently chosen driver
+static struct tuxedo_keyboard_driver *current_driver = NULL;
+
+struct platform_device *tuxedo_keyboard_init_driver(struct tuxedo_keyboard_driver *tk_driver);
+void tuxedo_keyboard_remove_driver(struct tuxedo_keyboard_driver *tk_driver);
+
+/**
+ * Basically a copy of the existing report event but doesn't report unknown events
+ */
+static bool sparse_keymap_report_known_event(struct input_dev *dev, unsigned int code,
+					unsigned int value, bool autorelease)
+{
+	const struct key_entry *ke =
+		sparse_keymap_entry_from_scancode(dev, code);
+
+	if (ke) {
+		sparse_keymap_report_entry(dev, ke, value, autorelease);
+		return true;
+	}
+
+	return false;
+}
+
+struct color_t {
+	u32 code;
+	char* name;
+};
+
+struct color_list_t {
+	uint size;
+	struct color_t colors[];
+};
+
+/**
+ * Commonly used standard colors
+ */
+static struct color_list_t color_list = {
+	.size = 8,
+	.colors = {
+		{ .name = "BLACK",    .code = 0x000000 },  // 0
+		{ .name = "RED",      .code = 0xFF0000 },  // 1
+		{ .name = "GREEN",    .code = 0x00FF00 },  // 2
+		{ .name = "BLUE",     .code = 0x0000FF },  // 3
+		{ .name = "YELLOW",   .code = 0xFFFF00 },  // 4
+		{ .name = "MAGENTA",  .code = 0xFF00FF },  // 5
+		{ .name = "CYAN",     .code = 0x00FFFF },  // 6
+		{ .name = "WHITE",    .code = 0xFFFFFF },  // 7
+	}
+};
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1 @@
+obj-m := tuxedo_nb02_nvidia_power_ctrl.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/tuxedo_nb02_nvidia_power_ctrl.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/tuxedo_nb02_nvidia_power_ctrl.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/tuxedo_nb02_nvidia_power_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb02_nvidia_power_ctrl/tuxedo_nb02_nvidia_power_ctrl.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,379 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+
+#include "../uniwill_interfaces.h"
+
+#define __unused __attribute__((unused))
+
+static ssize_t ctgp_offset_show(struct device * __unused dev,
+				struct device_attribute * __unused attr,
+				char *buf)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_CTGP_OFFSET, &data);
+	if (result < 0)
+		return result;
+
+	return sysfs_emit(buf, "%u\n", data);
+}
+static ssize_t ctgp_offset_store(struct device * __unused dev,
+				 struct device_attribute * __unused attr,
+				 const char *buf, size_t count)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = kstrtou8(buf, 0, &data);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_CTGP_OFFSET, data);
+	if (result < 0)
+		return result;
+
+	return count;
+}
+DEVICE_ATTR_RW(ctgp_offset);
+
+#ifdef DEBUG
+static ssize_t db_offset_show(struct device * __unused dev,
+			      struct device_attribute * __unused attr,
+			      char *buf)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_DB_OFFSET, &data);
+	if (result < 0)
+		return result;
+
+	return sysfs_emit(buf, "%u\n", data);
+}
+static ssize_t db_offset_store(struct device * __unused dev,
+			       struct device_attribute * __unused attr,
+			       const char *buf, size_t count)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = kstrtou8(buf, 0, &data);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_DB_OFFSET, data);
+	if (result < 0)
+		return result;
+
+	return count;
+}
+DEVICE_ATTR_RW(db_offset);
+
+static ssize_t ctgp_enable_show(struct device * __unused dev,
+				struct device_attribute * __unused attr,
+				char *buf)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, &data);
+	if (result < 0)
+		return result;
+
+	return sysfs_emit(buf, "%u\n", data & UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE? 1 : 0);
+}
+static ssize_t ctgp_enable_store(struct device * __unused dev,
+				 struct device_attribute * __unused attr,
+				 const char *buf, size_t count)
+{
+	int result = 0;
+	u8 data = 0;
+	bool enable = false;
+
+	result = kstrtobool(buf, &enable);
+	if (result < 0)
+		return result;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, &data);
+	if (result < 0)
+		return result;
+
+	if (enable) {
+		result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data |
+					      UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE |
+					      UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE);
+		if (result < 0)
+			return result;
+	}
+	else {
+		if (data & UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE) {
+			result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data &
+						      ~UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE);
+			if (result < 0)
+				return result;
+		}
+		else {
+			result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data &
+						      ~(UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE |
+						      UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE));
+			if (result < 0)
+				return result;
+		}
+	}
+
+	return count;
+}
+DEVICE_ATTR_RW(ctgp_enable);
+
+static ssize_t db_enable_show(struct device * __unused dev,
+			      struct device_attribute * __unused attr,
+			      char *buf)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, &data);
+	if (result < 0)
+		return result;
+
+	return sysfs_emit(buf, "%u\n", data & UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE? 1 : 0);
+}
+static ssize_t db_enable_store(struct device * __unused dev,
+			       struct device_attribute * __unused attr,
+			       const char *buf, size_t count)
+{
+	int result = 0;
+	u8 data = 0;
+	bool enable = false;
+
+	result = kstrtobool(buf, &enable);
+	if (result < 0)
+		return result;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, &data);
+	if (result < 0)
+		return result;
+
+	if (enable) {
+		result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data |
+					      UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE |
+					      UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE);
+		if (result < 0)
+			return result;
+	}
+	else {
+		if (data & UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE) {
+			result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data &
+						      ~UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE);
+			if (result < 0)
+				return result;
+		}
+		else {
+			result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE, data &
+						      ~(UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE |
+						      UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE));
+			if (result < 0)
+				return result;
+		}
+	}
+
+	return count;
+}
+DEVICE_ATTR_RW(db_enable);
+
+static ssize_t tpp_offset_show(struct device * __unused dev,
+			       struct device_attribute * __unused attr,
+			       char *buf)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_CTGP_DB_TPP_OFFSET, &data);
+	if (result < 0)
+		return result;
+
+	return sysfs_emit(buf, "%u\n", data);
+}
+static ssize_t tpp_offset_store(struct device * __unused dev,
+				struct device_attribute * __unused attr,
+				const char *buf, size_t count)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = kstrtou8(buf, 0, &data);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_TPP_OFFSET, data);
+	if (result < 0)
+		return result;
+
+	return count;
+}
+DEVICE_ATTR_RW(tpp_offset);
+#endif // DEBUG
+
+static int __init init_db_and_ctgp(void)
+{
+	int result = 0;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_ENABLE,
+				      UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE |
+				      UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE |
+				      UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_CTGP_OFFSET, 0);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_TPP_OFFSET, 255);
+	if (result < 0)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_CTGP_DB_DB_OFFSET, 25);
+	if (result < 0)
+		return result;
+
+	return 0;
+}
+
+static int __init init_sysfs_attrs(struct platform_device *pdev)
+{
+	int result = 0;
+
+	result = sysfs_create_file(&pdev->dev.kobj, &dev_attr_ctgp_offset.attr);
+	if (result)
+		return result;
+
+#ifdef DEBUG
+	result = sysfs_create_file(&pdev->dev.kobj, &dev_attr_db_offset.attr);
+	if (result)
+		return result;
+
+	result = sysfs_create_file(&pdev->dev.kobj, &dev_attr_ctgp_enable.attr);
+	if (result)
+		return result;
+
+	result = sysfs_create_file(&pdev->dev.kobj, &dev_attr_db_enable.attr);
+	if (result)
+		return result;
+
+	result = sysfs_create_file(&pdev->dev.kobj, &dev_attr_tpp_offset.attr);
+	if (result)
+		return result;
+#endif // DEBUG
+
+	return 0;
+}
+
+static int interface_probe_retries = 5;
+
+static int __init tuxedo_nb02_nvidia_power_ctrl_probe(struct platform_device *pdev) {
+	int result = 0;
+	char **uniwill_active_interface = NULL;
+	struct pci_dev *gpu_dev = NULL;
+
+	while (interface_probe_retries) {
+		result = uniwill_get_active_interface_id(uniwill_active_interface);
+		if (result == 0)
+			break;
+		msleep(20);
+		--interface_probe_retries;
+	}
+	if (result < 0)
+		return result;
+
+	// Check for NVIDIA 3000 series or higher
+	result = -ENODEV;
+	while ((gpu_dev = pci_get_device(0x10de, PCI_ANY_ID, gpu_dev)) != NULL) {
+		if (gpu_dev->device >= 0x2200) {
+			result = 0;
+			pci_dev_put(gpu_dev);
+			break;
+		}
+	}
+	if (result < 0)
+		return result;
+
+	result = init_db_and_ctgp();
+	if (result < 0)
+		return result;
+
+	result = init_sysfs_attrs(pdev);
+	if (result < 0)
+		return result;
+
+	return 0;
+}
+
+
+
+// Boilerplate
+
+static struct platform_device *tuxedo_nb02_nvidia_power_ctrl_device;
+static struct platform_driver tuxedo_nb02_nvidia_power_ctrl_driver = {
+	.driver.name = "tuxedo_nvidia_power_ctrl",
+};
+
+static int __init tuxedo_nb02_nvidia_power_ctrl_init(void)
+{
+	struct device *dev = NULL;
+
+	dev = bus_find_device_by_name(&platform_bus_type, NULL,
+				      tuxedo_nb02_nvidia_power_ctrl_driver.driver.name);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+	if (dev != NULL) {
+		put_device(dev);
+		return -EEXIST;
+	}
+
+	tuxedo_nb02_nvidia_power_ctrl_device =
+		platform_create_bundle(&tuxedo_nb02_nvidia_power_ctrl_driver,
+				       tuxedo_nb02_nvidia_power_ctrl_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb02_nvidia_power_ctrl_device))
+		return PTR_ERR(tuxedo_nb02_nvidia_power_ctrl_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb02_nvidia_power_ctrl_exit(void)
+{
+	platform_device_unregister(tuxedo_nb02_nvidia_power_ctrl_device);
+	platform_driver_unregister(&tuxedo_nb02_nvidia_power_ctrl_driver);
+}
+
+module_init(tuxedo_nb02_nvidia_power_ctrl_init);
+module_exit(tuxedo_nb02_nvidia_power_ctrl_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers Dynamic Boost and cTGP control driver for NVIDIA silicon for devices marked with board_vendor NB02");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:tuxedo_keyboard");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,6 @@
+obj-m += tuxedo_nb04_keyboard.o
+obj-m += tuxedo_nb04_wmi_ab.o
+obj-m += tuxedo_nb04_wmi_bs.o
+obj-m += tuxedo_nb04_sensors.o
+obj-m += tuxedo_nb04_power_profiles.o
+obj-m += tuxedo_nb04_kbd_backlight.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_kbd_backlight.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_kbd_backlight.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_kbd_backlight.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_kbd_backlight.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,158 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/version.h>
+#include "tuxedo_nb04_wmi_ab.h"
+
+#define KEYBOARD_MAX_BRIGHTNESS		0x0a
+#define KEYBOARD_DEFAULT_BRIGHTNESS	0x00
+#define KEYBOARD_DEFAULT_COLOR_RED	0xff
+#define KEYBOARD_DEFAULT_COLOR_GREEN	0xff
+#define KEYBOARD_DEFAULT_COLOR_BLUE	0xff
+
+struct driver_data_t {
+	struct led_classdev_mc mcled_cdev_keyboard;
+	struct mc_subled mcled_cdev_subleds_keyboard[3];
+	struct device_keyboard_status_t device_status;
+};
+
+static void leds_set_brightness_mc_keyboard(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+	u8 red = mcled_cdev->subled_info[0].intensity;
+	u8 green = mcled_cdev->subled_info[1].intensity;
+	u8 blue = mcled_cdev->subled_info[2].intensity;
+
+	pr_debug("wmi_set_whole_keyboard(%u, %u, %u, %u)\n", red, green, blue, brightness);
+
+	wmi_set_whole_keyboard(red, green, blue, brightness);
+}
+
+static int init_leds(struct platform_device *pdev)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	int retval;
+
+	driver_data->mcled_cdev_keyboard.led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT;
+	driver_data->mcled_cdev_keyboard.led_cdev.max_brightness = KEYBOARD_MAX_BRIGHTNESS;
+	driver_data->mcled_cdev_keyboard.led_cdev.brightness_set = &leds_set_brightness_mc_keyboard;
+	driver_data->mcled_cdev_keyboard.led_cdev.brightness = KEYBOARD_DEFAULT_BRIGHTNESS;
+	driver_data->mcled_cdev_keyboard.num_colors = 3;
+	driver_data->mcled_cdev_keyboard.subled_info = driver_data->mcled_cdev_subleds_keyboard;
+	driver_data->mcled_cdev_keyboard.subled_info[0].color_index = LED_COLOR_ID_RED;
+	driver_data->mcled_cdev_keyboard.subled_info[0].intensity = KEYBOARD_DEFAULT_COLOR_RED;
+	driver_data->mcled_cdev_keyboard.subled_info[0].channel = 0;
+	driver_data->mcled_cdev_keyboard.subled_info[1].color_index = LED_COLOR_ID_GREEN;
+	driver_data->mcled_cdev_keyboard.subled_info[1].intensity = KEYBOARD_DEFAULT_COLOR_GREEN;
+	driver_data->mcled_cdev_keyboard.subled_info[1].channel = 0;
+	driver_data->mcled_cdev_keyboard.subled_info[2].color_index = LED_COLOR_ID_BLUE;
+	driver_data->mcled_cdev_keyboard.subled_info[2].intensity = KEYBOARD_DEFAULT_COLOR_BLUE;
+	driver_data->mcled_cdev_keyboard.subled_info[2].channel = 0;
+
+	retval = devm_led_classdev_multicolor_register(&pdev->dev, &driver_data->mcled_cdev_keyboard);
+	if (retval)
+		return retval;
+
+	return 0;
+}
+
+static int __init tuxedo_nb04_kbd_backlight_probe(struct platform_device *pdev)
+{
+	int result;
+	struct driver_data_t *driver_data;
+
+	pr_debug("driver probe\n");
+
+	driver_data = devm_kzalloc(&pdev->dev, sizeof(struct driver_data_t), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, driver_data);
+
+	// Note: Read of keyboard status needed for fw init
+	//       before writing can be done
+	result = wmi_update_device_status_keyboard(&driver_data->device_status);
+
+	if (result) {
+		if (result != -ENODEV)
+			pr_err("Failed initial read %d\n", result);
+		return result;
+	}
+
+	result = init_leds(pdev);
+	if (result)
+		return result;
+
+	pr_debug("kbd enabled: %d\n", driver_data->device_status.keyboard_state_enabled);
+	pr_debug("kbd type: %d\n", driver_data->device_status.keyboard_type);
+	pr_debug("kbd sidebar support: %d\n", driver_data->device_status.keyboard_sidebar_support);
+	pr_debug("kbd keyboard matrix: %d\n", driver_data->device_status.keyboard_matrix);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int tuxedo_nb04_kbd_backlight_remove(struct platform_device *pdev)
+#else
+static void tuxedo_nb04_kbd_backlight_remove(struct platform_device *pdev)
+#endif
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	devm_led_classdev_multicolor_unregister(&pdev->dev, &driver_data->mcled_cdev_keyboard);
+	pr_debug("driver remove\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static struct platform_device *tuxedo_nb04_kbd_backlight_device;
+static struct platform_driver tuxedo_nb04_kbd_backlight_driver = {
+	.driver.name = "tuxedo_nb04_kbd_backlight",
+	.remove = tuxedo_nb04_kbd_backlight_remove
+};
+
+static int __init tuxedo_nb04_kbd_backlight_init(void)
+{
+	tuxedo_nb04_kbd_backlight_device =
+		platform_create_bundle(&tuxedo_nb04_kbd_backlight_driver,
+				       tuxedo_nb04_kbd_backlight_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb04_kbd_backlight_device))
+		return PTR_ERR(tuxedo_nb04_kbd_backlight_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb04_kbd_backlight_exit(void)
+{
+	platform_device_unregister(tuxedo_nb04_kbd_backlight_device);
+	platform_driver_unregister(&tuxedo_nb04_kbd_backlight_driver);
+}
+
+module_init(tuxedo_nb04_kbd_backlight_init);
+module_exit(tuxedo_nb04_kbd_backlight_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB04 keyboard backlight");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_keyboard.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_keyboard.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_keyboard.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_keyboard.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,215 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/keyboard.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+
+#define NB04_WMI_EVENT_GUID	"96A786FA-690C-48FB-9EB3-FA9BC3D92300"
+
+#define NB04_WMI_EVENT_MODE_BATTERY			0x01
+#define NB04_WMI_EVENT_MODE_HUMAN			0x02
+#define NB04_WMI_EVENT_MODE_BEAST			0x03
+#define NB04_WMI_EVENT_FULL_FAN				0x04
+#define NB04_WMI_EVENT_NEXT_POWER_MODE			0x05
+#define NB04_WMI_EVENT_TOUCHPAD_TOGGLE			0x06
+#define NB04_WMI_EVENT_MIC_MUTE				0x07
+#define NB04_WMI_EVENT_KBD_BRT_UP			0x08
+#define NB04_WMI_EVENT_KBD_BRT_DOWN			0x09
+#define NB04_WMI_EVENT_KBD_EFFECT_ALWAYS		0x0A
+#define NB04_WMI_EVENT_KBD_EFFECT_BREATHING		0x0B
+#define NB04_WMI_EVENT_KBD_EFFECT_WAVE			0x0C
+#define NB04_WMI_EVENT_KBD_EFFECT_TWINKLE		0x0D
+#define NB04_WMI_EVENT_KBD_EFFECT_COLOR_CYCLE		0x0E
+#define NB04_WMI_EVENT_KBD_EFFECT_REACTIVE		0x0F
+#define NB04_WMI_EVENT_KBD_EFFECT_RIPPLE		0x10
+#define NB04_WMI_EVENT_KBD_EFFECT_SPIRAL_RAINBOW	0x11
+#define NB04_WMI_EVENT_KBD_EFFECT_RAINBOW_RIPPLE	0x12
+
+struct driver_data_t {
+	struct input_dev *input_dev;
+};
+
+static struct key_entry driver_keymap[] = {
+	{ KE_KEY,	NB04_WMI_EVENT_MIC_MUTE,	{ KEY_F20 } },
+	{ KE_KEY,	NB04_WMI_EVENT_TOUCHPAD_TOGGLE,	{ KEY_F21 } },
+	{ KE_KEY,	NB04_WMI_EVENT_KBD_BRT_DOWN,	{ KEY_KBDILLUMDOWN } },
+	{ KE_KEY,	NB04_WMI_EVENT_KBD_BRT_UP,	{ KEY_KBDILLUMUP } },
+	{ KE_END,	0 }
+};
+
+/**
+ * Basically a copy of the existing report event but doesn't report unknown events
+ */
+static bool sparse_keymap_report_known_event(struct input_dev *dev,
+					     unsigned int code,
+					     unsigned int value,
+					     bool autorelease)
+{
+	const struct key_entry *ke =
+		sparse_keymap_entry_from_scancode(dev, code);
+
+	if (ke) {
+		sparse_keymap_report_entry(dev, ke, value, autorelease);
+		return true;
+	}
+
+	return false;
+}
+
+static int input_device_init(struct input_dev **input_dev_pp, const struct key_entry key_map[])
+{
+	struct input_dev *input_dev;
+	int err;
+
+	input_dev = input_allocate_device();
+	if (unlikely(!input_dev)) {
+		pr_err("Error allocating input device\n");
+		return -ENOMEM;
+	}
+
+	input_dev->name = "TUXEDO Keyboard Events";
+	input_dev->phys = "tuxedo-keyboard" "/input0";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->dev.parent = NULL;
+
+	if (key_map != NULL) {
+		err = sparse_keymap_setup(input_dev, key_map, NULL);
+		if (err) {
+			pr_err("Failed to setup sparse keymap\n");
+			goto err_free_input_device;
+		}
+	}
+
+	err = input_register_device(input_dev);
+	if (unlikely(err)) {
+		pr_err("Error registering input device\n");
+		goto err_free_input_device;
+	}
+
+	*input_dev_pp = input_dev;
+
+	return 0;
+
+err_free_input_device:
+	input_free_device(input_dev);
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int tuxedo_nb04_keyboard_probe(struct wmi_device *wdev)
+#else
+static int tuxedo_nb04_keyboard_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	struct driver_data_t *driver_data;
+	int err;
+
+	pr_debug("driver probe\n");
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	if (!wmi_has_guid(NB04_WMI_EVENT_GUID))
+		return -ENODEV;
+
+	driver_data = devm_kzalloc(&wdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&wdev->dev, driver_data);
+
+	err = input_device_init(&driver_data->input_dev, driver_keymap);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int tuxedo_nb04_keyboard_remove(struct wmi_device *wdev)
+#else
+static void tuxedo_nb04_keyboard_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+	input_unregister_device(driver_data->input_dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static void tuxedo_nb04_keyboard_notify(struct wmi_device *wdev, union acpi_object *obj)
+{
+	u8 function_number;
+	u8 event_code;
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+
+	if (obj &&
+	    obj->type == ACPI_TYPE_BUFFER &&
+	    obj->buffer.length >= 2)
+	{
+		function_number = obj->buffer.pointer[0];
+		event_code = obj->buffer.pointer[1];
+		pr_debug("event value: %d (%0#4x)\n",
+			 event_code, event_code);
+		sparse_keymap_report_known_event(driver_data->input_dev,
+						 event_code,
+						 1,
+						 true);
+	} else {
+		pr_debug("expected buffer not found\n");
+	}
+}
+
+static const struct wmi_device_id tuxedo_nb04_keyboard_device_ids[] = {
+	{ .guid_string = NB04_WMI_EVENT_GUID },
+	{ }
+};
+
+static struct wmi_driver tuxedo_nb04_keyboard_driver = {
+	.driver = {
+		.name = "tuxedo_nb04_keyboard",
+		.owner = THIS_MODULE
+	},
+	.id_table = tuxedo_nb04_keyboard_device_ids,
+	.probe = tuxedo_nb04_keyboard_probe,
+	.remove = tuxedo_nb04_keyboard_remove,
+	.notify = tuxedo_nb04_keyboard_notify,
+};
+
+module_wmi_driver(tuxedo_nb04_keyboard_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB04 WMI (keyboard) events");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, tuxedo_nb04_keyboard_device_ids);
+MODULE_ALIAS("wmi:" NB04_WMI_EVENT_GUID);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_power_profiles.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_power_profiles.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_power_profiles.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_power_profiles.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dmi.h>
+#include <linux/version.h>
+#include "tuxedo_nb04_wmi_bs.h"
+
+#define DEFAULT_PROFILE		WMI_SYSTEM_MODE_BEAST
+
+struct driver_data_t {
+	struct platform_device *pdev;
+	u8 current_profile_value;
+};
+
+static int set_system_mode(u8 mode_input)
+{
+	int err, wmi_return;
+	u8 in[BS_INPUT_BUFFER_LENGTH] = { 0 };
+	u8 out[BS_OUTPUT_BUFFER_LENGTH] = { 0 };
+
+	if (mode_input >= WMI_SYSTEM_MODE_END)
+		return -EINVAL;
+
+	in[0] = mode_input;
+
+	err = nb04_wmi_bs_method(0x07, in, out);
+	if (err)
+		return err;
+
+	wmi_return = (out[1] << 8) | out[0];
+	if (wmi_return != WMI_RETURN_STATUS_SUCCESS)
+		return -EIO;
+
+	return 0;
+}
+
+static int write_platform_profile_state(struct platform_device *pdev)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	return set_system_mode(driver_data->current_profile_value);
+}
+
+static ssize_t platform_profile_choices_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buffer);
+
+static ssize_t platform_profile_show(struct device *dev,
+				     struct device_attribute *attr, char *buffer);
+
+static ssize_t platform_profile_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size);
+
+struct platform_profile_attrs_t {
+	struct device_attribute platform_profile_choices;
+	struct device_attribute platform_profile;
+};
+
+struct platform_profile_attrs_t platform_profile_attrs = {
+	.platform_profile_choices = __ATTR(platform_profile_choices, 0444,
+					   platform_profile_choices_show, NULL),
+	.platform_profile = __ATTR(platform_profile, 0644,
+				   platform_profile_show, platform_profile_store)
+};
+
+static struct attribute *platform_profile_attrs_list[] = {
+	&platform_profile_attrs.platform_profile_choices.attr,
+	&platform_profile_attrs.platform_profile.attr,
+	NULL
+};
+
+static struct attribute_group platform_profile_attr_group = {
+	.attrs = platform_profile_attrs_list
+};
+
+struct char_to_value_t {
+	char* descriptor;
+	u64 value;
+};
+
+static struct char_to_value_t platform_profile_options[] = {
+	{ .descriptor = "low-power",	.value = WMI_SYSTEM_MODE_BATTERY },
+	{ .descriptor = "balanced",	.value = WMI_SYSTEM_MODE_HUMAN },
+	{ .descriptor = "performance",	.value = WMI_SYSTEM_MODE_BEAST },
+};
+
+static ssize_t platform_profile_choices_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buffer)
+{
+	int i, n;
+	n = ARRAY_SIZE(platform_profile_options);
+	for (i = 0; i < n; ++i) {
+		sprintf(buffer + strlen(buffer), "%s",
+			platform_profile_options[i].descriptor);
+		if (i < n - 1)
+			sprintf(buffer + strlen(buffer), " ");
+		else
+			sprintf(buffer + strlen(buffer), "\n");
+	}
+
+	return strlen(buffer);
+}
+
+static ssize_t platform_profile_show(struct device *dev,
+				     struct device_attribute *attr, char *buffer)
+{
+	u64 platform_profile_value;
+	int i, err;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+
+	err = 0;
+	platform_profile_value = driver_data->current_profile_value;
+
+	if (err) {
+		pr_err("Error reading power profile");
+		return -EIO;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(platform_profile_options); ++i)
+		if (platform_profile_options[i].value == platform_profile_value) {
+			sprintf(buffer, "%s\n", platform_profile_options[i].descriptor);
+			return strlen(buffer);
+		}
+
+	pr_err("Read platform profile value not matched to a descriptor\n");
+
+	return -EIO;
+}
+
+static ssize_t platform_profile_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	u64 platform_profile_value;
+	int i, err;
+	char *buffer_copy;
+	char *platform_profile_descriptor;
+
+	buffer_copy = kmalloc(size + 1, GFP_KERNEL);
+	strcpy(buffer_copy, buffer);
+	platform_profile_descriptor = strstrip(buffer_copy);
+
+	for (i = 0; i < ARRAY_SIZE(platform_profile_options); ++i)
+		if (strcmp(platform_profile_options[i].descriptor, platform_profile_descriptor) == 0) {
+			platform_profile_value = platform_profile_options[i].value;
+			break;
+		}
+
+	kfree(buffer_copy);
+
+	if (i < ARRAY_SIZE(platform_profile_options)) {
+		// Option found try to set
+		driver_data->current_profile_value = platform_profile_value;
+		err = write_platform_profile_state(pdev);
+		if (err)
+			return err;
+		return size;
+	} else {
+		// Invalid input, not matched to an option
+		return -EINVAL;
+	}
+}
+
+static int __init tuxedo_nb04_power_profiles_probe(struct platform_device *pdev)
+{
+	int err;
+	struct driver_data_t *driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	pr_debug("driver probe\n");
+
+	// Sirius uses other platform control interface
+	if (dmi_match(DMI_SYS_VENDOR, "TUXEDO") &&
+	    dmi_match(DMI_PRODUCT_SKU, "SIRIUS1601"))
+		return -ENODEV;
+
+	dev_set_drvdata(&pdev->dev, driver_data);
+
+	driver_data->pdev = pdev;
+	driver_data->current_profile_value = DEFAULT_PROFILE;
+	write_platform_profile_state(pdev);
+
+	err = sysfs_create_group(&driver_data->pdev->dev.kobj, &platform_profile_attr_group);
+	if (err) {
+		pr_err("create group failed\n");
+		platform_device_unregister(driver_data->pdev);
+		return err;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int tuxedo_nb04_power_profiles_remove(struct platform_device *pdev)
+#else
+static void tuxedo_nb04_power_profiles_remove(struct platform_device *pdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	sysfs_remove_group(&driver_data->pdev->dev.kobj, &platform_profile_attr_group);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static struct platform_device *tuxedo_nb04_power_profiles_device;
+static struct platform_driver tuxedo_nb04_power_profiles_driver = {
+	.driver.name = "tuxedo_platform_profile",
+	.remove = tuxedo_nb04_power_profiles_remove,
+};
+
+static int __init tuxedo_nb04_power_profiles_init(void)
+{
+	if (!nb04_wmi_bs_available())
+		return -ENODEV;
+
+	tuxedo_nb04_power_profiles_device =
+		platform_create_bundle(&tuxedo_nb04_power_profiles_driver,
+				       tuxedo_nb04_power_profiles_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb04_power_profiles_device))
+		return PTR_ERR(tuxedo_nb04_power_profiles_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb04_power_profiles_exit(void)
+{
+	platform_device_unregister(tuxedo_nb04_power_profiles_device);
+	platform_driver_unregister(&tuxedo_nb04_power_profiles_driver);
+}
+
+module_init(tuxedo_nb04_power_profiles_init);
+module_exit(tuxedo_nb04_power_profiles_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers NB04 platform profile driver");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_sensors.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_sensors.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_sensors.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_sensors.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,290 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/hwmon.h>
+#include <linux/platform_device.h>
+#include "tuxedo_nb04_wmi_bs.h"
+
+static int read_cpu_info(u8 *cpu_temp, u8 *cpu_turbo_mode)
+{
+	int err, wmi_return;
+	u8 in[BS_INPUT_BUFFER_LENGTH];
+	u8 out[BS_OUTPUT_BUFFER_LENGTH];
+
+	err = nb04_wmi_bs_method(0x04, in, out);
+	if (err)
+		return err;
+
+	wmi_return = (out[1] << 8) | out[0];
+	if (wmi_return != WMI_RETURN_STATUS_SUCCESS)
+		return -EIO;
+
+	if (cpu_temp)
+		*cpu_temp = out[2];
+	if (cpu_turbo_mode)
+		*cpu_turbo_mode = out[3];
+
+	return 0;
+}
+
+static int read_gpu_info(u8 *gpu_temp, u8 *gpu_turbo_mode, u16 *gpu_max_freq)
+{
+	int err, wmi_return;
+	u8 in[BS_INPUT_BUFFER_LENGTH];
+	u8 out[BS_OUTPUT_BUFFER_LENGTH];
+
+	err = nb04_wmi_bs_method(0x06, in, out);
+	if (err)
+		return err;
+
+	wmi_return = (out[1] << 8) | out[0];
+	if (wmi_return != WMI_RETURN_STATUS_SUCCESS)
+		return -EIO;
+
+	if (gpu_temp)
+		*gpu_temp = out[2];
+	if (gpu_turbo_mode)
+		*gpu_turbo_mode = out[3];
+	if (gpu_max_freq)
+		*gpu_max_freq = (out[5] << 8) | out[4];
+
+	return 0;
+}
+
+static int read_fan_setting(u16 *fan1_cur_rpm, u16 *fan2_cur_rpm,
+			    u16 *fan1_max_rpm, u16 *fan2_max_rpm,
+			    bool *full_fan_status)
+{
+	int err, wmi_return;
+	u8 in[BS_INPUT_BUFFER_LENGTH];
+	u8 out[BS_OUTPUT_BUFFER_LENGTH];
+
+	err = nb04_wmi_bs_method(0x02, in, out);
+	if (err)
+		return err;
+
+	wmi_return = (out[1] << 8) | out[0];
+	if (wmi_return != WMI_RETURN_STATUS_SUCCESS)
+		return -EIO;
+
+	if (fan1_cur_rpm)
+		*fan1_cur_rpm = (out[3] << 8) | out[2];
+	if (fan2_cur_rpm)
+		*fan2_cur_rpm = (out[5] << 8) | out[4];
+	if (fan1_max_rpm)
+		*fan1_max_rpm = (out[7] << 8) | out[6];
+	if (fan2_max_rpm)
+		*fan2_max_rpm = (out[9] << 8) | out[8];
+	if (full_fan_status)
+		*full_fan_status = (out[10] == 0x01);
+
+	return 0;
+}
+
+static const char * const temp_labels[] = {
+	"cpu0",
+	"gpu0"
+};
+
+static const char * const fan_labels[] = {
+	"cpu0",
+	"gpu0"
+};
+
+struct driver_data_t {
+	int fan_cpu_max;
+	int fan_cpu_min;
+	int fan_gpu_max;
+	int fan_gpu_min;
+};
+
+struct driver_data_t driver_data;
+
+static umode_t
+tuxedo_nb04_sensors_is_visible(const void *drvdata, enum hwmon_sensor_types type,
+			       u32 attr, int channel)
+{
+	return 0444;
+}
+
+static int
+tuxedo_nb04_sensors_read(struct device *dev, enum hwmon_sensor_types type,
+			 u32 attr, int channel, long *val)
+{
+	int err;
+	u8 temp_data;
+	u16 rpm_data;
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_temp:
+		if (channel == 0) {
+			err = read_cpu_info(&temp_data, NULL);
+			if (err)
+				return err;
+			*val = temp_data * 1000;
+			return 0;
+		} else if (channel == 1) {
+			err = read_gpu_info(&temp_data, NULL, NULL);
+			if (err)
+				return err;
+			*val = temp_data * 1000;
+			return 0;
+		}
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_min:
+			if (channel == 0) {
+				*val = driver_data->fan_cpu_min;
+				return 0;
+			} else if (channel == 1) {
+				*val = driver_data->fan_gpu_min;
+				return 0;
+			}
+			break;
+		case hwmon_fan_max:
+			if (channel == 0) {
+				*val = driver_data->fan_cpu_max;
+				return 0;
+			} else if (channel == 1) {
+				*val = driver_data->fan_gpu_max;
+				return 0;
+			}
+			break;
+		case hwmon_fan_input:
+			if (channel == 0) {
+				err = read_fan_setting(&rpm_data, NULL, NULL, NULL, NULL);
+				if (err)
+					return err;
+				*val = rpm_data;
+				return 0;
+			} else if (channel == 1) {
+				err = read_fan_setting(NULL, &rpm_data, NULL, NULL, NULL);
+				if (err)
+					return err;
+				*val = rpm_data;
+				return 0;
+			}
+			break;
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int
+tuxedo_nb04_sensors_read_string(struct device *dev, enum hwmon_sensor_types type,
+				u32 attr, int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_temp:
+		*str = temp_labels[channel];
+		return 0;
+	case hwmon_fan:
+		*str = fan_labels[channel];
+		return 0;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops tuxedo_nb04_sensors_ops = {
+	.is_visible = tuxedo_nb04_sensors_is_visible,
+	.read = tuxedo_nb04_sensors_read,
+	.read_string = tuxedo_nb04_sensors_read_string
+};
+
+static const struct hwmon_channel_info *const tuxedo_nb04_sensors_info[] = {
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_LABEL,
+			   HWMON_T_INPUT | HWMON_T_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX),
+	NULL
+};
+
+static const struct hwmon_chip_info tuxedo_nb04_sensors_chip_info = {
+	.ops = &tuxedo_nb04_sensors_ops,
+	.info = tuxedo_nb04_sensors_info
+};
+
+static int __init tuxedo_nb04_sensors_probe(struct platform_device *pdev)
+{
+	struct device *hwmon_dev;
+	int err;
+	u16 fan1_max_rpm, fan2_max_rpm;
+
+	err = read_fan_setting(NULL, NULL, &fan1_max_rpm, &fan2_max_rpm, NULL);
+	if (err)
+		return err;
+
+	driver_data.fan_cpu_max = fan1_max_rpm;
+	driver_data.fan_cpu_min = 0;
+	driver_data.fan_gpu_max = fan2_max_rpm;
+	driver_data.fan_gpu_min = 0;
+
+	hwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,
+							 "tuxedo",
+							 &driver_data,
+							 &tuxedo_nb04_sensors_chip_info,
+							 NULL);
+
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static struct platform_device *tuxedo_nb04_sensors_device;
+static struct platform_driver tuxedo_nb04_sensors_driver = {
+	.driver.name = "tuxedo_nb04_sensors",
+};
+
+static int __init tuxedo_nb04_sensors_init(void)
+{
+	tuxedo_nb04_sensors_device =
+		platform_create_bundle(&tuxedo_nb04_sensors_driver,
+				       tuxedo_nb04_sensors_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb04_sensors_device))
+		return PTR_ERR(tuxedo_nb04_sensors_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb04_sensors_exit(void)
+{
+	platform_device_unregister(tuxedo_nb04_sensors_device);
+	platform_driver_unregister(&tuxedo_nb04_sensors_driver);
+}
+
+module_init(tuxedo_nb04_sensors_init);
+module_exit(tuxedo_nb04_sensors_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers NB04 sensors driver");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include "tuxedo_nb04_wmi_ab.h"
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+
+#define dev_to_wdev(__dev)	container_of(__dev, struct wmi_device, dev)
+
+static DEFINE_MUTEX(nb04_wmi_ab_lock);
+
+static struct wmi_device *__wmi_dev;
+
+#define KEYBOARD_MAX_BRIGHTNESS		0x0a
+#define KEYBOARD_DEFAULT_BRIGHTNESS	0x00
+#define KEYBOARD_DEFAULT_COLOR_RED	0xff
+#define KEYBOARD_DEFAULT_COLOR_GREEN	0xff
+#define KEYBOARD_DEFAULT_COLOR_BLUE	0xff
+
+struct driver_data_t {};
+
+static int
+__nb04_wmi_ab_method_buffer(struct wmi_device *wdev, u32 wmi_method_id,
+			    u8 *in, u8 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)AB_INPUT_BUFFER_LENGTH_NORMAL, in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb04_wmi_ab_lock);
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+	mutex_unlock(&nb04_wmi_ab_lock);
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method %u\n", wmi_method_id);
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_BUFFER) {
+		pr_err("No buffer for method (%u) call\n", wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	if (acpi_object_out->buffer.length != AB_OUTPUT_BUFFER_LENGTH) {
+		pr_err("Unexpected buffer length: %u for method (%u) call\n", 
+		       acpi_object_out->buffer.length, wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	memcpy(out, acpi_object_out->buffer.pointer, AB_OUTPUT_BUFFER_LENGTH);
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+/**
+ * Method interface 8 bytes in 80 bytes out
+ */
+int nb04_wmi_ab_method_buffer(u32 wmi_method_id, u8 *in, u8 *out)
+{
+	if (__wmi_dev)
+		return __nb04_wmi_ab_method_buffer(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(nb04_wmi_ab_method_buffer);
+
+static int
+__nb04_wmi_ab_method_buffer_reduced_output(struct wmi_device *wdev, u32 wmi_method_id,
+					   u8 *in, u8 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)AB_INPUT_BUFFER_LENGTH_NORMAL, in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb04_wmi_ab_lock);
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+	mutex_unlock(&nb04_wmi_ab_lock);
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method %u\n", wmi_method_id);
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_BUFFER) {
+		pr_err("No buffer for method (%u) call\n", wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	if (acpi_object_out->buffer.length != AB_OUTPUT_BUFFER_LENGTH_REDUCED) {
+		pr_err("Unexpected buffer length: %u for method (%u) call\n", 
+		       acpi_object_out->buffer.length, wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	memcpy(out, acpi_object_out->buffer.pointer, AB_OUTPUT_BUFFER_LENGTH_REDUCED);
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+/**
+ * Method interface 8 bytes in 10 bytes out
+ */
+int nb04_wmi_ab_method_buffer_reduced_output(u32 wmi_method_id, u8 *in, u8 *out)
+{
+	if (__wmi_dev)
+		return __nb04_wmi_ab_method_buffer_reduced_output(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(nb04_wmi_ab_method_buffer_reduced_output);
+
+static int
+__nb04_wmi_ab_method_extended_input(struct wmi_device *wdev, u32 wmi_method_id,
+				    u8 *in, u8 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)AB_INPUT_BUFFER_LENGTH_EXTENDED, in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb04_wmi_ab_lock);
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+	mutex_unlock(&nb04_wmi_ab_lock);
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method %u\n", wmi_method_id);
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_BUFFER) {
+		pr_err("No buffer for method (%u) call\n", wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	if (acpi_object_out->buffer.length != AB_OUTPUT_BUFFER_LENGTH) {
+		pr_err("Unexpected buffer length: %u for method (%u) call\n", 
+		       acpi_object_out->buffer.length, wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	memcpy(out, acpi_object_out->buffer.pointer, AB_OUTPUT_BUFFER_LENGTH);
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+/**
+ * Method interface 496 bytes in 80 bytes out
+ */
+int nb04_wmi_ab_method_extended_input(u32 wmi_method_id, u8 *in, u8 *out)
+{
+	if (__wmi_dev)
+		return __nb04_wmi_ab_method_extended_input(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(nb04_wmi_ab_method_extended_input);
+
+static int
+__nb04_wmi_ab_method_int_out(struct wmi_device *wdev, u32 wmi_method_id,
+			     u8 *in, u64 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)AB_INPUT_BUFFER_LENGTH_NORMAL, in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb04_wmi_ab_lock);
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+	mutex_unlock(&nb04_wmi_ab_lock);
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method\n");
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_INTEGER) {
+		pr_err("No integer\n");
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	*out = acpi_object_out->integer.value;
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+/**
+ * Method interface 8 bytes in integer out
+ */
+int nb04_wmi_ab_method_int_out(u32 wmi_method_id, u8 *in, u64 *out)
+{
+	if (__wmi_dev)
+		return __nb04_wmi_ab_method_int_out(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(nb04_wmi_ab_method_int_out);
+
+int wmi_update_device_status_keyboard(struct device_keyboard_status_t *kbds)
+{
+	u8 arg[AB_INPUT_BUFFER_LENGTH_NORMAL] = {0};
+	u8 out[AB_OUTPUT_BUFFER_LENGTH] = {0};
+	u16 wmi_return;
+	int result, retry_count = 3;
+
+	arg[0] = WMI_DEVICE_TYPE_ID_KEYBOARD;
+
+	while (retry_count--) {
+		result = nb04_wmi_ab_method_buffer(2, arg, out);
+		if (result)
+			return result;
+
+		wmi_return = (out[1] << 8) | out[0];
+		if (wmi_return != WMI_RETURN_STATUS_SUCCESS)
+			return -EIO;
+
+		if (out[3] < WMI_KEYBOARD_TYPE_MAX)
+			break;
+
+		// Sometimes initial read has proved to fail without having a fail
+		// status. However the returned keyboard type in this case is invalid.
+		pr_debug("Unexpected keyboard type (%d), retry read\n", out[3]);
+		msleep(50);
+	}
+
+	// If, despite retries, not getting a valid keyboard type => give up
+	if (out[3] >= WMI_KEYBOARD_TYPE_MAX) {
+		pr_err("Failed to identifiy keyboard type\n");
+		return -ENODEV;
+	}
+
+	kbds->keyboard_state_enabled = out[2] == 1;
+	kbds->keyboard_type = out[3];
+	kbds->keyboard_sidebar_support = out[4] == 1;
+	kbds->keyboard_matrix = out[5];
+
+	return 0;
+}
+EXPORT_SYMBOL(wmi_update_device_status_keyboard);
+
+int wmi_set_whole_keyboard(u8 red, u8 green, u8 blue, int brightness)
+{
+	u8 arg[AB_INPUT_BUFFER_LENGTH_NORMAL] = {0};
+	u64 out;
+	u8 brightness_byte = 0xfe, enable_byte = 0x01;
+	int result;
+
+	if (brightness == 0)
+		enable_byte = 0x00;
+	else if (brightness > 0 && brightness <= 10)
+		brightness_byte = brightness;
+
+	arg[0] = 0x00;
+	arg[1] = red;
+	arg[2] = green;
+	arg[3] = blue;
+	arg[4] = brightness_byte;
+	arg[5] = 0xfe;
+	arg[6] = 0x00;
+	arg[7] = enable_byte;
+
+	result = nb04_wmi_ab_method_int_out(3, arg, &out);
+	if (result)
+		return result;
+
+	if (out != 0)
+		return -EIO;
+
+	return 0;
+}
+EXPORT_SYMBOL(wmi_set_whole_keyboard);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int tuxedo_nb04_wmi_ab_probe(struct wmi_device *wdev)
+#else
+static int tuxedo_nb04_wmi_ab_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	struct driver_data_t *driver_data;
+
+	pr_debug("driver probe\n");
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	if (!wmi_has_guid(NB04_WMI_AB_GUID))
+		return -ENODEV;
+
+	driver_data = devm_kzalloc(&wdev->dev, sizeof(struct driver_data_t), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&wdev->dev, driver_data);
+
+	__wmi_dev = wdev;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int tuxedo_nb04_wmi_ab_remove(struct wmi_device *wdev)
+#else
+static void tuxedo_nb04_wmi_ab_remove(struct wmi_device *wdev)
+#endif
+{
+	__wmi_dev = NULL;
+	pr_debug("driver remove\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static const struct wmi_device_id tuxedo_nb04_wmi_ab_device_ids[] = {
+	{ .guid_string = NB04_WMI_AB_GUID },
+	{ }
+};
+
+static struct wmi_driver tuxedo_nb04_wmi_ab_driver = {
+	.driver = {
+		.name = "tuxedo_nb04_wmi_ab",
+		.owner = THIS_MODULE
+	},
+	.id_table = tuxedo_nb04_wmi_ab_device_ids,
+	.probe = tuxedo_nb04_wmi_ab_probe,
+	.remove = tuxedo_nb04_wmi_ab_remove,
+};
+
+module_wmi_driver(tuxedo_nb04_wmi_ab_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB04 WMI AB methods");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, tuxedo_nb04_wmi_ab_device_ids);
+MODULE_ALIAS("wmi:" NB04_WMI_AB_GUID);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_ab.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_NB04_WMI_AB_H
+#define TUXEDO_NB04_WMI_AB_H
+
+#define NB04_WMI_AB_GUID	"80C9BAA6-AC48-4538-9234-9F81A55E7C85"
+MODULE_ALIAS("wmi:" NB04_WMI_AB_GUID);
+
+#define AB_INPUT_BUFFER_LENGTH_NORMAL	8
+#define AB_INPUT_BUFFER_LENGTH_EXTENDED	496
+#define AB_OUTPUT_BUFFER_LENGTH		80
+#define AB_OUTPUT_BUFFER_LENGTH_REDUCED	10
+
+enum wmi_return_status {
+	WMI_RETURN_STATUS_SUCCESS = 0,
+	WMI_RETURN_STATUS_UNSUPPORTED = 1,
+	WMI_RETURN_STATUS_INVALID_PARAMETER = 2,
+	WMI_RETURN_STATUS_UNDEFINED_DEVICE = 3,
+	WMI_RETURN_STATUS_DEVICE_ERROR = 4,
+	WMI_RETURN_STATUS_UNEXPECTED_ERROR = 5,
+	WMI_RETURN_STATUS_TIMEOUT = 6,
+	WMI_RETURN_STATUS_EC_BUSY = 7,
+};
+
+enum wmi_device_type_id {
+	WMI_DEVICE_TYPE_ID_TOUCHPAD = 1,
+	WMI_DEVICE_TYPE_ID_KEYBOARD = 2,
+	WMI_DEVICE_TYPE_ID_APPDISPLAYPAGES = 3
+};
+
+enum wmi_keyboard_type {
+	WMI_KEYBOARD_TYPE_NORMAL = 0,
+	WMI_KEYBOARD_TYPE_PERKEY = 1,
+	WMI_KEYBOARD_TYPE_4ZONE = 2,
+	WMI_KEYBOARD_TYPE_WHITE = 3,
+	WMI_KEYBOARD_TYPE_MAX,
+};
+
+enum wmi_keyboard_matrix {
+	WMI_KEYBOARD_MATRIX_US = 0,
+	WMI_KEYBOARD_MATRIX_UK = 1
+};
+
+enum wmi_color_preset {
+	WMI_COLOR_PRESET_RED = 1,
+	WMI_COLOR_PRESET_GREEN = 2,
+	WMI_COLOR_PRESET_YELLOW = 3,
+	WMI_COLOR_PRESET_BLUE = 4,
+	WMI_COLOR_PRESET_PURPLE = 5,
+	WMI_COLOR_PRESET_INDIGO = 6,
+	WMI_COLOR_PRESET_WHITE = 7
+};
+
+struct device_keyboard_status_t {
+	bool keyboard_state_enabled;
+	enum wmi_keyboard_type keyboard_type;
+	bool keyboard_sidebar_support;
+	enum wmi_keyboard_matrix keyboard_matrix;
+};
+
+int nb04_wmi_ab_method_buffer(u32 wmi_method_id, u8 *in, u8 *out);
+int nb04_wmi_ab_method_buffer_reduced_output(u32 wmi_method_id, u8 *in, u8 *out);
+int nb04_wmi_ab_method_extended_input(u32 wmi_method_id, u8 *in, u8 *out);
+int nb04_wmi_ab_method_int_out(u32 wmi_method_id, u8 *in, u64 *out);
+
+int wmi_update_device_status_keyboard(struct device_keyboard_status_t *kbds);
+int wmi_set_whole_keyboard(u8 red, u8 green, u8 blue, int brightness);
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,164 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/version.h>
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+#include "tuxedo_nb04_wmi_bs.h"
+
+#define BS_INPUT_BUFFER_LENGTH	8
+#define BS_OUTPUT_BUFFER_LENGTH	80
+
+struct driver_data_t {};
+
+static DEFINE_MUTEX(nb04_wmi_bs_access_lock);
+
+static struct wmi_device *__wmi_dev;
+
+bool nb04_wmi_bs_available(void)
+{
+	if (__wmi_dev)
+		return true;
+	else
+		return false;
+}
+EXPORT_SYMBOL(nb04_wmi_bs_available);
+
+static int __nb04_wmi_bs_method(struct wmi_device *wdev, u32 wmi_method_id,
+				u8 *in, u8 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size)BS_INPUT_BUFFER_LENGTH, in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb04_wmi_bs_access_lock);
+
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+
+	mutex_unlock(&nb04_wmi_bs_access_lock);
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method %u\n", wmi_method_id);
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_BUFFER) {
+		// Returns an int 0 when not finding a valid method number
+		kfree(return_buffer.pointer);
+		return -EINVAL;
+	}
+
+	if (acpi_object_out->buffer.length != BS_OUTPUT_BUFFER_LENGTH) {
+		pr_err("Unexpected buffer length: %u for method (%u) call\n", 
+		       acpi_object_out->buffer.length, wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	memcpy(out, acpi_object_out->buffer.pointer, BS_OUTPUT_BUFFER_LENGTH);
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+/**
+ * Method interface 8 bytes in 80 bytes out
+ */
+int nb04_wmi_bs_method(u32 wmi_method_id, u8 *in, u8 *out)
+{
+	if (__wmi_dev)
+		return __nb04_wmi_bs_method(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL(nb04_wmi_bs_method);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int tuxedo_nb04_wmi_probe(struct wmi_device *wdev)
+#else
+static int tuxedo_nb04_wmi_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	struct driver_data_t *driver_data;
+
+	pr_debug("driver probe\n");
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	if (!wmi_has_guid(NB04_WMI_BS_GUID))
+		return -ENODEV;
+
+	__wmi_dev = wdev;
+
+	driver_data = devm_kzalloc(&wdev->dev, sizeof(struct driver_data_t), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&wdev->dev, driver_data);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int tuxedo_nb04_wmi_remove(struct wmi_device *wdev)
+#else
+static void tuxedo_nb04_wmi_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("driver remove\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static const struct wmi_device_id tuxedo_nb04_wmi_device_ids[] = {
+	{ .guid_string = NB04_WMI_BS_GUID },
+	{ }
+};
+
+static struct wmi_driver tuxedo_nb04_wmi_driver = {
+	.driver = {
+		.name = "tuxedo_nb04_wmi",
+		.owner = THIS_MODULE
+	},
+	.id_table = tuxedo_nb04_wmi_device_ids,
+	.probe = tuxedo_nb04_wmi_probe,
+	.remove = tuxedo_nb04_wmi_remove,
+};
+
+module_wmi_driver(tuxedo_nb04_wmi_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB04 WMI BS methods");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, tuxedo_nb04_wmi_device_ids);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb04/tuxedo_nb04_wmi_bs.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2023 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_NB04_WMI_BS_H
+#define TUXEDO_NB04_WMI_BS_H
+
+#define NB04_WMI_BS_GUID	"1F174999-3A4E-4311-900D-7BE7166D5055"
+MODULE_ALIAS("wmi:" NB04_WMI_BS_GUID);
+
+enum wmi_system_mode {
+	WMI_SYSTEM_MODE_BATTERY = 0,
+	WMI_SYSTEM_MODE_HUMAN = 1,
+	WMI_SYSTEM_MODE_BEAST = 2,
+	WMI_SYSTEM_MODE_END,
+};
+
+enum wmi_return_status {
+	WMI_RETURN_STATUS_SUCCESS = 0,
+	WMI_RETURN_STATUS_UNSUPPORTED = 1,
+	WMI_RETURN_STATUS_INVALID_PARAMETER = 2,
+	WMI_RETURN_STATUS_UNDEFINED_DEVICE = 3,
+	WMI_RETURN_STATUS_DEVICE_ERROR = 4,
+	WMI_RETURN_STATUS_UNEXPECTED_ERROR = 5,
+	WMI_RETURN_STATUS_TIMEOUT = 6,
+	WMI_RETURN_STATUS_EC_BUSY = 7,
+};
+
+#define BS_INPUT_BUFFER_LENGTH		8
+#define BS_OUTPUT_BUFFER_LENGTH		80
+bool nb04_wmi_bs_available(void);
+int nb04_wmi_bs_method(u32 wmi_method_id, u8 *in, u8 *out);
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,6 @@
+obj-m += tuxedo_nb05_keyboard.o
+obj-m += tuxedo_nb05_kbd_backlight.o
+obj-m += tuxedo_nb05_power_profiles.o
+obj-m += tuxedo_nb05_ec.o
+obj-m += tuxedo_nb05_sensors.o
+obj-m += tuxedo_nb05_fan_control.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dmi.h>
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include "tuxedo_nb05_ec.h"
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+
+static struct nb05_ec_data_t ec_data;
+
+#define EC_PORT_ADDR	0x4e
+#define EC_PORT_DATA	0x4f
+
+#define I2EC_REG_ADDR	0x2e
+#define I2EC_REG_DATA	0x2f
+
+#define I2EC_ADDR_LOW	0x10
+#define I2EC_ADDR_HIGH	0x11
+#define I2EC_ADDR_DATA	0x12
+
+static DEFINE_MUTEX(nb05_ec_access_lock);
+
+static void io_write(u8 reg, u8 data)
+{
+	outb(reg, EC_PORT_ADDR);
+	outb(data, EC_PORT_DATA);
+}
+
+static u8 io_read(u8 reg)
+{
+	outb(reg, EC_PORT_ADDR);
+	return inb(EC_PORT_DATA);
+}
+
+void nb05_read_ec_ram(u16 addr, u8 *data)
+{
+	u8 addr_high = (addr >> 8) & 0xff;
+	u8 addr_low = (addr & 0xff);
+
+	mutex_lock(&nb05_ec_access_lock);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_HIGH);
+	io_write(I2EC_REG_DATA, addr_high);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_LOW);
+	io_write(I2EC_REG_DATA, addr_low);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_DATA);
+	*data = io_read(I2EC_REG_DATA);
+
+	mutex_unlock(&nb05_ec_access_lock);
+}
+EXPORT_SYMBOL(nb05_read_ec_ram);
+
+void nb05_write_ec_ram(u16 addr, u8 data)
+{
+	u8 addr_high = (addr >> 8) & 0xff;
+	u8 addr_low = (addr & 0xff);
+
+	mutex_lock(&nb05_ec_access_lock);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_HIGH);
+	io_write(I2EC_REG_DATA, addr_high);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_LOW);
+	io_write(I2EC_REG_DATA, addr_low);
+
+	io_write(I2EC_REG_ADDR, I2EC_ADDR_DATA);
+	io_write(I2EC_REG_DATA, data);
+
+	mutex_unlock(&nb05_ec_access_lock);
+}
+EXPORT_SYMBOL(nb05_write_ec_ram);
+
+void nb05_read_ec_fw_version(u8 *major, u8 *minor)
+{
+	nb05_read_ec_ram(0x0400, major);
+	nb05_read_ec_ram(0x0401, minor);
+}
+EXPORT_SYMBOL(nb05_read_ec_fw_version);
+
+static int tuxedo_nb05_ec_probe(struct platform_device *pdev)
+{
+	u8 minor, major;
+
+	nb05_read_ec_fw_version(&major, &minor);
+	pr_info("EC I/O driver loaded, firmware version %d.%d\n", major, minor);
+
+	ec_data.ver_major = major;
+	ec_data.ver_minor = minor;
+
+	return 0;
+}
+
+static struct platform_driver tuxedo_nb05_ec_driver = {
+	.driver		= {
+		.name	= KBUILD_MODNAME,
+	},
+	.probe		= tuxedo_nb05_ec_probe,
+};
+
+static struct platform_device *tuxedo_nb05_ec_device;
+
+static int dmi_check_callback(const struct dmi_system_id *id)
+{
+	printk(KERN_INFO KBUILD_MODNAME ": found model '%s'\n", id->ident);
+	ec_data.dev_data = id->driver_data;
+	return 1;
+}
+
+struct nb05_device_data_t data_pulse = {
+	.number_fans = 2,
+	.fanctl_onereg = false,
+};
+
+struct nb05_device_data_t data_infinityflex = {
+	.number_fans = 1,
+	.fanctl_onereg = true,
+};
+
+static const struct dmi_system_id tuxedo_nb05_id_table[] = {
+	{
+		.ident = PULSE1403,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "NB05"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "PULSE1403"),
+		},
+		.callback = dmi_check_callback,
+		.driver_data = &data_pulse,
+	},
+	{
+		.ident = PULSE1404,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "NB05"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "PULSE1404"),
+		},
+		.callback = dmi_check_callback,
+		.driver_data = &data_pulse,
+	},
+	{
+		.ident = IFLX14I01,
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_VENDOR, "NB05"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "IFLX14I01"),
+		},
+		.callback = dmi_check_callback,
+		.driver_data = &data_infinityflex,
+	},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(dmi, tuxedo_nb05_id_table);
+
+const struct dmi_system_id *nb05_match_device(void)
+{
+	return dmi_first_match(tuxedo_nb05_id_table);
+}
+EXPORT_SYMBOL(nb05_match_device);
+
+void nb05_get_ec_data(struct nb05_ec_data_t **ec_data_pp)
+{
+	*ec_data_pp = &ec_data;
+}
+EXPORT_SYMBOL(nb05_get_ec_data);
+
+static int __init tuxedo_nb05_ec_init(void)
+{
+	if (!dmi_check_system(tuxedo_nb05_id_table))
+		return -ENODEV;
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	tuxedo_nb05_ec_device =
+		platform_create_bundle(&tuxedo_nb05_ec_driver,
+				       tuxedo_nb05_ec_probe,
+				       NULL, 0, NULL, 0);
+
+	return PTR_ERR_OR_ZERO(tuxedo_nb05_ec_device);
+}
+
+static void __exit tuxedo_nb05_ec_exit(void)
+{
+	platform_device_unregister(tuxedo_nb05_ec_device);
+	platform_driver_unregister(&tuxedo_nb05_ec_driver);
+}
+
+module_init(tuxedo_nb05_ec_init);
+module_exit(tuxedo_nb05_ec_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB05 EC I/O");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_ec.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_NB05_EC_H
+#define TUXEDO_NB05_EC_H
+
+#define PULSE1403 "TUXEDO Pulse 14 Gen3"
+#define PULSE1404 "TUXEDO Pulse 14 Gen4"
+#define IFLX14I01 "TUXEDO InfinityFlex 14 Gen1"
+
+MODULE_ALIAS("platform:tuxedo_nb05_ec");
+
+struct nb05_ec_data_t {
+	u8 ver_major;
+	u8 ver_minor;
+	struct nb05_device_data_t *dev_data;
+};
+
+struct nb05_device_data_t {
+	int number_fans;
+	bool fanctl_onereg;
+};
+
+void nb05_read_ec_ram(u16 addr, u8 *data);
+void nb05_write_ec_ram(u16 addr, u8 data);
+void nb05_read_ec_fw_version(u8 *major, u8 *minor);
+void nb05_get_ec_data(struct nb05_ec_data_t **ec_data);
+
+const struct dmi_system_id *nb05_match_device(void);
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_fan_control.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_fan_control.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_fan_control.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_fan_control.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,561 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dmi.h>
+#include <linux/version.h>
+#include "tuxedo_nb05_ec.h"
+
+#define FAN_SET_RPM_MAX 54
+#define FAN_SET_DUTY_MAX 0xb8
+#define FAN_ON_MIN_SPEED_PERCENT 25
+#define FAN_SET_RPM_HIGHTEMP 15
+#define FAN_SET_DUTY_HIGHTEMP ((FAN_SET_RPM_HIGHTEMP * FAN_SET_DUTY_MAX) / FAN_SET_RPM_MAX)
+
+#define PWM_TO_RPM(pwm_data) ((pwm_data * FAN_SET_RPM_MAX) / 0xff)
+#define PWM_TO_DUTY(pwm_data) ((pwm_data * FAN_SET_DUTY_MAX) / 0xff)
+#define RPM_TO_PWM(rpm_data) ((rpm_data * 0xff) / FAN_SET_RPM_MAX)
+#define DUTY_TO_PWM(duty_data) ((duty_data * 0xff) / FAN_SET_DUTY_MAX)
+
+struct driver_data_t {
+	struct platform_device *pdev;
+	struct nb05_ec_data_t *ec_data;
+	bool write_rpm;
+};
+
+static ssize_t fan1_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer);
+
+static ssize_t fan1_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size);
+
+static ssize_t fan1_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer);
+
+static ssize_t fan1_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size);
+
+static ssize_t fan2_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer);
+
+static ssize_t fan2_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size);
+
+static ssize_t fan2_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer);
+
+static ssize_t fan2_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size);
+
+static int write_fan1_rpm(u8 rpm_data);
+static u8 read_fan1_duty_ranges(void);
+static u8 read_fan1_duty_onereg(void);
+static int write_fan1_duty_ranges(u8 rpm_data);
+static int write_fan1_duty_onereg(u8 rpm_data);
+static bool read_fan1_enable_ranges(void);
+static bool read_fan1_enable_onereg(void);
+static int write_fan1_enable_ranges(bool enable_data);
+static int write_fan1_enable_onereg(bool enable_data);
+static int write_fan2_rpm(u8 rpm_data);
+static u8 read_fan2_duty(void);
+static int write_fan2_duty(u8 rpm_data);
+static bool read_fan2_enable(void);
+static int write_fan2_enable(bool enable_data);
+
+static int write_fan1_rpm(u8 rpm_data)
+{
+	int reg;
+
+	if (rpm_data > FAN_SET_RPM_MAX)
+		return -EINVAL;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (rpm_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 2 / 100)
+		rpm_data = 0;
+	else if (rpm_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 100)
+		rpm_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 100;
+
+	for (reg = 0x02d0; reg <= 0x02d6; ++reg)
+		nb05_write_ec_ram(reg, rpm_data);
+
+	if (rpm_data < FAN_SET_RPM_HIGHTEMP)
+		rpm_data = FAN_SET_RPM_HIGHTEMP;
+
+	nb05_write_ec_ram(0x02d7, rpm_data);
+	nb05_write_ec_ram(0x02d8, rpm_data);
+
+	return 0;
+}
+
+static u8 read_fan1_duty_ranges(void)
+{
+	u8 duty_data;
+	nb05_read_ec_ram(0x2c1, &duty_data);
+	return duty_data;
+}
+
+static u8 read_fan1_duty_onereg(void)
+{
+	u8 duty_data;
+	nb05_read_ec_ram(0x1809, &duty_data);
+	return duty_data;
+}
+
+static int write_fan1_duty_ranges(u8 duty_data)
+{
+	int reg;
+
+	if (duty_data > FAN_SET_DUTY_MAX)
+		return -EINVAL;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (duty_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 2 / 100)
+		duty_data = 0;
+	else if (duty_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100)
+		duty_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100;
+
+	for (reg = 0x02c1; reg <= 0x02c7; ++reg)
+		nb05_write_ec_ram(reg, duty_data);
+
+	if (duty_data < FAN_SET_DUTY_HIGHTEMP)
+		duty_data = FAN_SET_DUTY_HIGHTEMP;
+
+	nb05_write_ec_ram(0x02c8, duty_data);
+	nb05_write_ec_ram(0x02c9, duty_data);
+
+	return 0;
+}
+
+static int write_fan1_duty_onereg(u8 duty_data)
+{
+	if (duty_data > FAN_SET_DUTY_MAX)
+		return -EINVAL;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (duty_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 2 / 100)
+		duty_data = 0;
+	else if (duty_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100)
+		duty_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100;
+
+	nb05_write_ec_ram(0x1809, duty_data);
+
+	return 0;
+}
+
+static bool read_fan1_enable_ranges(void)
+{
+	u8 enable_data;
+	nb05_read_ec_ram(0x2c0, &enable_data);
+	return (enable_data & 0x01);
+}
+
+static bool read_fan1_enable_onereg(void)
+{
+	u8 enable_data;
+	nb05_read_ec_ram(0x2f1, &enable_data);
+	return (enable_data == 0xaa);
+}
+
+static int write_fan1_enable_ranges(bool enable)
+{
+	u8 enable_data = enable ? 1 : 0;
+	nb05_write_ec_ram(0x2c0, enable_data);
+	return 0;
+}
+
+static int write_fan1_enable_onereg(bool enable)
+{
+	u8 enable_data = enable ? 0xaa : 0x00;
+	nb05_write_ec_ram(0x2f1, enable_data);
+	return 0;
+}
+
+static int write_fan2_rpm(u8 rpm_data)
+{
+	int reg;
+
+	if (rpm_data > FAN_SET_RPM_MAX)
+		return -EINVAL;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (rpm_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 2 / 100)
+		rpm_data = 0;
+	else if (rpm_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 100)
+		rpm_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_RPM_MAX / 100;
+
+	for (reg = 0x0250; reg <= 0x0256; ++reg)
+		nb05_write_ec_ram(reg, rpm_data);
+
+	if (rpm_data < FAN_SET_RPM_HIGHTEMP)
+		rpm_data = FAN_SET_RPM_HIGHTEMP;
+
+	nb05_write_ec_ram(0x0257, rpm_data);
+	nb05_write_ec_ram(0x0258, rpm_data);
+
+	return 0;
+}
+
+static u8 read_fan2_duty(void)
+{
+	u8 rpm_data;
+	nb05_read_ec_ram(0x0241, &rpm_data);
+	return rpm_data;
+}
+
+static int write_fan2_duty(u8 duty_data)
+{
+	int reg;
+
+	if (duty_data > FAN_SET_DUTY_MAX)
+		return -EINVAL;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (duty_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 2 / 100)
+		duty_data = 0;
+	else if (duty_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100)
+		duty_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100;
+
+	for (reg = 0x0241; reg <= 0x0247; ++reg)
+		nb05_write_ec_ram(reg, duty_data);
+
+	if (duty_data < FAN_SET_DUTY_HIGHTEMP)
+		duty_data = FAN_SET_DUTY_HIGHTEMP;
+
+	nb05_write_ec_ram(0x0248, duty_data);
+	nb05_write_ec_ram(0x0249, duty_data);
+
+	return 0;
+}
+
+static bool read_fan2_enable(void)
+{
+	u8 enable_data;
+	nb05_read_ec_ram(0x240, &enable_data);
+	return (enable_data & 0x01);
+}
+
+static int write_fan2_enable(bool enable)
+{
+	u8 enable_data = enable ? 1 : 0;
+	nb05_write_ec_ram(0x240, enable_data);
+	return 0;
+}
+
+struct fan_control_attrs_t {
+	struct device_attribute fan1_pwm;
+	struct device_attribute fan1_pwm_enable;
+	struct device_attribute fan2_pwm;
+	struct device_attribute fan2_pwm_enable;
+};
+
+struct fan_control_attrs_t fan_control_attrs = {
+	.fan1_pwm = __ATTR(fan1_pwm, 0644, fan1_pwm_show, fan1_pwm_store),
+	.fan1_pwm_enable = __ATTR(fan1_pwm_enable, 0644, fan1_pwm_enable_show, fan1_pwm_enable_store),
+	.fan2_pwm = __ATTR(fan2_pwm, 0644, fan2_pwm_show, fan2_pwm_store),
+	.fan2_pwm_enable = __ATTR(fan2_pwm_enable, 0644, fan2_pwm_enable_show, fan2_pwm_enable_store),
+};
+
+static struct attribute *fan_control_attrs_list[] = {
+	&fan_control_attrs.fan1_pwm.attr,
+	&fan_control_attrs.fan1_pwm_enable.attr,
+	&fan_control_attrs.fan2_pwm.attr,
+	&fan_control_attrs.fan2_pwm_enable.attr,
+	NULL
+};
+
+static umode_t fan_control_attr_is_visible(struct kobject *kobj,
+					   struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+
+	// Two attributes per fan, show interface for device specific number of fans
+	if (n < (driver_data->ec_data->dev_data->number_fans * 2))
+		return 0644;
+	else
+		return 0;
+}
+
+static struct attribute_group fan_control_attr_group = {
+	.attrs = fan_control_attrs_list,
+	.is_visible = fan_control_attr_is_visible,
+};
+
+static ssize_t fan1_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+	u8 pwm_data, duty_data;
+
+	if (driver_data->ec_data->dev_data->fanctl_onereg)
+		duty_data = read_fan1_duty_onereg();
+	else
+		duty_data = read_fan1_duty_ranges();
+
+	pwm_data = DUTY_TO_PWM(duty_data);
+	sysfs_emit(buffer, "%d\n", pwm_data);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan1_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size)
+{
+	u8 pwm_data, rpm_data, duty_data;
+	int err;
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+
+	if (kstrtou8(buffer, 0, &pwm_data))
+		return -EINVAL;
+
+	duty_data = PWM_TO_DUTY(pwm_data);
+	rpm_data = PWM_TO_RPM(pwm_data);
+
+	if (driver_data->ec_data->dev_data->fanctl_onereg)
+		err = write_fan1_duty_onereg(duty_data);
+	else
+		err = write_fan1_duty_ranges(duty_data);
+
+	if (err)
+		return err;
+
+	if (driver_data->write_rpm) {
+		err = write_fan1_rpm(rpm_data);
+		if (err)
+			return err;
+	}
+
+	return size;
+}
+
+static ssize_t fan1_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+	bool enable_data;
+	u8 enable_hwmon;
+
+	if (driver_data->ec_data->dev_data->fanctl_onereg)
+		enable_data = read_fan1_enable_onereg();
+	else
+		enable_data = read_fan1_enable_ranges();
+
+	if (enable_data)
+		enable_hwmon = 1;
+	else
+		enable_hwmon = 2;
+
+	sysfs_emit(buffer, "%d\n", enable_hwmon);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan1_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+	bool enable_data;
+	u8 enable_hwmon;
+	int err;
+
+	if (kstrtou8(buffer, 0, &enable_hwmon))
+		return -EINVAL;
+
+	if (enable_hwmon == 2)
+		enable_data = false;
+	else
+		enable_data = true;
+
+	if (driver_data->ec_data->dev_data->fanctl_onereg)
+		err = write_fan1_enable_onereg(enable_data);
+	else
+		err = write_fan1_enable_ranges(enable_data);
+
+	if (err)
+		return err;
+
+	return size;
+}
+
+static ssize_t fan2_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer)
+{
+	u8 pwm_data, duty_data;
+	duty_data = read_fan2_duty();
+	pwm_data = DUTY_TO_PWM(duty_data);
+	sysfs_emit(buffer, "%d\n", pwm_data);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan2_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size)
+{	
+	u8 pwm_data, rpm_data, duty_data;
+	int err;
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+
+	if (kstrtou8(buffer, 0, &pwm_data))
+		return -EINVAL;
+
+	duty_data = PWM_TO_DUTY(pwm_data);
+	rpm_data = PWM_TO_RPM(pwm_data);
+
+	err = write_fan2_duty(duty_data);
+	if (err)
+		return err;
+
+	if (driver_data->write_rpm) {
+		err = write_fan2_rpm(rpm_data);
+		if (err)
+			return err;
+	}
+
+	return size;
+}
+
+static ssize_t fan2_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer)
+{
+	bool enable_data;
+	u8 enable_hwmon;
+	enable_data = read_fan2_enable();
+	if (enable_data)
+		enable_hwmon = 1;
+	else
+		enable_hwmon = 2;
+
+	sysfs_emit(buffer, "%d\n", enable_hwmon);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan2_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size)
+{
+	bool enable_data;
+	u8 enable_hwmon;
+	int err;
+
+	if (kstrtou8(buffer, 0, &enable_hwmon))
+		return -EINVAL;
+
+	if (enable_hwmon == 2)
+		enable_data = false;
+	else
+		enable_data = true;
+
+	err = write_fan2_enable(enable_data);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static int __init tuxedo_nb05_fan_control_probe(struct platform_device *pdev)
+{
+	int err;
+
+	struct driver_data_t *driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	pr_debug("driver probe\n");
+
+	dev_set_drvdata(&pdev->dev, driver_data);
+
+	driver_data->pdev = pdev;
+	nb05_get_ec_data(&driver_data->ec_data);
+
+	driver_data->write_rpm = false;
+	if (!driver_data->ec_data->dev_data->fanctl_onereg) {
+		if (driver_data->ec_data->ver_major >= 9 &&
+		    driver_data->ec_data->ver_minor >= 10)
+			driver_data->write_rpm = false;
+		else
+			driver_data->write_rpm = true;
+	}
+
+	err = sysfs_create_group(&driver_data->pdev->dev.kobj, &fan_control_attr_group);
+	if (err) {
+		pr_err("create group failed\n");
+		platform_device_unregister(driver_data->pdev);
+		return err;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int tuxedo_nb05_fan_control_remove(struct platform_device *pdev)
+#else
+static void tuxedo_nb05_fan_control_remove(struct platform_device *pdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	sysfs_remove_group(&driver_data->pdev->dev.kobj, &fan_control_attr_group);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static struct platform_device *tuxedo_nb05_fan_control_device;
+static struct platform_driver tuxedo_nb05_fan_control_driver = {
+	.driver.name = "tuxedo_fan_control",
+	.remove = tuxedo_nb05_fan_control_remove,
+};
+
+static int __init tuxedo_nb05_fan_control_init(void)
+{
+	tuxedo_nb05_fan_control_device =
+		platform_create_bundle(&tuxedo_nb05_fan_control_driver,
+				       tuxedo_nb05_fan_control_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb05_fan_control_device))
+		return PTR_ERR(tuxedo_nb05_fan_control_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb05_fan_control_exit(void)
+{
+	platform_device_unregister(tuxedo_nb05_fan_control_device);
+	platform_driver_unregister(&tuxedo_nb05_fan_control_driver);
+}
+
+module_init(tuxedo_nb05_fan_control_init);
+module_exit(tuxedo_nb05_fan_control_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers NB05 fan control");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/version.h>
+#include <linux/dmi.h>
+#include "tuxedo_nb05_kbd_backlight.h"
+#include "tuxedo_nb05_ec.h"
+
+#define NB05_KBD_BRIGHTNESS_MAX_WHITE		0x02
+#define NB05_KBD_BRIGHTNESS_DEFAULT_WHITE	0x00
+
+static struct led_classdev *__nb05_kbd_led_cdev = NULL;
+
+static u8 white_brightness_to_level_map[] = {
+	0x00,
+	0x5c,
+	0xb8,
+};
+
+struct driver_data_t {
+	struct led_classdev nb05_kbd_led_cdev;
+};
+
+static void nb05_leds_set_brightness(struct led_classdev *led_cdev __always_unused,
+				     enum led_brightness brightness)
+{
+	if (brightness < 0 || brightness > NB05_KBD_BRIGHTNESS_MAX_WHITE)
+		return;
+
+	const struct dmi_system_id *sysid;
+	sysid = nb05_match_device();
+	if (!strcmp(sysid->ident, IFLX14I01))
+		nb05_write_ec_ram(0x03e2, white_brightness_to_level_map[brightness]);
+	else
+		nb05_write_ec_ram(0x0409, white_brightness_to_level_map[brightness]);
+}
+
+void nb05_leds_notify_brightness_change_extern(u8 step)
+{
+	if (step > NB05_KBD_BRIGHTNESS_MAX_WHITE)
+		return;
+
+	if (__nb05_kbd_led_cdev) {
+		__nb05_kbd_led_cdev->brightness = step;
+		led_classdev_notify_brightness_hw_changed(__nb05_kbd_led_cdev, step);
+	}
+}
+EXPORT_SYMBOL(nb05_leds_notify_brightness_change_extern);
+
+static int init_leds(struct platform_device *pdev)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	int retval;
+
+	driver_data->nb05_kbd_led_cdev.name = "white:" LED_FUNCTION_KBD_BACKLIGHT;
+	driver_data->nb05_kbd_led_cdev.max_brightness = NB05_KBD_BRIGHTNESS_MAX_WHITE;
+	driver_data->nb05_kbd_led_cdev.brightness_set = &nb05_leds_set_brightness;
+	driver_data->nb05_kbd_led_cdev.brightness = NB05_KBD_BRIGHTNESS_DEFAULT_WHITE;
+	driver_data->nb05_kbd_led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+
+	retval = led_classdev_register(&pdev->dev, &driver_data->nb05_kbd_led_cdev);
+	if (retval)
+		return retval;
+
+	__nb05_kbd_led_cdev = &driver_data->nb05_kbd_led_cdev;
+
+	return 0;
+}
+
+static int __init tuxedo_nb05_kbd_backlight_probe(struct platform_device *pdev)
+{
+	int result;
+	struct driver_data_t *driver_data;
+
+	pr_debug("driver probe\n");
+
+	driver_data = devm_kzalloc(&pdev->dev, sizeof(struct driver_data_t), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, driver_data);
+
+	if (result) {
+		pr_err("Failed init write %d\n", result);
+		return result;
+	}
+
+	result = init_leds(pdev);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int tuxedo_nb05_kbd_backlight_remove(struct platform_device *pdev)
+#else
+static void tuxedo_nb05_kbd_backlight_remove(struct platform_device *pdev)
+#endif
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	led_classdev_unregister(&driver_data->nb05_kbd_led_cdev);
+	__nb05_kbd_led_cdev = NULL;
+	pr_debug("driver remove\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static struct platform_device *tuxedo_nb05_kbd_backlight_device;
+static struct platform_driver tuxedo_nb05_kbd_backlight_driver = {
+	.driver.name = "tuxedo_nb05_kbd_backlight",
+	.remove = tuxedo_nb05_kbd_backlight_remove
+};
+
+static int __init tuxedo_nb05_kbd_backlight_init(void)
+{
+	tuxedo_nb05_kbd_backlight_device =
+		platform_create_bundle(&tuxedo_nb05_kbd_backlight_driver,
+				       tuxedo_nb05_kbd_backlight_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb05_kbd_backlight_device))
+		return PTR_ERR(tuxedo_nb05_kbd_backlight_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb05_kbd_backlight_exit(void)
+{
+	platform_device_unregister(tuxedo_nb05_kbd_backlight_device);
+	platform_driver_unregister(&tuxedo_nb05_kbd_backlight_driver);
+}
+
+module_init(tuxedo_nb05_kbd_backlight_init);
+module_exit(tuxedo_nb05_kbd_backlight_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB05 keyboard backlight");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_kbd_backlight.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_NB05_KBD_BACKLIGHT_H
+#define TUXEDO_NB05_KBD_BACKLIGHT_H
+#include <linux/types.h>
+void nb05_leds_notify_brightness_change_extern(u8);
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_keyboard.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_keyboard.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_keyboard.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_keyboard.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/keyboard.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include "tuxedo_nb05_power_profiles.h"
+#include "tuxedo_nb05_kbd_backlight.h"
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+
+#define NB05_WMI_EVENT_GUID	"8FAFC061-22DA-46E2-91DB-1FE3D7E5FF3C"
+
+#define EVENT_STATUS_COMBO(event, status) (event | (status << 8)) 
+
+#define NB05_WMI_EVENT_TOUCHPAD_TOGGLE			0x02
+#define NB05_WMI_EVENT_KBD_BRT_CHANGE			0x03
+#define NB05_WMI_EVENT_KBD_BRT_MAX			0x07
+#define NB05_WMI_EVENT_KBD_BRT_MIDDLE			0x08
+#define NB05_WMI_EVENT_KBD_BRT_OFF			0x09
+#define NB05_WMI_EVENT_MODE_POWER_SAVE			0x11
+#define NB05_WMI_EVENT_MODE_BALANCE			0x12
+#define NB05_WMI_EVENT_MODE_HIGH_PERFORMANCE		0x13
+#define NB05_WMI_EVENT_CAMERA_TOGGLE			0x30
+#define NB05_WMI_EVENT_FNLOCK_TOGGLE			0x31
+
+#define NB05_WMI_EVENT_TOUCHPAD_ON	EVENT_STATUS_COMBO(NB05_WMI_EVENT_TOUCHPAD_TOGGLE, 0x11)
+#define NB05_WMI_EVENT_TOUCHPAD_OFF	EVENT_STATUS_COMBO(NB05_WMI_EVENT_TOUCHPAD_TOGGLE, 0x22)
+
+#define NB05_WMI_EVENT_CAMERA_ON	EVENT_STATUS_COMBO(NB05_WMI_EVENT_CAMERA_TOGGLE, 0x11)
+#define NB05_WMI_EVENT_CAMERA_OFF	EVENT_STATUS_COMBO(NB05_WMI_EVENT_CAMERA_TOGGLE, 0x22)
+
+#define NB05_WMI_EVENT_FNLOCK_ON	EVENT_STATUS_COMBO(NB05_WMI_EVENT_FNLOCK_TOGGLE, 0x11)
+#define NB05_WMI_EVENT_FNLOCK_OFF	EVENT_STATUS_COMBO(NB05_WMI_EVENT_FNLOCK_TOGGLE, 0x22)
+
+struct driver_data_t {
+	struct input_dev *input_dev;
+};
+
+static struct key_entry driver_keymap[] = {
+	{ KE_KEY,	NB05_WMI_EVENT_TOUCHPAD_ON,	{ KEY_F22 } },
+	{ KE_KEY,	NB05_WMI_EVENT_TOUCHPAD_OFF,	{ KEY_F23 } },
+	// Only used to put ev bits
+	{ KE_KEY,	0xffff,				{ KEY_F6 } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTALT } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTMETA } },
+	{ KE_END,	0 }
+};
+
+static void __attribute__ ((unused)) report_gauge_key_combo(struct input_dev *idev)
+{
+	// Special key combination when mode change key is pressed
+	input_report_key(idev, KEY_LEFTMETA, 1);
+	input_report_key(idev, KEY_LEFTALT, 1);
+	input_report_key(idev, KEY_F6, 1);
+	input_sync(idev);
+	input_report_key(idev, KEY_F6, 0);
+	input_report_key(idev, KEY_LEFTALT, 0);
+	input_report_key(idev, KEY_LEFTMETA, 0);
+	input_sync(idev);
+}
+
+/**
+ * Basically a copy of the existing report event but doesn't report unknown events
+ */
+static bool sparse_keymap_report_known_event(struct input_dev *dev,
+					     unsigned int code,
+					     unsigned int value,
+					     bool autorelease)
+{
+	const struct key_entry *ke =
+		sparse_keymap_entry_from_scancode(dev, code);
+
+	if (ke) {
+		sparse_keymap_report_entry(dev, ke, value, autorelease);
+		return true;
+	}
+
+	return false;
+}
+
+static int input_device_init(struct input_dev **input_dev_pp, const struct key_entry key_map[])
+{
+	struct input_dev *input_dev;
+	int err;
+
+	input_dev = input_allocate_device();
+	if (unlikely(!input_dev)) {
+		pr_err("Error allocating input device\n");
+		return -ENOMEM;
+	}
+
+	input_dev->name = "TUXEDO Keyboard Events";
+	input_dev->phys = "tuxedo-keyboard" "/input0";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->dev.parent = NULL;
+
+	if (key_map != NULL) {
+		err = sparse_keymap_setup(input_dev, key_map, NULL);
+		if (err) {
+			pr_err("Failed to setup sparse keymap\n");
+			goto err_free_input_device;
+		}
+	}
+
+	err = input_register_device(input_dev);
+	if (unlikely(err)) {
+		pr_err("Error registering input device\n");
+		goto err_free_input_device;
+	}
+
+	*input_dev_pp = input_dev;
+
+	return 0;
+
+err_free_input_device:
+	input_free_device(input_dev);
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int tuxedo_nb05_keyboard_probe(struct wmi_device *wdev)
+#else
+static int tuxedo_nb05_keyboard_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	struct driver_data_t *driver_data;
+	int err;
+
+	pr_debug("driver probe\n");
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	if (!wmi_has_guid(NB05_WMI_EVENT_GUID))
+		return -ENODEV;
+
+	driver_data = devm_kzalloc(&wdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&wdev->dev, driver_data);
+
+	err = input_device_init(&driver_data->input_dev, driver_keymap);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int tuxedo_nb05_keyboard_remove(struct wmi_device *wdev)
+#else
+static void tuxedo_nb05_keyboard_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+	input_unregister_device(driver_data->input_dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static void tuxedo_nb05_keyboard_notify(struct wmi_device *wdev, union acpi_object *obj)
+{
+	u8 function_number;
+	u8 event_code;
+	u16 device_status;
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+
+	if (obj &&
+	    obj->type == ACPI_TYPE_BUFFER &&
+	    obj->buffer.length >= 4)
+	{
+		function_number = obj->buffer.pointer[0];
+		event_code = obj->buffer.pointer[1];
+		device_status = obj->buffer.pointer[2] |
+				(obj->buffer.pointer[3] << 8);
+		pr_debug("event value: %d (%0#4x), device status %d (%0#6x)\n",
+			 event_code, event_code, device_status, device_status);
+
+		switch (event_code) {
+		case NB05_WMI_EVENT_MODE_POWER_SAVE:
+		case NB05_WMI_EVENT_MODE_BALANCE:
+		case NB05_WMI_EVENT_MODE_HIGH_PERFORMANCE:
+			if (!profile_changed_by_driver()) {
+				report_gauge_key_combo(driver_data->input_dev);
+				rewrite_last_profile();
+			}
+			break;
+		case NB05_WMI_EVENT_KBD_BRT_MAX:
+			nb05_leds_notify_brightness_change_extern(2);
+			break;
+		case NB05_WMI_EVENT_KBD_BRT_MIDDLE:
+			nb05_leds_notify_brightness_change_extern(1);
+			break;
+		case NB05_WMI_EVENT_KBD_BRT_OFF:
+			nb05_leds_notify_brightness_change_extern(0);
+			break;
+		case NB05_WMI_EVENT_KBD_BRT_CHANGE:
+			nb05_leds_notify_brightness_change_extern(device_status);
+			break;
+		default:
+			break;
+		}
+
+		// Report event_code
+		sparse_keymap_report_known_event(driver_data->input_dev,
+						 event_code,
+						 1,
+						 true);
+		// Report combined event code and device status
+		sparse_keymap_report_known_event(driver_data->input_dev,
+						 EVENT_STATUS_COMBO(event_code, device_status),
+						 1,
+						 true);
+	} else {
+		pr_debug("expected buffer not found\n");
+	}
+}
+
+static const struct wmi_device_id tuxedo_nb05_keyboard_device_ids[] = {
+	{ .guid_string = NB05_WMI_EVENT_GUID },
+	{ }
+};
+
+static struct wmi_driver tuxedo_nb05_keyboard_driver = {
+	.driver = {
+		.name = "tuxedo_nb05_keyboard",
+		.owner = THIS_MODULE
+	},
+	.id_table = tuxedo_nb05_keyboard_device_ids,
+	.probe = tuxedo_nb05_keyboard_probe,
+	.remove = tuxedo_nb05_keyboard_remove,
+	.notify = tuxedo_nb05_keyboard_notify,
+};
+
+module_wmi_driver(tuxedo_nb05_keyboard_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB05 keyboard events");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, tuxedo_nb05_keyboard_device_ids);
+MODULE_ALIAS("wmi:" NB05_WMI_EVENT_GUID);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/keyboard.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include "tuxedo_nb05_power_profiles.h"
+#include "../tuxedo_compatibility_check/tuxedo_compatibility_check.h"
+
+#define dev_to_wdev(__dev)	container_of(__dev, struct wmi_device, dev)
+
+#define NB05_WMI_METHOD_BA_GUID	"99D89064-8D50-42BB-BEA9-155B2E5D0FCD"
+
+static DEFINE_MUTEX(nb05_wmi_aa_access_lock);
+
+struct driver_data_t {
+	struct platform_device *pdev;
+	u64 last_chosen_profile;
+};
+
+static struct wmi_device *__wmi_dev;
+
+static int rewrite_last_profile_internal(void);
+
+static void nb05_rewrite_profile_work_handler(struct work_struct *work)
+{
+	rewrite_last_profile_internal();
+}
+
+static DECLARE_WORK(nb05_rewrite_profile_work, nb05_rewrite_profile_work_handler);
+
+static void profile_changed_timeout(struct timer_list *t);
+DEFINE_TIMER(profile_changed_timer, profile_changed_timeout);
+static volatile bool profile_changed_by_driver_flag = false;
+
+static void profile_changed_timer_bump(void)
+{
+	profile_changed_by_driver_flag = true;
+	mod_timer(&profile_changed_timer, jiffies + msecs_to_jiffies(300));
+}
+
+static void profile_changed_timeout(struct timer_list *t)
+{
+	profile_changed_by_driver_flag = false;
+	// Again make sure that the last profile is written
+	rewrite_last_profile();
+}
+
+/**
+ * Method interface: int in, int out
+ */
+static int __nb05_wmi_aa_method(struct wmi_device *wdev, u32 wmi_method_id,
+				u64 *in, u64 *out)
+{
+	struct acpi_buffer acpi_buffer_in = { (acpi_size) sizeof(*in), in };
+	struct acpi_buffer return_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *acpi_object_out;
+	acpi_status status;
+
+	mutex_lock(&nb05_wmi_aa_access_lock);
+
+	pr_debug("evaluate: %u\n", wmi_method_id);
+	status = wmidev_evaluate_method(wdev, 0, wmi_method_id,
+					&acpi_buffer_in, &return_buffer);
+
+	mutex_unlock(&nb05_wmi_aa_access_lock);
+
+	if (ACPI_FAILURE(status)) {
+		pr_err("failed to evaluate wmi method %u\n", wmi_method_id);
+		return -EIO;
+	}
+
+	acpi_object_out = (union acpi_object *) return_buffer.pointer;
+	if (!acpi_object_out)
+		return -ENODATA;
+
+	if (acpi_object_out->type != ACPI_TYPE_INTEGER) {
+		pr_err("No integer for method (%u) call\n", wmi_method_id);
+		kfree(return_buffer.pointer);
+		return -EIO;
+	}
+
+	*out = acpi_object_out->integer.value;
+	kfree(return_buffer.pointer);
+
+	return 0;
+}
+
+static int nb05_wmi_aa_method(u32 wmi_method_id, u64 *in, u64 *out)
+{
+	if (__wmi_dev)
+		return __nb05_wmi_aa_method(__wmi_dev, wmi_method_id, in, out);
+	else
+		return -ENODEV;
+}
+
+static int write_profile(u64 profile)
+{
+	u64 out = 0;
+	profile_changed_timer_bump();
+	int err = nb05_wmi_aa_method(1, &profile, &out);
+	if (err)
+		return err;
+	else if (out)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int read_profile(u64 *profile)
+{
+	u64 in;
+	int err = nb05_wmi_aa_method(2, &in, profile);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static ssize_t platform_profile_choices_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buffer);
+
+static ssize_t platform_profile_show(struct device *dev,
+				     struct device_attribute *attr, char *buffer);
+
+static ssize_t platform_profile_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size);
+
+struct platform_profile_attrs_t {
+	struct device_attribute platform_profile_choices;
+	struct device_attribute platform_profile;
+};
+
+struct platform_profile_attrs_t platform_profile_attrs = {
+	.platform_profile_choices = __ATTR(platform_profile_choices, 0444,
+					   platform_profile_choices_show, NULL),
+	.platform_profile = __ATTR(platform_profile, 0644,
+				   platform_profile_show, platform_profile_store)
+};
+
+static struct attribute *platform_profile_attrs_list[] = {
+	&platform_profile_attrs.platform_profile_choices.attr,
+	&platform_profile_attrs.platform_profile.attr,
+	NULL
+};
+
+static struct attribute_group platform_profile_attr_group = {
+	.attrs = platform_profile_attrs_list
+};
+
+struct char_to_value_t {
+	char* descriptor;
+	u64 value;
+};
+
+static struct char_to_value_t platform_profile_options[] = {
+	{ .descriptor = "low-power",		.value = 2 },
+	{ .descriptor = "balanced",		.value = 0 },
+	{ .descriptor = "performance",		.value = 1 }
+};
+
+static ssize_t platform_profile_choices_show(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buffer)
+{
+	int i, n;
+	n = ARRAY_SIZE(platform_profile_options);
+	for (i = 0; i < n; ++i) {
+		sprintf(buffer + strlen(buffer), "%s",
+			platform_profile_options[i].descriptor);
+		if (i < n - 1)
+			sprintf(buffer + strlen(buffer), " ");
+		else
+			sprintf(buffer + strlen(buffer), "\n");
+	}
+
+	return strlen(buffer);
+}
+
+static ssize_t platform_profile_show(struct device *dev,
+				     struct device_attribute *attr, char *buffer)
+{
+	u64 platform_profile_value;
+	int i, err;
+
+	err = read_profile(&platform_profile_value);
+	if (err) {
+		pr_err("Error reading power profile");
+		return -EIO;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(platform_profile_options); ++i)
+		if (platform_profile_options[i].value == platform_profile_value) {
+			sprintf(buffer, "%s\n", platform_profile_options[i].descriptor);
+			return strlen(buffer);
+		}
+
+	pr_err("Read platform profile value not matched to a descriptor\n");
+
+	return -EIO;
+}
+
+static int rewrite_last_profile_internal(void)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(&__wmi_dev->dev);
+	u64 current_profile;
+	int err;
+
+	err = read_profile(&current_profile);
+	if (err)
+		return err;
+
+	if (current_profile != driver_data->last_chosen_profile) {
+		err = write_profile(driver_data->last_chosen_profile);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+void rewrite_last_profile(void)
+{
+	schedule_work(&nb05_rewrite_profile_work);
+}
+EXPORT_SYMBOL(rewrite_last_profile);
+
+bool profile_changed_by_driver(void)
+{
+	return profile_changed_by_driver_flag;
+}
+EXPORT_SYMBOL(profile_changed_by_driver);
+
+static ssize_t platform_profile_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct wmi_device *wdev = dev_to_wdev(pdev->dev.parent);
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+	u64 platform_profile_value;
+	int i, err;
+	char *buffer_copy;
+	char *platform_profile_descriptor;
+
+	buffer_copy = kmalloc(size + 1, GFP_KERNEL);
+	strcpy(buffer_copy, buffer);
+	platform_profile_descriptor = strstrip(buffer_copy);
+
+	for (i = 0; i < ARRAY_SIZE(platform_profile_options); ++i)
+		if (strcmp(platform_profile_options[i].descriptor, platform_profile_descriptor) == 0) {
+			platform_profile_value = platform_profile_options[i].value;
+			break;
+		}
+
+	kfree(buffer_copy);
+
+	if (i < ARRAY_SIZE(platform_profile_options)) {
+		// Option found try to set
+		err = write_profile(platform_profile_value);
+		if (err)
+			return err;
+		
+		driver_data->last_chosen_profile = platform_profile_value;
+		return size;
+	} else {
+		// Invalid input, not matched to an option
+		return -EINVAL;
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int tuxedo_nb05_power_profiles_probe(struct wmi_device *wdev)
+#else
+static int tuxedo_nb05_power_profiles_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	int err;
+	struct driver_data_t *driver_data;
+
+	pr_debug("driver probe\n");
+
+	__wmi_dev = wdev;
+
+	if (!tuxedo_is_compatible())
+		return -ENODEV;
+
+	if (!wmi_has_guid(NB05_WMI_METHOD_BA_GUID))
+		return -ENODEV;
+
+	driver_data = devm_kzalloc(&wdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&wdev->dev, driver_data);
+
+	// Initialize last chosen profile
+	err = read_profile(&driver_data->last_chosen_profile);
+	if (err) {
+		pr_err("Error reading power profile");
+		return -EIO;
+	}
+
+	const struct platform_device_info pinfo = {
+		.name = "tuxedo_platform_profile",
+		.id = PLATFORM_DEVID_NONE,
+		.parent = &wdev->dev
+	};
+
+	driver_data->pdev = platform_device_register_full(&pinfo);
+	if (PTR_ERR_OR_ZERO(driver_data->pdev)) {
+		pr_err("platform device creation failed\n");
+		return -ENOMEM;
+	}
+
+	err = sysfs_create_group(&driver_data->pdev->dev.kobj, &platform_profile_attr_group);
+	if (err) {
+		pr_err("create group failed\n");
+		platform_device_unregister(driver_data->pdev);
+		return err;
+	}
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int tuxedo_nb05_power_profiles_remove(struct wmi_device *wdev)
+#else
+static void tuxedo_nb05_power_profiles_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	timer_delete(&profile_changed_timer);
+	struct driver_data_t *driver_data = dev_get_drvdata(&wdev->dev);
+	sysfs_remove_group(&driver_data->pdev->dev.kobj, &platform_profile_attr_group);
+	platform_device_unregister(driver_data->pdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static const struct wmi_device_id tuxedo_nb05_power_profiles_device_ids[] = {
+	{ .guid_string = NB05_WMI_METHOD_BA_GUID },
+	{ }
+};
+
+static struct wmi_driver tuxedo_nb05_power_profiles_driver = {
+	.driver = {
+		.name = "tuxedo_nb05_power_profiles",
+		.owner = THIS_MODULE
+	},
+	.id_table = tuxedo_nb05_power_profiles_device_ids,
+	.probe = tuxedo_nb05_power_profiles_probe,
+	.remove = tuxedo_nb05_power_profiles_remove,
+};
+
+module_wmi_driver(tuxedo_nb05_power_profiles_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for NB05 power profiles");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(wmi, tuxedo_nb05_power_profiles_device_ids);
+MODULE_ALIAS("wmi:" NB05_WMI_METHOD_BA_GUID);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_power_profiles.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXEDO_NB05_POWER_PROFILES_H
+#define TUXEDO_NB05_POWER_PROFILES_H
+void rewrite_last_profile(void);
+bool profile_changed_by_driver(void);
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_sensors.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_sensors.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_sensors.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_nb05/tuxedo_nb05_sensors.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,231 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2023-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/module.h>
+#include <linux/hwmon.h>
+#include <linux/platform_device.h>
+#include <linux/dmi.h>
+#include "tuxedo_nb05_ec.h"
+
+static int read_cpu_temp(void)
+{
+	u8 cpu_temp;
+	nb05_read_ec_ram(0x470, &cpu_temp);
+	return cpu_temp;
+}
+
+static int read_fan1_rpm(void)
+{
+	u8 rpm_low, rpm_high;
+	nb05_read_ec_ram(0x298, &rpm_high);
+	nb05_read_ec_ram(0x298, &rpm_low);
+	return (rpm_high << 8) | rpm_low;
+}
+
+static int read_fan2_rpm(void)
+{
+	u8 rpm_low, rpm_high;
+	nb05_read_ec_ram(0x218, &rpm_high);
+	nb05_read_ec_ram(0x219, &rpm_low);
+	return (rpm_high << 8) | rpm_low;
+}
+
+static const char * const temp_labels[] = {
+	"cpu0"
+};
+
+static const char * const fan_labels[] = {
+	"cpu0",
+	"cpu1"
+};
+
+struct driver_data_t {
+	int fan_cpu_max;
+	int fan_cpu_min;
+	int number_fans;
+};
+
+struct driver_data_t driver_data;
+
+static umode_t
+tuxedo_nb05_hwmon_is_visible(const void *drvdata, enum hwmon_sensor_types type,
+			     u32 attr, int channel)
+{
+	struct driver_data_t *driver_data = (struct driver_data_t *) drvdata;
+
+	switch (type) {
+	case hwmon_temp:
+		return 0444;
+	case hwmon_fan:
+		if (channel < driver_data->number_fans)
+			return 0444;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int
+tuxedo_nb05_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+		       u32 attr, int channel, long *val)
+{
+	struct driver_data_t *driver_data = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_temp:
+		*val = read_cpu_temp() * 1000;
+		return 0;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_min:
+			if (channel == 0) {
+				*val = driver_data->fan_cpu_min;
+				return 0;
+			} else if (channel == 1) {
+				*val = driver_data->fan_cpu_min;
+				return 0;
+			}
+			break;
+		case hwmon_fan_max:
+			if (channel == 0) {
+				*val = driver_data->fan_cpu_max;
+				return 0;
+			} else if (channel == 1) {
+				*val = driver_data->fan_cpu_max;
+				return 0;
+			}
+			break;
+		case hwmon_fan_input:
+			if (channel == 0) {
+				*val = read_fan1_rpm();
+				return 0;
+			} else if (channel == 1) {
+				*val = read_fan2_rpm();
+				return 0;
+			}
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int
+tuxedo_nb05_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
+			      u32 attr, int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_temp:
+		*str = temp_labels[channel];
+		return 0;
+	case hwmon_fan:
+		*str = fan_labels[channel];
+		return 0;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops tuxedo_nb05_hwmon_ops = {
+	.is_visible = tuxedo_nb05_hwmon_is_visible,
+	.read = tuxedo_nb05_hwmon_read,
+	.read_string = tuxedo_nb05_hwmon_read_string
+};
+
+static const struct hwmon_channel_info *const tuxedo_nb05_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX),
+	NULL
+};
+
+static const struct hwmon_chip_info tuxedo_nb05_hwmon_chip_info = {
+	.ops = &tuxedo_nb05_hwmon_ops,
+	.info = tuxedo_nb05_hwmon_info
+};
+
+static int __init tuxedo_nb05_sensors_probe(struct platform_device *pdev) {
+	struct device *hwmon_dev;
+	const struct dmi_system_id *sysid;
+
+	pr_debug("driver_probe\n");
+
+	sysid = nb05_match_device();
+	if (!sysid)
+		return -ENODEV;
+
+	driver_data.fan_cpu_min = 0;
+
+	if (!strcmp(sysid->ident, IFLX14I01)) {
+		driver_data.number_fans = 1;
+		driver_data.fan_cpu_max = 5600;
+	} else {
+		driver_data.number_fans = 2;
+		driver_data.fan_cpu_max = 5400;
+	}
+
+	hwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev,
+							 "tuxedo",
+							 &driver_data,
+							 &tuxedo_nb05_hwmon_chip_info,
+							 NULL);
+
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static struct platform_device *tuxedo_nb05_sensors_device;
+static struct platform_driver tuxedo_nb05_sensors_driver = {
+	.driver.name = "tuxedo_nb05_sensors",
+};
+
+static int __init tuxedo_nb05_sensors_init(void)
+{
+	tuxedo_nb05_sensors_device =
+		platform_create_bundle(&tuxedo_nb05_sensors_driver,
+				       tuxedo_nb05_sensors_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_nb05_sensors_device))
+		return PTR_ERR(tuxedo_nb05_sensors_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_nb05_sensors_exit(void)
+{
+	platform_device_unregister(tuxedo_nb05_sensors_device);
+	platform_driver_unregister(&tuxedo_nb05_sensors_driver);
+}
+
+module_init(tuxedo_nb05_sensors_init);
+module_exit(tuxedo_nb05_sensors_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers NB05 sensors driver");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/Kbuild linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/Kbuild
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/Kbuild	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,2 @@
+obj-m += tuxi_acpi.o
+obj-m += tuxedo_tuxi_fan_control.o
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxedo_tuxi_fan_control.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxedo_tuxi_fan_control.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxedo_tuxi_fan_control.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxedo_tuxi_fan_control.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,432 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dmi.h>
+#include <linux/version.h>
+#include <linux/hwmon.h>
+#include "tuxi_acpi.h"
+
+#define FAN_SET_DUTY_MAX 255
+#define FAN_ON_MIN_SPEED_PERCENT 25
+
+struct driver_data_t {
+	struct platform_device *pdev;
+};
+
+static ssize_t fan1_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer);
+
+static ssize_t fan1_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size);
+
+static ssize_t fan1_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer);
+
+static ssize_t fan1_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size);
+
+static ssize_t fan2_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer);
+
+static ssize_t fan2_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size);
+
+static ssize_t fan2_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer);
+
+static ssize_t fan2_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size);
+
+struct fan_control_attrs_t {
+	struct device_attribute fan1_pwm;
+	struct device_attribute fan1_pwm_enable;
+	struct device_attribute fan2_pwm;
+	struct device_attribute fan2_pwm_enable;
+};
+
+struct fan_control_attrs_t fan_control_attrs = {
+	.fan1_pwm = __ATTR(fan1_pwm, 0644, fan1_pwm_show, fan1_pwm_store),
+	.fan1_pwm_enable = __ATTR(fan1_pwm_enable, 0644, fan1_pwm_enable_show, fan1_pwm_enable_store),
+	.fan2_pwm = __ATTR(fan2_pwm, 0644, fan2_pwm_show, fan2_pwm_store),
+	.fan2_pwm_enable = __ATTR(fan2_pwm_enable, 0644, fan2_pwm_enable_show, fan2_pwm_enable_store),
+};
+
+static struct attribute *fan_control_attrs_list[] = {
+	&fan_control_attrs.fan1_pwm.attr,
+	&fan_control_attrs.fan1_pwm_enable.attr,
+	&fan_control_attrs.fan2_pwm.attr,
+	&fan_control_attrs.fan2_pwm_enable.attr,
+	NULL
+};
+
+static struct attribute_group fan_control_attr_group = {
+	.attrs = fan_control_attrs_list
+};
+
+static ssize_t fan1_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer)
+{
+	u8 pwm_data, duty_data;
+	duty_data = tuxi_get_fan_speed(0, &duty_data);
+	pwm_data = (duty_data * 0xff) / FAN_SET_DUTY_MAX;
+	sysfs_emit(buffer, "%d\n", pwm_data);
+	return strlen(buffer);
+}
+
+static ssize_t fan1_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size)
+{
+	u8 pwm_data, duty_data;
+	int err;
+
+	if (kstrtou8(buffer, 0, &pwm_data))
+		return -EINVAL;
+
+	duty_data = (pwm_data * FAN_SET_DUTY_MAX) / 0xff;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (duty_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 2 / 100)
+		duty_data = 0;
+	else if (duty_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100)
+		duty_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100;
+
+	err = tuxi_set_fan_speed(0, duty_data);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static ssize_t fan1_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer)
+{
+	enum tuxi_fan_mode mode;
+	u8 enable_hwmon;
+	int err;
+
+	err = tuxi_get_fan_mode(&mode);
+	if (mode == MANUAL) {
+		enable_hwmon = 1;
+	} else {
+		enable_hwmon = 2;
+	}
+	sysfs_emit(buffer, "%d\n", enable_hwmon);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan1_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size)
+{
+	enum tuxi_fan_mode mode;
+	u8 enable_hwmon;
+	int err;
+
+	if (kstrtou8(buffer, 0, &enable_hwmon))
+		return -EINVAL;
+
+	if (enable_hwmon == 1)
+		mode = MANUAL;
+	else
+		mode = AUTO;
+
+	err = tuxi_set_fan_mode(mode);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static ssize_t fan2_pwm_show(struct device *dev,
+			     struct device_attribute *attr, char *buffer)
+{
+	u8 pwm_data, duty_data;
+	duty_data = tuxi_get_fan_speed(1, &duty_data);
+	pwm_data = (duty_data * 0xff) / FAN_SET_DUTY_MAX;
+	sysfs_emit(buffer, "%d\n", pwm_data);
+	return strlen(buffer);
+}
+
+static ssize_t fan2_pwm_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buffer, size_t size)
+{
+	u8 pwm_data, duty_data;
+	int err;
+
+	if (kstrtou8(buffer, 0, &pwm_data))
+		return -EINVAL;
+
+	duty_data = (pwm_data * FAN_SET_DUTY_MAX) / 0xff;
+
+	// Don't allow vallues between fan-off and minimum fan-on-speed
+	if (duty_data <= FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 2 / 100)
+		duty_data = 0;
+	else if (duty_data < FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100)
+		duty_data = FAN_ON_MIN_SPEED_PERCENT * FAN_SET_DUTY_MAX / 100;
+
+	err = tuxi_set_fan_speed(1, duty_data);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static ssize_t fan2_pwm_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buffer)
+{
+	enum tuxi_fan_mode mode;
+	u8 enable_hwmon;
+	int err;
+
+	err = tuxi_get_fan_mode(&mode);
+	if (mode == MANUAL) {
+		enable_hwmon = 1;
+	} else {
+		enable_hwmon = 2;
+	}
+	sysfs_emit(buffer, "%d\n", enable_hwmon);
+
+	return strlen(buffer);
+}
+
+static ssize_t fan2_pwm_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size)
+{
+	enum tuxi_fan_mode mode;
+	u8 enable_hwmon;
+	int err;
+
+	if (kstrtou8(buffer, 0, &enable_hwmon))
+		return -EINVAL;
+
+	if (enable_hwmon == 1)
+		mode = MANUAL;
+	else
+		mode = AUTO;
+
+	err = tuxi_set_fan_mode(mode);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static umode_t
+hwm_is_visible(const void __always_unused *drvdata,
+	       enum hwmon_sensor_types __always_unused type,
+	       u32 __always_unused attr, int __always_unused channel)
+{
+	return 0444;
+}
+
+static int
+hwm_read(struct device __always_unused *dev, enum hwmon_sensor_types type,
+	 u32 __always_unused attr, int channel, long *val)
+{
+	int err;
+	u16 temp;
+	u16 rpm;
+
+	switch (type) {
+	case hwmon_temp:
+		err = tuxi_get_fan_temp(channel, &temp);
+		if (err)
+			return err;
+		*val = (temp - 2730) * 100; // temp is in tenth Kelvin, hovever
+					    // the last digit is always 0, so
+					    // the conversion is also rounded to
+					    // whole C.
+		return 0;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_min:
+			*val = 0;
+			return 0;
+		case hwmon_fan_max:
+			*val = 6000; // FIXME Return value read from firmware.
+			return 0;
+		case hwmon_fan_input:
+			err = tuxi_get_fan_rpm(channel, &rpm);
+			if (err)
+				return err;
+			*val = rpm;
+			return 0;
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static const char * const hwm_temp_labels[] = {
+	"cpu0",
+	"gpu0"
+};
+
+static const char * const hwm_fan_labels[] = {
+	"cpu0",
+	"gpu0"
+};
+
+static int
+hwm_read_string(struct device __always_unused *dev,
+		enum hwmon_sensor_types type, u32 __always_unused attr,
+		int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_temp:
+		*str = hwm_temp_labels[channel];
+		return 0;
+	case hwmon_fan:
+		*str = hwm_fan_labels[channel];
+		return 0;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops hwmops = {
+	.is_visible = hwm_is_visible,
+	.read = hwm_read,
+	.read_string = hwm_read_string
+};
+
+static const struct hwmon_channel_info *const hwmcinfo[] = {
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_LABEL,
+			   HWMON_T_INPUT | HWMON_T_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX,
+			   HWMON_F_INPUT | HWMON_F_LABEL | HWMON_F_MIN | HWMON_F_MAX),
+	NULL
+};
+
+static const struct hwmon_chip_info hwminfo = {
+	.ops = &hwmops,
+	.info = hwmcinfo
+};
+
+static int __init tuxedo_tuxi_fan_control_probe(struct platform_device *pdev)
+{
+	int err;
+	u16 temp, rpm;
+	struct device *hwmdev;
+	struct driver_data_t *driver_data = devm_kzalloc(&pdev->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	pr_debug("driver probe\n");
+
+	dev_set_drvdata(&pdev->dev, driver_data);
+
+	driver_data->pdev = pdev;
+
+	err = sysfs_create_group(&driver_data->pdev->dev.kobj, &fan_control_attr_group);
+	if (err) {
+		pr_err("create group failed\n");
+		platform_device_unregister(driver_data->pdev);
+		return err;
+	}
+
+	if(tuxi_get_fan_temp(0, &temp) == 0 && tuxi_get_fan_rpm(0, &rpm) == 0) {
+		hwmdev = devm_hwmon_device_register_with_info(&pdev->dev,
+							      "tuxedo_tuxi_sensors",
+							      NULL,
+							      &hwminfo,
+							      NULL);
+		return PTR_ERR_OR_ZERO(hwmdev);
+	}
+	pr_debug("Old tuxi interface with missing temp and rpm functions detected.\n");
+	pr_debug("Skipping hwmon creation.\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int tuxedo_tuxi_fan_control_remove(struct platform_device *pdev)
+#else
+static void tuxedo_tuxi_fan_control_remove(struct platform_device *pdev)
+#endif
+{
+	pr_debug("driver remove\n");
+	struct driver_data_t *driver_data = dev_get_drvdata(&pdev->dev);
+	sysfs_remove_group(&driver_data->pdev->dev.kobj, &fan_control_attr_group);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static struct platform_device *tuxedo_tuxi_fan_control_device;
+static struct platform_driver tuxedo_tuxi_fan_control_driver = {
+	.driver.name = "tuxedo_fan_control",
+	.remove = tuxedo_tuxi_fan_control_remove,
+};
+
+static int __init tuxedo_tuxi_fan_control_init(void)
+{
+	int err;
+	u8 dummy;
+
+	// Check interface presence
+	err = tuxi_get_nr_fans(&dummy);
+	if (err == -ENODEV)
+		return err;
+
+	tuxedo_tuxi_fan_control_device =
+		platform_create_bundle(&tuxedo_tuxi_fan_control_driver,
+				       tuxedo_tuxi_fan_control_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(tuxedo_tuxi_fan_control_device))
+		return PTR_ERR(tuxedo_tuxi_fan_control_device);
+
+	return 0;
+}
+
+static void __exit tuxedo_tuxi_fan_control_exit(void)
+{
+	platform_device_unregister(tuxedo_tuxi_fan_control_device);
+	platform_driver_unregister(&tuxedo_tuxi_fan_control_driver);
+}
+
+module_init(tuxedo_tuxi_fan_control_init);
+module_exit(tuxedo_tuxi_fan_control_exit);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("TUXEDO Computers TUXI fan control driver");
+MODULE_LICENSE("GPL");
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,378 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/version.h>
+#include "tuxi_acpi.h"
+
+#define DRIVER_NAME "tuxi_acpi"
+
+struct tuxi_acpi_driver_data_t {
+	struct acpi_device *tuxi_adev;
+	acpi_handle tfan_handle;
+};
+
+static struct tuxi_acpi_driver_data_t *tuxi_driver_data = NULL;
+
+static
+int evaluate_intparams(acpi_handle handle,
+		       acpi_string pathname,
+		       unsigned long long *int_params,
+		       u32 param_count,
+		       unsigned long long *retval);
+
+static
+int evaluate_intparams(acpi_handle handle,
+		       acpi_string pathname,
+		       unsigned long long *int_params,
+		       u32 param_count,
+		       unsigned long long *retval)
+{
+	struct acpi_object_list input;
+	union acpi_object *params;
+	unsigned long long result;
+	acpi_status status;
+	int i;
+	u32 param_buffer_size = sizeof(union acpi_object) * param_count;
+
+	if (!handle)
+		return -ENODEV;
+
+	if (param_buffer_size > 0)
+		params = kzalloc(param_buffer_size, GFP_KERNEL);
+
+	for (i = 0; i < param_count; ++i) {
+		params[i].type = ACPI_TYPE_INTEGER;
+		params[i].integer.value = int_params[i];
+	}
+
+	input.count = param_count;
+	input.pointer = params;
+
+	if (param_buffer_size > 0) {
+		status = acpi_evaluate_integer(handle, pathname, &input, &result);
+		kfree(params);
+	} else {
+		status = acpi_evaluate_integer(handle, pathname, NULL, &result);
+	}
+
+	if (ACPI_FAILURE(status))
+		return -EIO;
+
+	if (retval)
+		*retval = result;
+
+	return 0;
+}
+
+int tuxi_set_fan_speed(u8 fan_index, u8 fan_speed)
+{
+	long long int retval;
+	long long int args[] = { fan_index, fan_speed };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "SSPD",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_set_fan_speed);
+
+int tuxi_get_fan_speed(u8 fan_index, u8 *fan_speed)
+{
+	long long int retval;
+	long long int args[] = { fan_index };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GSPD",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	*fan_speed = (u8) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_fan_speed);
+
+int tuxi_get_nr_fans(u8 *nr_fans)
+{
+	long long int retval;
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GCNT",
+				 NULL, 0,
+				 &retval);
+	if (err)
+		return err;
+
+	*nr_fans = (u8) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_nr_fans);
+
+int tuxi_set_fan_mode(enum tuxi_fan_mode mode)
+{
+	long long int retval;
+	long long int args[] = { mode };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "SMOD",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_set_fan_mode);
+
+int tuxi_get_fan_mode(enum tuxi_fan_mode *mode)
+{
+	long long int retval;
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GMOD",
+				 NULL, 0,
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	*mode = (u8) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_fan_mode);
+
+int tuxi_get_fan_type(u8 fan_index, enum tuxi_fan_type *type)
+{
+	long long int retval;
+	long long int args[] = { fan_index };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GTYP",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	*type = (u8) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_fan_type);
+
+int tuxi_get_fan_temp(u8 index, u16 *temp)
+{
+	unsigned long long int retval;
+	long long int args[] = { index };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GTMP",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	*temp = (u16) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_fan_temp);
+
+int tuxi_get_fan_rpm(u8 index, u16 *rpm)
+{
+	unsigned long long int retval;
+	long long int args[] = { index };
+	int err;
+
+	if (tuxi_driver_data == NULL)
+		return -ENODEV;
+
+	err = evaluate_intparams(tuxi_driver_data->tfan_handle,
+				 "GRPM",
+				 args, ARRAY_SIZE(args),
+				 &retval);
+	if (err)
+		return err;
+
+	if (retval < 0)
+		return -EINVAL;
+
+	*rpm = (u16) retval;
+
+	return 0;
+}
+EXPORT_SYMBOL(tuxi_get_fan_rpm);
+
+static int get_tfan(struct acpi_device *tuxi_dev, acpi_handle *tfan_handle)
+{
+	acpi_status status;
+	status = acpi_get_handle(tuxi_dev->handle, "TFAN", tfan_handle);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+	return 0;
+}
+
+static int tuxi_acpi_add(struct acpi_device *device)
+{
+	struct tuxi_acpi_driver_data_t *driver_data;
+	int err;
+
+	driver_data = devm_kzalloc(&device->dev, sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data)
+		return -ENOMEM;
+
+	driver_data->tuxi_adev = device;
+	device->driver_data = driver_data;
+
+	// Find subdevices
+	err = get_tfan(device, &driver_data->tfan_handle);
+	if (err)
+		driver_data->tfan_handle = NULL;
+
+	if (!driver_data->tfan_handle)
+		pr_info("no interface found\n");
+
+	tuxi_driver_data = driver_data;
+
+	pr_info("interface initialized\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+static int tuxi_acpi_remove(struct acpi_device *device)
+#else
+static void tuxi_acpi_remove(struct acpi_device *device)
+#endif
+{
+	tuxi_driver_data = NULL;
+	pr_debug("driver remove\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+	return 0;
+#endif
+}
+
+static void tuxi_acpi_notify(struct acpi_device *device, u32 event)
+{
+	pr_debug("event: %d\n", event);
+}
+
+#ifdef CONFIG_PM
+static int driver_suspend_callb(struct device *dev)
+{
+	pr_debug("driver suspend\n");
+	return 0;
+}
+
+static int driver_resume_callb(struct device *dev)
+{
+	pr_debug("driver resume\n");
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(tuxi_driver_pm_ops, driver_suspend_callb, driver_resume_callb);
+#endif
+
+static const struct acpi_device_id tuxi_acpi_device_ids[] = {
+	{ TUXI_ACPI_RESOURCE_HID, 0 },
+	{ "", 0 }
+};
+
+static struct acpi_driver tuxi_acpi_driver = {
+	.name = DRIVER_NAME,
+	.class = DRIVER_NAME,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 10, 0)
+	.owner = THIS_MODULE,
+#endif
+	.ids = tuxi_acpi_device_ids,
+	.flags = ACPI_DRIVER_ALL_NOTIFY_EVENTS,
+	.ops = {
+		.add = tuxi_acpi_add,
+		.remove = tuxi_acpi_remove,
+		.notify = tuxi_acpi_notify,
+	},
+#ifdef CONFIG_PM
+	.drv.pm = &tuxi_driver_pm_ops
+#endif
+};
+
+module_acpi_driver(tuxi_acpi_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for TUXEDO ACPI interface");
+MODULE_LICENSE("GPL");
+
+MODULE_DEVICE_TABLE(acpi, tuxi_acpi_device_ids);
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/tuxedo_tuxi/tuxi_acpi.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef TUXI_ACPI_H
+#define TUXI_ACPI_H
+
+#define TUXI_ACPI_RESOURCE_HID "TUXI0000"
+
+MODULE_ALIAS("acpi*:" TUXI_ACPI_RESOURCE_HID ":*");
+
+enum tuxi_fan_type {
+	GENERAL = 0,
+	CPU = 1,
+	GPU = 2,
+};
+
+enum tuxi_fan_mode {
+	AUTO = 0,
+	MANUAL = 1,
+};
+
+int tuxi_set_fan_speed(u8 fan_index, u8 fan_speed);
+int tuxi_get_fan_speed(u8 fan_index, u8 *fan_speed);
+int tuxi_get_nr_fans(u8 *nr_fans);
+int tuxi_set_fan_mode(enum tuxi_fan_mode mode);
+int tuxi_get_fan_mode(enum tuxi_fan_mode *mode);
+int tuxi_get_fan_type(u8 fan_index, enum tuxi_fan_type *type);
+int tuxi_get_fan_temp(u8 index, u16 *temp);
+int tuxi_get_fan_rpm(u8 index, u16 *rpm);
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_interfaces.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_interfaces.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_interfaces.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_interfaces.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,186 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2021-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef UNIWILL_INTERFACES_H
+#define UNIWILL_INTERFACES_H
+
+#include <linux/types.h>
+
+#define UNIWILL_WMI_MGMT_GUID_BA	"ABBC0F6D-8EA1-11D1-00A0-C90629100000"
+#define UNIWILL_WMI_MGMT_GUID_BB	"ABBC0F6E-8EA1-11D1-00A0-C90629100000"
+#define UNIWILL_WMI_MGMT_GUID_BC	"ABBC0F6F-8EA1-11D1-00A0-C90629100000"
+
+#define UNIWILL_WMI_EVENT_GUID_0	"ABBC0F70-8EA1-11D1-00A0-C90629100000"
+#define UNIWILL_WMI_EVENT_GUID_1	"ABBC0F71-8EA1-11D1-00A0-C90629100000"
+#define UNIWILL_WMI_EVENT_GUID_2	"ABBC0F72-8EA1-11D1-00A0-C90629100000"
+
+#define UNIWILL_WMI_FUNCTION_WRITE			0
+#define UNIWILL_WMI_FUNCTION_READ			1
+#define UNIWILL_WMI_FUNCTION_FEATURE_TOGGLE		5
+
+#define UNIWILL_WMI_LOCAL_DIMMING_ON			0x0E
+#define UNIWILL_WMI_LOCAL_DIMMING_OFF			0x0D
+
+#define MODULE_ALIAS_UNIWILL_WMI() \
+	MODULE_ALIAS("wmi:" UNIWILL_WMI_EVENT_GUID_2); \
+	MODULE_ALIAS("wmi:" UNIWILL_WMI_MGMT_GUID_BC);
+
+#define UNIWILL_INTERFACE_WMI_STRID "uniwill_wmi"
+
+typedef int (uniwill_read_ec_ram_t)(u16, u8*);
+typedef int (uniwill_read_ec_ram_with_retry_t)(u16, u8*, int);
+typedef int (uniwill_write_ec_ram_t)(u16, u8);
+typedef int (uniwill_wmi_evaluate_t)(u8 function, u32 arg, u32 *return_buffer);
+typedef int (uniwill_write_ec_ram_with_retry_t)(u16, u8, int);
+typedef void (uniwill_event_callb_t)(u32);
+
+// UW_EC_REG_* known relevant EC address exposing some information or function
+// UW_EC_REG_*_BIT_* single bit from byte holding information, should be handled with bit-wise operations
+// UW_EC_REG_*_VALUE_* discrete value of the whole byte with special meaning
+// UW_EC_REG_*_SUBCMD_* writing this discrete value triggers special behaviour
+
+#define UW_EC_REG_KBD_BL_STATUS				0x078c
+#define UW_EC_REG_KBD_BL_STATUS_BIT_WHITE_ONLY_KB	0x01
+#define UW_EC_REG_KBD_BL_STATUS_SUBCMD_RESET		0x10
+
+#define UW_EC_REG_KBD_BL_MAX_BRIGHTNESS_IMMEDIATE	0x1801
+#define UW_EC_REG_KBD_BL_WHITE_BRIGHTNESS_IMMEDIATE	0x1802
+#define UW_EC_REG_KBD_BL_RGB_RED_BRIGHTNESS_IMMEDIATE	0x1803
+#define UW_EC_REG_KBD_BL_RGB_GREEN_BRIGHTNESS_IMMEDIATE	0x1805
+#define UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS_IMMEDIATE	0x1808
+
+#define UW_EC_REG_KBD_BL_RGB_MODE			0x0767
+#define UW_EC_REG_KBD_BL_RGB_MODE_BIT_APPLY_COLOR	0x20
+#define UW_EC_REG_KBD_BL_RGB_MODE_BIT_RAINBOW		0x80
+#define UW_EC_REG_KBD_BL_RGB_RED_BRIGHTNESS		0x0769
+#define UW_EC_REG_KBD_BL_RGB_GREEN_BRIGHTNESS		0x076a
+#define UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS		0x076b
+
+#define UW_EC_REG_KBD_FN_LOCK_STATUS_BIT		0x074e
+
+#define UW_EC_REG_CUSTOM_PROFILE			0x0727
+#define UW_EC_REG_AC_AUTO_BOOT_STATUS			0x0726
+#define UW_EC_REG_USB_POWERSHARE_STATUS			0x0767
+#define UW_EC_REG_MINI_LED_LOCAL_DIMMING_SUPPORT	0x0D4F
+
+#define UW_EC_REG_FAN_CTRL_STATUS			0x078e
+#define UW_EC_REG_FAN_CTRL_STATUS_BIT_HAS_UW_FAN_CTRL	0x40
+
+#define UW_EC_REG_CTGP_DB_ENABLE			0x0743
+#define UW_EC_REG_CTGP_DB_ENABLE_BIT_GENERAL_ENABLE	0x01
+#define UW_EC_REG_CTGP_DB_ENABLE_BIT_DB_ENABLE		0x02
+#define UW_EC_REG_CTGP_DB_ENABLE_BIT_CTGP_ENABLE	0x04
+#define UW_EC_REG_CTGP_DB_CTGP_OFFSET			0x0744
+#define UW_EC_REG_CTGP_DB_TPP_OFFSET			0x0745
+#define UW_EC_REG_CTGP_DB_DB_OFFSET			0x0746
+
+#define UW_EC_REG_BAREBONE_ID				0x0740
+#define UW_EC_REG_BAREBONE_ID_VALUE_PFxxxxx		0x09
+#define UW_EC_REG_BAREBONE_ID_VALUE_PFxMxxx		0x0e
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH4TRX1		0x12
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH4TUX1		0x13
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH4TQx1		0x14
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH6TRX1		0x15
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH6TQxx		0x16
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH4Axxx		0x17
+#define UW_EC_REG_BAREBONE_ID_VALUE_PH4Pxxx		0x18
+
+#define UW_EC_REG_FEATURES_0				0x0765
+#define UW_EC_REG_FEATURES_1				0x0766
+#define UW_EC_REG_FEATURES_1_BIT_1_ZONE_RGB_KB		BIT(2)
+#define UW_EC_REG_FEATURES_1_BIT_FIXED_COLOR_5_ENABLE	BIT(5)
+
+#define UW_EC_REG_ROMID_START				0x0770
+#define UW_EC_REG_ROMID_SPECIAL_1			0x077e
+#define UW_EC_REG_ROMID_SPECIAL_2			0x077f
+
+struct uniwill_interface_t {
+	char *string_id;
+	uniwill_event_callb_t *event_callb;
+	uniwill_read_ec_ram_t *read_ec_ram;
+	uniwill_write_ec_ram_t *write_ec_ram;
+	uniwill_wmi_evaluate_t *wmi_evaluate;
+};
+
+int uniwill_add_interface(struct uniwill_interface_t *new_interface);
+int uniwill_remove_interface(struct uniwill_interface_t *interface);
+uniwill_read_ec_ram_t uniwill_read_ec_ram;
+uniwill_write_ec_ram_t uniwill_write_ec_ram;
+uniwill_wmi_evaluate_t uniwill_wmi_evaluate;
+uniwill_write_ec_ram_with_retry_t uniwill_write_ec_ram_with_retry;
+uniwill_read_ec_ram_with_retry_t uniwill_read_ec_ram_with_retry;
+int uniwill_get_active_interface_id(char **id_str);
+
+#define UW_MODEL_PF5LUXG	0x09
+#define UW_MODEL_PH4TUX		0x13
+#define UW_MODEL_PH4TRX		0x12
+#define UW_MODEL_PH4TQF		0x14
+#define UW_MODEL_PH4AQF_ARX	0x17
+
+struct uniwill_device_features_t {
+	u8 model;
+	/**
+	 * Identification for uniwill_power_profile_v1
+	 *
+	 * - Two profiles present in low power devices often called
+	 *   "power save" and "balanced".
+	 * - Three profiles present mainly in devices with discrete
+	 *   graphics card often called "power save", "balanced"
+	 *   and "enthusiast"
+	 */
+	bool uniwill_profile_v1;
+	bool uniwill_profile_v1_two_profs;
+	bool uniwill_profile_v1_three_profs;
+	bool uniwill_profile_v1_three_profs_leds_only;
+	/*
+	 * Identifies devices where mode need to be chosen
+	 * for custom TDP values (and sometimes fan control) to have effect
+	 */
+	bool uniwill_custom_profile_mode_needed;
+	bool uniwill_has_charging_prio;
+	bool uniwill_has_charging_profile;
+	bool uniwill_has_universal_ec_fan_control;
+	bool uniwill_has_double_pl4;
+	bool uniwill_has_ac_auto_boot;
+	bool uniwill_has_usb_powershare;
+	bool uniwill_has_mini_led_local_dimming;
+};
+
+struct uniwill_device_features_t *uniwill_get_device_features(void);
+
+union uw_ec_read_return {
+	u32 dword;
+	struct {
+		u8 data_low;
+		u8 data_high;
+	} bytes;
+};
+
+union uw_ec_write_return {
+	u32 dword;
+	struct {
+		u8 addr_low;
+		u8 addr_high;
+		u8 data_low;
+		u8 data_high;
+	} bytes;
+};
+
+#endif
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_keyboard.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_keyboard.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_keyboard.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_keyboard.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,1829 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2020-2024 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef UNIWILL_KEYBOARD_H
+#define UNIWILL_KEYBOARD_H
+
+#include "tuxedo_keyboard_common.h"
+#include <linux/acpi.h>
+#include <linux/wmi.h>
+#include <linux/workqueue.h>
+#include <linux/keyboard.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/leds.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/string.h>
+#include <linux/version.h>
+#include <linux/i8042.h>
+#include <linux/serio.h>
+#include "uniwill_interfaces.h"
+#include "uniwill_leds.h"
+
+#define UNIWILL_OSD_RADIOON			0x01A
+#define UNIWILL_OSD_RADIOOFF			0x01B
+#define UNIWILL_OSD_KB_LED_LEVEL0		0x03B
+#define UNIWILL_OSD_KB_LED_LEVEL1		0x03C
+#define UNIWILL_OSD_KB_LED_LEVEL2		0x03D
+#define UNIWILL_OSD_KB_LED_LEVEL3		0x03E
+#define UNIWILL_OSD_KB_LED_LEVEL4		0x03F
+#define UNIWILL_OSD_DC_ADAPTER_CHANGE		0x0AB
+#define UNIWILL_OSD_MODE_CHANGE_KEY_EVENT	0x0B0
+
+#define UNIWILL_KEY_RFKILL			0x0A4
+#define UNIWILL_KEY_KBDILLUMDOWN		0x0B1
+#define UNIWILL_KEY_KBDILLUMUP			0x0B2
+#define UNIWILL_KEY_FN_LOCK			0x0B8
+#define UNIWILL_KEY_KBDILLUMTOGGLE		0x0B9
+
+#define UNIWILL_OSD_TOUCHPADWORKAROUND		0xFFF
+
+#define UNIWILL_FN_LOCK_MASK			0x10
+
+static void uw_charging_priority_write_state(void);
+static void uw_charging_profile_write_state(void);
+static void uniwill_set_custom_profile_mode(bool zero_bit_initially);
+
+struct tuxedo_keyboard_driver uniwill_keyboard_driver;
+
+struct uniwill_device_features_t uniwill_device_features;
+
+static bool uw_feats_loaded = false;
+
+static u8 uniwill_kbd_bl_enable_state_on_start = 0xff;
+
+static struct key_entry uniwill_wmi_keymap[] = {
+	// { KE_KEY,	UNIWILL_OSD_RADIOON,		{ KEY_RFKILL } },
+	// { KE_KEY,	UNIWILL_OSD_RADIOOFF,		{ KEY_RFKILL } },
+	// { KE_KEY,	0xb0,				{ KEY_F13 } },
+	// Manual mode rfkill
+	{ KE_KEY,	UNIWILL_KEY_RFKILL,		{ KEY_RFKILL }},
+	{ KE_KEY,	UNIWILL_OSD_TOUCHPADWORKAROUND,	{ KEY_F21 } },
+	// Keyboard brightness
+	{ KE_KEY,	UNIWILL_KEY_KBDILLUMDOWN,	{ KEY_KBDILLUMDOWN } },
+	{ KE_KEY,	UNIWILL_KEY_KBDILLUMUP,		{ KEY_KBDILLUMUP } },
+	{ KE_KEY,	UNIWILL_KEY_KBDILLUMTOGGLE,	{ KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY,	UNIWILL_OSD_KB_LED_LEVEL0,	{ KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY,	UNIWILL_OSD_KB_LED_LEVEL1,	{ KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY,	UNIWILL_OSD_KB_LED_LEVEL2,	{ KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY,	UNIWILL_OSD_KB_LED_LEVEL3,	{ KEY_KBDILLUMTOGGLE } },
+	{ KE_KEY,	UNIWILL_OSD_KB_LED_LEVEL4,	{ KEY_KBDILLUMTOGGLE } },
+	// Send FN_ESC to user space as input-event-codes.h does not define Fn-Lock
+	{ KE_KEY,	UNIWILL_KEY_FN_LOCK,		{ KEY_FN_ESC } },
+	// Only used to put ev bits
+	{ KE_KEY,	0xffff,				{ KEY_F6 } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTALT } },
+	{ KE_KEY,	0xffff,				{ KEY_LEFTMETA } },
+	{ KE_END,	0 }
+};
+
+static struct uniwill_interfaces_t {
+	struct uniwill_interface_t *wmi;
+} uniwill_interfaces = { .wmi = NULL };
+
+uniwill_event_callb_t uniwill_event_callb;
+
+int uniwill_read_ec_ram(u16 address, u8 *data)
+{
+	int status;
+
+	if (!IS_ERR_OR_NULL(uniwill_interfaces.wmi))
+		status = uniwill_interfaces.wmi->read_ec_ram(address, data);
+	else {
+		pr_err("no active interface while read addr 0x%04x\n", address);
+		status = -EIO;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(uniwill_read_ec_ram);
+
+int uniwill_read_ec_ram_with_retry(u16 address, u8 *data, int retries)
+{
+	int status, i;
+
+	for (i = 0; i < retries; ++i) {
+		status = uniwill_read_ec_ram(address, data);
+		if (status != 0)
+			pr_debug("uniwill_read_ec_ram(...) failed.\n");
+		else
+			break;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(uniwill_read_ec_ram_with_retry);
+
+int uniwill_write_ec_ram(u16 address, u8 data)
+{
+	int status;
+
+	if (!IS_ERR_OR_NULL(uniwill_interfaces.wmi))
+		status = uniwill_interfaces.wmi->write_ec_ram(address, data);
+	else {
+		pr_err("no active interface while write addr 0x%04x data 0x%02x\n", address, data);
+		status = -EIO;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(uniwill_write_ec_ram);
+
+int uniwill_write_ec_ram_with_retry(u16 address, u8 data, int retries)
+{
+	int status, i;
+	u8 control_data;
+
+	for (i = 0; i < retries; ++i) {
+		status = uniwill_write_ec_ram(address, data);
+		if (status != 0) {
+			msleep(50);
+			continue;
+		}
+		else {
+			status = uniwill_read_ec_ram(address, &control_data);
+			if (status != 0 || data != control_data) {
+				msleep(50);
+				continue;
+			}
+			break;
+		}
+	}
+
+	return status;
+}
+EXPORT_SYMBOL(uniwill_write_ec_ram_with_retry);
+
+
+int uniwill_wmi_evaluate(u8 function, u32 arg, u32 *return_buffer)
+{
+    int status;
+
+    if (!IS_ERR_OR_NULL(uniwill_interfaces.wmi) &&
+        !IS_ERR_OR_NULL(uniwill_interfaces.wmi->wmi_evaluate)) {
+        status = uniwill_interfaces.wmi->wmi_evaluate(function, arg, return_buffer);
+    } else {
+        pr_err("no active interface or ec_evaluate while calling function %u\n", function);
+        status = -EIO;
+    }
+
+    return status;
+}
+EXPORT_SYMBOL(uniwill_wmi_evaluate);
+
+static DEFINE_MUTEX(uniwill_interface_modification_lock);
+
+int uniwill_add_interface(struct uniwill_interface_t *interface)
+{
+	mutex_lock(&uniwill_interface_modification_lock);
+
+	if (strcmp(interface->string_id, UNIWILL_INTERFACE_WMI_STRID) == 0)
+		uniwill_interfaces.wmi = interface;
+	else {
+		TUXEDO_DEBUG("trying to add unknown interface\n");
+		mutex_unlock(&uniwill_interface_modification_lock);
+		return -EINVAL;
+	}
+	interface->event_callb = uniwill_event_callb;
+
+	mutex_unlock(&uniwill_interface_modification_lock);
+
+	// Initialize driver if not already present
+	tuxedo_keyboard_init_driver(&uniwill_keyboard_driver);
+
+	return 0;
+}
+EXPORT_SYMBOL(uniwill_add_interface);
+
+int uniwill_remove_interface(struct uniwill_interface_t *interface)
+{
+	mutex_lock(&uniwill_interface_modification_lock);
+
+	if (strcmp(interface->string_id, UNIWILL_INTERFACE_WMI_STRID) == 0) {
+		// Remove driver if last interface is removed
+		tuxedo_keyboard_remove_driver(&uniwill_keyboard_driver);
+
+		uniwill_interfaces.wmi = NULL;
+	} else {
+		mutex_unlock(&uniwill_interface_modification_lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&uniwill_interface_modification_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(uniwill_remove_interface);
+
+int uniwill_get_active_interface_id(char **id_str)
+{
+	if (IS_ERR_OR_NULL(uniwill_interfaces.wmi))
+		return -ENODEV;
+
+	if (!IS_ERR_OR_NULL(id_str))
+		*id_str = uniwill_interfaces.wmi->string_id;
+
+	return 0;
+}
+EXPORT_SYMBOL(uniwill_get_active_interface_id);
+
+static void key_event_work(struct work_struct *work)
+{
+	// Delay sometimes needed to make userspace reliably separate
+	// the touchpadtoggle key events from the custom key events
+	// coming from firmware
+	msleep(50);
+	sparse_keymap_report_known_event(
+		uniwill_keyboard_driver.input_device,
+		UNIWILL_OSD_TOUCHPADWORKAROUND,
+		1,
+		true
+	);
+}
+static DECLARE_WORK(uniwill_key_event_work, key_event_work);
+
+static void uniwill_write_kbd_bl_enable(u8 enable)
+{
+	u8 backlight_data;
+	enable = enable & 0x01;
+
+	uniwill_read_ec_ram(UW_EC_REG_KBD_BL_STATUS, &backlight_data);
+	backlight_data = backlight_data & ~(1 << 1);
+	backlight_data |= (!enable << 1);
+	uniwill_write_ec_ram(UW_EC_REG_KBD_BL_STATUS, backlight_data);
+}
+
+void uniwill_event_callb(u32 code)
+{
+	switch (code) {
+		case UNIWILL_OSD_MODE_CHANGE_KEY_EVENT:
+			// Special key combination when mode change key is pressed (the one next to
+			// the power key). Opens TCC by default when installed.
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_LEFTMETA, 1);
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_LEFTALT, 1);
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_F6, 1);
+			input_sync(uniwill_keyboard_driver.input_device);
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_F6, 0);
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_LEFTALT, 0);
+			input_report_key(uniwill_keyboard_driver.input_device, KEY_LEFTMETA, 0);
+			input_sync(uniwill_keyboard_driver.input_device);
+			break;
+		case UNIWILL_OSD_DC_ADAPTER_CHANGE:
+			// Refresh keyboard state and charging prio on cable switch event and make sure that the custom
+			// profile mode is still applied in case it's needed.
+			uniwill_set_custom_profile_mode(false);
+			uniwill_leds_restore_state_extern();
+			msleep(50);
+			uw_charging_priority_write_state();
+			break;
+		case UNIWILL_KEY_KBDILLUMTOGGLE:
+		case UNIWILL_OSD_KB_LED_LEVEL0:
+		case UNIWILL_OSD_KB_LED_LEVEL1:
+		case UNIWILL_OSD_KB_LED_LEVEL2:
+		case UNIWILL_OSD_KB_LED_LEVEL3:
+		case UNIWILL_OSD_KB_LED_LEVEL4:
+			// Notify userspace/UPower that the firmware changed the keyboard backlight
+			// brightness on white only keyboards. Fallthrough on other keyboards to
+			// emit KEY_KBDILLUMTOGGLE.
+			if (uniwill_leds_notify_brightness_change_extern())
+				return;
+			fallthrough;
+		default:
+			if (uniwill_keyboard_driver.input_device != NULL)
+				if (!sparse_keymap_report_known_event(uniwill_keyboard_driver.input_device, code, 1, true))
+					TUXEDO_DEBUG("Unknown code - %d (%0#6x)\n", code, code);
+	}
+}
+
+static void uniwill_set_custom_profile_mode(bool zero_bit_initially)
+{
+	// Set custom profile mode if needed
+	struct uniwill_device_features_t *uw_feats = uniwill_get_device_features();
+	if (uw_feats->uniwill_custom_profile_mode_needed) {
+		u8 data;
+		uniwill_read_ec_ram(UW_EC_REG_CUSTOM_PROFILE, &data);
+		if (zero_bit_initially) {
+			// Certain devices seem to need this first reset to zero on boot to have it properly applied
+			data &= ~(1 << 6);
+			uniwill_write_ec_ram(UW_EC_REG_CUSTOM_PROFILE, data);
+			msleep(50);
+		}
+		data |= (1 << 6);
+		uniwill_write_ec_ram(UW_EC_REG_CUSTOM_PROFILE, data);
+	}
+}
+
+#define UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS	0x24
+#define UNIWILL_LIGHTBAR_LED_NAME_RGB_RED	"lightbar_rgb:1:status"
+#define UNIWILL_LIGHTBAR_LED_NAME_RGB_GREEN	"lightbar_rgb:2:status"
+#define UNIWILL_LIGHTBAR_LED_NAME_RGB_BLUE	"lightbar_rgb:3:status"
+#define UNIWILL_LIGHTBAR_LED_NAME_ANIMATION	"lightbar_animation::status"
+
+static void uniwill_write_lightbar_rgb(u8 red, u8 green, u8 blue)
+{
+	if (red <= UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS) {
+		uniwill_write_ec_ram(0x0749, red);
+	}
+	if (green <= UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS) {
+		uniwill_write_ec_ram(0x074a, green);
+	}
+	if (blue <= UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS) {
+		uniwill_write_ec_ram(0x074b, blue);
+	}
+}
+
+static void uniwill_read_lightbar_rgb(u8 *red, u8 *green, u8 *blue)
+{
+	uniwill_read_ec_ram(0x0749, red);
+	uniwill_read_ec_ram(0x074a, green);
+	uniwill_read_ec_ram(0x074b, blue);
+}
+
+static void uniwill_write_lightbar_animation(bool animation_status)
+{
+	u8 value;
+
+	uniwill_read_ec_ram(0x0748, &value);
+	if (animation_status) {
+		value |= 0x80;
+	} else {
+		value &= ~0x80;
+	}
+	uniwill_write_ec_ram(0x0748, value);
+}
+
+static void uniwill_read_lightbar_animation(bool *animation_status)
+{
+	u8 lightbar_animation_data;
+	uniwill_read_ec_ram(0x0748, &lightbar_animation_data);
+	*animation_status = (lightbar_animation_data & 0x80) > 0;
+}
+
+static int lightbar_set_blocking(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	u8 red = 0xff, green = 0xff, blue = 0xff;
+	bool led_red = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_RED) != NULL;
+	bool led_green = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_GREEN) != NULL;
+	bool led_blue = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_BLUE) != NULL;
+	bool led_animation = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_ANIMATION) != NULL;
+
+	if (led_red || led_green || led_blue) {
+		if (led_red) {
+			red = brightness;
+		} else if (led_green) {
+			green = brightness;
+		} else if (led_blue) {
+			blue = brightness;
+		}
+		uniwill_write_lightbar_rgb(red, green, blue);
+		// Also make sure the animation is off
+		uniwill_write_lightbar_animation(false);
+	} else if (led_animation) {
+		if (brightness == 1) {
+			uniwill_write_lightbar_animation(true);
+		} else {
+			uniwill_write_lightbar_animation(false);
+		}
+	}
+	return 0;
+}
+
+static enum led_brightness lightbar_get(struct led_classdev *led_cdev)
+{
+	u8 red, green, blue;
+	bool animation_status;
+	bool led_red = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_RED) != NULL;
+	bool led_green = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_GREEN) != NULL;
+	bool led_blue = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_RGB_BLUE) != NULL;
+	bool led_animation = strstr(led_cdev->name, UNIWILL_LIGHTBAR_LED_NAME_ANIMATION) != NULL;
+
+	if (led_red || led_green || led_blue) {
+		uniwill_read_lightbar_rgb(&red, &green, &blue);
+		if (led_red) {
+			return red;
+		} else if (led_green) {
+			return green;
+		} else if (led_blue) {
+			return blue;
+		}
+	} else if (led_animation) {
+		uniwill_read_lightbar_animation(&animation_status);
+		return animation_status ? 1 : 0;
+	}
+
+	return 0;
+}
+
+static bool uw_lightbar_loaded;
+static struct led_classdev lightbar_led_classdevs[] = {
+	{
+		.name = UNIWILL_LIGHTBAR_LED_NAME_RGB_RED,
+		.max_brightness = UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS,
+		.brightness_set_blocking = &lightbar_set_blocking,
+		.brightness_get = &lightbar_get
+	},
+	{
+		.name = UNIWILL_LIGHTBAR_LED_NAME_RGB_GREEN,
+		.max_brightness = UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS,
+		.brightness_set_blocking = &lightbar_set_blocking,
+		.brightness_get = &lightbar_get
+	},
+	{
+		.name = UNIWILL_LIGHTBAR_LED_NAME_RGB_BLUE,
+		.max_brightness = UNIWILL_LIGHTBAR_LED_MAX_BRIGHTNESS,
+		.brightness_set_blocking = &lightbar_set_blocking,
+		.brightness_get = &lightbar_get
+	},
+	{
+		.name = UNIWILL_LIGHTBAR_LED_NAME_ANIMATION,
+		.max_brightness = 1,
+		.brightness_set_blocking = &lightbar_set_blocking,
+		.brightness_get = &lightbar_get
+	}
+};
+
+static int uw_lightbar_init(struct platform_device *dev)
+{
+	int i, j, status;
+
+	bool lightbar_supported = false
+		|| dmi_match(DMI_BOARD_NAME, "LAPQC71A")
+		|| dmi_match(DMI_BOARD_NAME, "LAPQC71B")
+		|| dmi_match(DMI_BOARD_NAME, "TRINITY1501I")
+		|| dmi_match(DMI_BOARD_NAME, "TRINITY1701I")
+		|| dmi_match(DMI_PRODUCT_NAME, "A60 MUV")
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XA03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI04")
+		|| dmi_match(DMI_PRODUCT_SKU, "STEPOL1XA04")
+
+#endif
+		;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 18, 0)
+	TUXEDO_ERROR(
+		"Warning: Kernel version less that 4.18, lightbar might not be properly recognized.");
+#endif
+
+	if (!lightbar_supported)
+		return -ENODEV;
+
+	for (i = 0; i < ARRAY_SIZE(lightbar_led_classdevs); ++i) {
+		status = led_classdev_register(&dev->dev, &lightbar_led_classdevs[i]);
+		if (status < 0) {
+			for (j = 0; j < i; j++)
+				led_classdev_unregister(&lightbar_led_classdevs[j]);
+			return status;
+		}
+	}
+
+	// Init default state
+	uniwill_write_lightbar_animation(false);
+	uniwill_write_lightbar_rgb(0, 0, 0);
+
+	return 0;
+}
+
+static int uw_lightbar_remove(struct platform_device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(lightbar_led_classdevs); ++i) {
+		led_classdev_unregister(&lightbar_led_classdevs[i]);
+	}
+	return 0;
+}
+
+static bool uw_charging_prio_loaded = false;
+static bool uw_charging_prio_last_written_value;
+
+static ssize_t uw_charging_prios_available_show(struct device *child,
+						struct device_attribute *attr,
+						char *buffer);
+static ssize_t uw_charging_prio_show(struct device *child,
+				     struct device_attribute *attr, char *buffer);
+static ssize_t uw_charging_prio_store(struct device *child,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size);
+
+struct uw_charging_prio_attrs_t {
+	struct device_attribute charging_prios_available;
+	struct device_attribute charging_prio;
+} uw_charging_prio_attrs = {
+	.charging_prios_available = __ATTR(charging_prios_available, 0444, uw_charging_prios_available_show, NULL),
+	.charging_prio = __ATTR(charging_prio, 0644, uw_charging_prio_show, uw_charging_prio_store)
+};
+
+static struct attribute *uw_charging_prio_attrs_list[] = {
+	&uw_charging_prio_attrs.charging_prios_available.attr,
+	&uw_charging_prio_attrs.charging_prio.attr,
+	NULL
+};
+
+static struct attribute_group uw_charging_prio_attr_group = {
+	.name = "charging_priority",
+	.attrs = uw_charging_prio_attrs_list
+};
+
+/*
+ * charging_prio values
+ *     0 => charging priority
+ *     1 => performance priority
+ */
+static int uw_set_charging_priority(u8 charging_priority)
+{
+	u8 previous_data, next_data;
+	int result;
+
+	charging_priority = (charging_priority & 0x01) << 7;
+
+	result = uniwill_read_ec_ram(0x07cc, &previous_data);
+	if (result != 0)
+		return result;
+
+	next_data = (previous_data & ~(1 << 7)) | charging_priority;
+	result = uniwill_write_ec_ram(0x07cc, next_data);
+	if (result == 0)
+		uw_charging_prio_last_written_value = charging_priority;
+
+	return result;
+}
+
+static int uw_get_charging_priority(u8 *charging_priority)
+{
+	int result = uniwill_read_ec_ram(0x07cc, charging_priority);
+	*charging_priority = (*charging_priority >> 7) & 0x01;
+	return result;
+}
+
+static int uw_has_charging_priority(bool *status)
+{
+	u8 data;
+	int result;
+
+	/* 
+	 * The ODM dropped this feature for certain reasons by just disabling the feature within their Control Center.
+	 * Therefore every device using the control center until version 5.9.49.16 at least theoretically supports the
+	 * feature. However, due to the support identification bit, being listed among the following devices does not
+	 * automatically mean that this device supports the feature.
+	 * After 5.9.50.3 devices may still have the support identification bit set but don't officially support the 
+	 * feature anymore.
+	*/
+	bool device_before_feature_drop = false
+		|| dmi_match(DMI_BOARD_NAME, "PH4PRX1_PH6PRX1") // IBP Gen8
+		|| dmi_match(DMI_BOARD_NAME, "PH6PG01_PH6PG71")
+		|| dmi_match(DMI_BOARD_NAME, "PH4PG31")
+		|| dmi_match(DMI_BOARD_NAME, "PHxARX1_PHxAQF1") // IBP Gen7
+		|| dmi_match(DMI_BOARD_NAME, "PH6AG01_PH6AQ71_PH6AQI1")
+		|| dmi_match(DMI_BOARD_NAME, "PHxTxX1") // IBP Gen6
+		|| dmi_match(DMI_BOARD_NAME, "GMxXGxx") // Polaris Gen5 
+		|| dmi_match(DMI_BOARD_NAME, "GMxNGxx") // Polaris Gen3 
+		|| dmi_match(DMI_BOARD_NAME, "GMxTGxx") // Stellaris/Polaris Gen3 
+		|| dmi_match(DMI_BOARD_NAME, "GMxZGxx") // Stellaris Gen3
+		|| dmi_match(DMI_BOARD_NAME, "GMxMGxx") // Polaris Gen2 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501I1650TI") // Polaris Gen1 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501A1650TI") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701A1650TI") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701I1650TI") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501I2060") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501A2060") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701I2060") 
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701A2060") 
+		|| dmi_match(DMI_BOARD_NAME, "PF5LUXG") // Pulse Gen2
+		|| dmi_match(DMI_BOARD_NAME, "PULSE1401") // Pulse Gen1
+		|| dmi_match(DMI_BOARD_NAME, "PULSE1501") 
+		;
+
+	if (!device_before_feature_drop) {
+		*status = false;
+		return 0;
+	}
+
+	result = uniwill_read_ec_ram(0x0742, &data);
+	if (result != 0)
+		return -EIO;
+
+	if (data & (1 << 5))
+		*status = true;
+	else
+		*status = false;
+
+	return 0;
+}
+
+static void uw_charging_priority_write_state(void)
+{
+	if (uw_charging_prio_loaded)
+		uw_set_charging_priority(uw_charging_prio_last_written_value);
+}
+
+static void uw_charging_priority_init(struct platform_device *dev)
+{
+	u8 value;
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->uniwill_has_charging_prio)
+		uw_charging_prio_loaded = sysfs_create_group(&dev->dev.kobj, &uw_charging_prio_attr_group) == 0;
+
+	// Read for state init
+	if (uw_charging_prio_loaded) {
+		uw_get_charging_priority(&value);
+		uw_charging_prio_last_written_value = value;
+	}
+}
+
+static bool uw_charging_profile_loaded = false;
+static bool uw_charging_profile_last_written_value;
+
+static ssize_t uw_charging_profiles_available_show(struct device *child,
+						   struct device_attribute *attr,
+						   char *buffer);
+static ssize_t uw_charging_profile_show(struct device *child,
+					struct device_attribute *attr, char *buffer);
+static ssize_t uw_charging_profile_store(struct device *child,
+					 struct device_attribute *attr,
+					 const char *buffer, size_t size);
+
+struct uw_charging_profile_attrs_t {
+	struct device_attribute charging_profiles_available;
+	struct device_attribute charging_profile;
+} uw_charging_profile_attrs = {
+	.charging_profiles_available = __ATTR(charging_profiles_available, 0444, uw_charging_profiles_available_show, NULL),
+	.charging_profile = __ATTR(charging_profile, 0644, uw_charging_profile_show, uw_charging_profile_store)
+};
+
+static struct attribute *uw_charging_profile_attrs_list[] = {
+	&uw_charging_profile_attrs.charging_profiles_available.attr,
+	&uw_charging_profile_attrs.charging_profile.attr,
+	NULL
+};
+
+static struct attribute_group uw_charging_profile_attr_group = {
+	.name = "charging_profile",
+	.attrs = uw_charging_profile_attrs_list
+};
+
+/*
+ * charging_profile values
+ *     0 => high capacity
+ *     1 => balanced
+ *     2 => stationary
+ */
+static int uw_set_charging_profile(u8 charging_profile)
+{
+	u8 previous_data, next_data;
+	int result;
+
+	charging_profile = (charging_profile & 0x03) << 4;
+
+	result = uniwill_read_ec_ram(0x07a6, &previous_data);
+	if (result != 0)
+		return result;
+
+	next_data = (previous_data & ~(0x03 << 4)) | charging_profile;
+	result = uniwill_write_ec_ram(0x07a6, next_data);
+
+	if (result == 0)
+		uw_charging_profile_last_written_value = charging_profile;
+
+	return result;
+}
+
+static int uw_get_charging_profile(u8 *charging_profile)
+{
+	int result = uniwill_read_ec_ram(0x07a6, charging_profile);
+	if (result == 0)
+		*charging_profile = (*charging_profile >> 4) & 0x03;
+	return result;
+}
+
+static int uw_has_charging_profile(bool *status)
+{
+	u8 data;
+	int result;
+
+	bool not_supported_device = false
+		|| dmi_match(DMI_BOARD_NAME, "PF5PU1G")
+		|| dmi_match(DMI_BOARD_NAME, "LAPQC71A")
+		|| dmi_match(DMI_BOARD_NAME, "LAPQC71B")
+		|| dmi_match(DMI_PRODUCT_NAME, "A60 MUV")
+	;
+
+	if (not_supported_device) {
+		*status = false;
+		return 0;
+	}
+
+	result = uniwill_read_ec_ram(0x078e, &data);
+	if (result != 0)
+		return -EIO;
+
+	if (data & (1 << 3))
+		*status = true;
+	else
+		*status = false;
+
+	return 0;
+}
+
+static void __attribute__ ((unused)) uw_charging_profile_write_state(void)
+{
+	if (uw_charging_profile_loaded)
+		uw_set_charging_profile(uw_charging_profile_last_written_value);
+}
+
+static void uw_charging_profile_init(struct platform_device *dev)
+{
+	u8 value;
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->uniwill_has_charging_profile)
+		uw_charging_profile_loaded = sysfs_create_group(&dev->dev.kobj, &uw_charging_profile_attr_group) == 0;
+
+	// Read for state init
+	if (uw_charging_profile_loaded) {
+		uw_get_charging_profile(&value);
+		uw_charging_profile_last_written_value = value;
+	}
+}
+
+struct char_to_u8_t {
+	char* descriptor;
+	u8 value;
+};
+
+static struct char_to_u8_t charging_profile_options[] = {
+	{ .descriptor = "high_capacity", .value = 0x00 },
+	{ .descriptor = "balanced",	 .value = 0x01 },
+	{ .descriptor = "stationary",	 .value = 0x02 }
+};
+
+static ssize_t uw_charging_profiles_available_show(struct device *child,
+						   struct device_attribute *attr,
+						   char *buffer)
+{
+	int i, n;
+	n = ARRAY_SIZE(charging_profile_options);
+	for (i = 0; i < n; ++i) {
+		sprintf(buffer + strlen(buffer), "%s",
+			charging_profile_options[i].descriptor);
+		if (i < n - 1)
+			sprintf(buffer + strlen(buffer), " ");
+		else
+			sprintf(buffer + strlen(buffer), "\n");
+	}
+
+	return strlen(buffer);
+}
+
+static ssize_t uw_charging_profile_show(struct device *child,
+					struct device_attribute *attr, char *buffer)
+{
+	u8 charging_profile_value;
+	int i, result;
+
+	result = uw_get_charging_profile(&charging_profile_value);
+	if (result != 0)
+		return result;
+
+	for (i = 0; i < ARRAY_SIZE(charging_profile_options); ++i)
+		if (charging_profile_options[i].value == charging_profile_value) {
+			sprintf(buffer, "%s\n", charging_profile_options[i].descriptor);
+			return strlen(buffer);
+		}
+
+	pr_err("Read charging profile value not matched to a descriptor\n");
+
+	return -EIO;
+}
+
+static ssize_t uw_charging_profile_store(struct device *child,
+					 struct device_attribute *attr,
+					 const char *buffer, size_t size)
+{
+	u8 charging_profile_value;
+	int i, result;
+	char *buffer_copy;
+	char *charging_profile_descriptor;
+	buffer_copy = kmalloc(size + 1, GFP_KERNEL);
+	strcpy(buffer_copy, buffer);
+	charging_profile_descriptor = strstrip(buffer_copy);
+
+	for (i = 0; i < ARRAY_SIZE(charging_profile_options); ++i)
+		if (strcmp(charging_profile_options[i].descriptor, charging_profile_descriptor) == 0) {
+			charging_profile_value = charging_profile_options[i].value;
+			break;
+		}
+
+	kfree(buffer_copy);
+
+	if (i < ARRAY_SIZE(charging_profile_options)) {
+		// Option found try to set
+		result = uw_set_charging_profile(charging_profile_value);
+		if (result == 0)
+			return size;
+		else
+			return -EIO;
+	} else
+		// Invalid input, not matched to an option
+		return -EINVAL;
+}
+
+static struct char_to_u8_t charging_prio_options[] = {
+	{ .descriptor = "charge_battery", .value = 0x00 },
+	{ .descriptor = "performance",    .value = 0x01 }
+};
+
+static ssize_t uw_charging_prios_available_show(struct device *child,
+						struct device_attribute *attr,
+						char *buffer)
+{
+	int i, n;
+	n = ARRAY_SIZE(charging_prio_options);
+	for (i = 0; i < n; ++i) {
+		sprintf(buffer + strlen(buffer), "%s",
+			charging_prio_options[i].descriptor);
+		if (i < n - 1)
+			sprintf(buffer + strlen(buffer), " ");
+		else
+			sprintf(buffer + strlen(buffer), "\n");
+	}
+
+	return strlen(buffer);
+}
+
+static ssize_t uw_charging_prio_show(struct device *child,
+				     struct device_attribute *attr, char *buffer)
+{
+	u8 charging_prio_value;
+	int i, result;
+
+	result = uw_get_charging_priority(&charging_prio_value);
+	if (result != 0)
+		return result;
+
+	for (i = 0; i < ARRAY_SIZE(charging_prio_options); ++i)
+		if (charging_prio_options[i].value == charging_prio_value) {
+			sprintf(buffer, "%s\n", charging_prio_options[i].descriptor);
+			return strlen(buffer);
+		}
+
+	pr_err("Read charging prio value not matched to a descriptor\n");
+
+	return -EIO;
+}
+
+static ssize_t uw_charging_prio_store(struct device *child,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size)
+{
+	u8 charging_prio_value;
+	int i, result;
+	char *buffer_copy;
+	char *charging_prio_descriptor;
+	buffer_copy = kmalloc(size + 1, GFP_KERNEL);
+	strcpy(buffer_copy, buffer);
+	charging_prio_descriptor = strstrip(buffer_copy);
+
+	for (i = 0; i < ARRAY_SIZE(charging_prio_options); ++i)
+		if (strcmp(charging_prio_options[i].descriptor, charging_prio_descriptor) == 0) {
+			charging_prio_value = charging_prio_options[i].value;
+			break;
+		}
+
+	kfree(buffer_copy);
+
+	if (i < ARRAY_SIZE(charging_prio_options)) {
+		// Option found try to set
+		result = uw_set_charging_priority(charging_prio_value);
+		if (result == 0)
+			return size;
+		else
+			return -EIO;
+	} else
+		// Invalid input, not matched to an option
+		return -EINVAL;
+}
+
+/*
+ * We didn't find any identification bits to retrieve the information if the
+ * device supports the features usb_powershare and ac_auto_boot. The nb02
+ * control center reads the support flag either from the registry or from the
+ * UniWillVariable efivar. The efivar most likely stores this information at an
+ * offset of 92 bytes. However, tests have shown that the control center most
+ * likely sets the bit in this variable itself dynamically, so we have to check
+ * DMI strings for now.
+ */
+static int is_auto_boot_and_powershare_supported(bool *status)
+{
+	*status = false ||
+		  // IBP Gen9
+		  dmi_match(DMI_BOARD_NAME, "GXxMRXx") ||
+		  dmi_match(DMI_BOARD_NAME, "GXxHRXx") ||
+		  // IBP Gen10
+		  dmi_match(DMI_BOARD_NAME, "XxHP4NAx") ||
+		  dmi_match(DMI_BOARD_NAME, "XxKK4NAx_XxSP4NAx") ||
+		  dmi_match(DMI_BOARD_NAME, "XxAR4NAx") ||
+
+		  // Stellaris Gen6
+		  dmi_match(DMI_BOARD_NAME, "GM6IXxB_MB1") ||
+		  dmi_match(DMI_BOARD_NAME, "GM6IXxB_MB2") ||
+		  dmi_match(DMI_BOARD_NAME, "GM7IXxN") ||
+		  // Stellaris Gen7
+		  dmi_match(DMI_BOARD_NAME, "X6AR5xxY") ||
+		  dmi_match(DMI_BOARD_NAME, "X6AR5xxY_mLED") ||
+		  dmi_match(DMI_BOARD_NAME, "X6FR5xxY") ||
+
+		  // Stellaris Slim Gen6
+		  dmi_match(DMI_BOARD_NAME, "GMxHGxx") ||
+		  dmi_match(DMI_BOARD_NAME, "GM5IXxA") ||
+
+		  // InfinityBook Max Gen10
+		  dmi_match(DMI_BOARD_NAME, "X5KK45xS_X5SP45xS");
+
+	return 0;
+}
+
+static bool uw_ac_auto_boot_loaded = false;
+static bool uw_ac_auto_boot_last_written_value;
+
+static ssize_t uw_ac_auto_boot_show(struct device *child,
+				    struct device_attribute *attr,
+				    char *buffer);
+static ssize_t uw_ac_auto_boot_store(struct device *child,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size);
+
+struct uw_ac_auto_boot_attrs_t
+{
+	struct device_attribute ac_auto_boot;
+} uw_ac_auto_boot_attrs = {
+	.ac_auto_boot = __ATTR(ac_auto_boot, 0644, uw_ac_auto_boot_show, uw_ac_auto_boot_store)
+};
+
+static struct attribute *uw_ac_auto_boot_attrs_list[] = {
+	&uw_ac_auto_boot_attrs.ac_auto_boot.attr,
+	NULL};
+
+static struct attribute_group uw_ac_auto_boot_attr_group = {
+	.name = "ac_auto_boot",
+	.attrs = uw_ac_auto_boot_attrs_list};
+
+static int uw_set_ac_auto_boot(u8 ac_auto_boot)
+{
+	u8 previous_data, next_data;
+	int result;
+
+	ac_auto_boot = (ac_auto_boot & 0x01) << 3;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_AC_AUTO_BOOT_STATUS,
+				     &previous_data);
+	if (result != 0)
+		return result;
+
+	next_data = (previous_data & ~(1 << 3)) | ac_auto_boot;
+	result = uniwill_write_ec_ram(UW_EC_REG_AC_AUTO_BOOT_STATUS, next_data);
+	if (result == 0)
+		uw_ac_auto_boot_last_written_value = ac_auto_boot;
+
+	return result;
+}
+
+static int uw_get_ac_auto_boot(u8 *ac_auto_boot)
+{
+	int result;
+	result = uniwill_read_ec_ram(UW_EC_REG_AC_AUTO_BOOT_STATUS,
+				     ac_auto_boot);
+	if (result == 0)
+		*ac_auto_boot = (*ac_auto_boot >> 3) & 0x01;
+	return result;
+}
+
+static int uw_has_ac_auto_boot(bool *status)
+{
+	return is_auto_boot_and_powershare_supported(status);
+}
+
+static void uw_ac_auto_boot_init(struct platform_device *dev)
+{
+	u8 value;
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->uniwill_has_ac_auto_boot)
+		uw_ac_auto_boot_loaded =
+			sysfs_create_group(&dev->dev.kobj,
+					   &uw_ac_auto_boot_attr_group) == 0;
+
+	// Read for state init
+	if (uw_ac_auto_boot_loaded) {
+		uw_get_ac_auto_boot(&value);
+		uw_ac_auto_boot_last_written_value = value;
+	}
+}
+
+static ssize_t uw_ac_auto_boot_show(struct device *child,
+				    struct device_attribute *attr, 
+				    char *buffer)
+{
+	u8 ac_auto_boot_value;
+	int result;
+
+	result = uw_get_ac_auto_boot(&ac_auto_boot_value);
+	if (result == 0)
+		return sprintf(buffer, "%d\n", ac_auto_boot_value);
+
+	return -EIO;
+}
+
+static ssize_t uw_ac_auto_boot_store(struct device *child,
+				     struct device_attribute *attr,
+				     const char *buffer, size_t size)
+{
+	u8 ac_auto_boot_value;
+	int result;
+
+	if (kstrtou8(buffer, 10, &ac_auto_boot_value) ||
+	    ac_auto_boot_value < 0 || ac_auto_boot_value > 1)
+		return -EINVAL;
+
+	result = uw_set_ac_auto_boot(ac_auto_boot_value);
+	if (result == 0)
+		return size;
+	else
+		return -EIO;
+}
+
+static bool uw_usb_powershare_loaded = false;
+static bool uw_usb_powershare_last_written_value;
+
+static ssize_t uw_usb_powershare_show(struct device *child,
+				      struct device_attribute *attr,
+				      char *buffer);
+static ssize_t uw_usb_powershare_store(struct device *child,
+				       struct device_attribute *attr,
+				       const char *buffer, size_t size);
+
+struct uw_usb_powershare_attrs_t
+{
+	struct device_attribute usb_powershare;
+} uw_usb_powershare_attrs = {
+	.usb_powershare = __ATTR(usb_powershare, 0644, uw_usb_powershare_show, uw_usb_powershare_store)
+};
+
+static struct attribute *uw_usb_powershare_attrs_list[] = {
+	&uw_usb_powershare_attrs.usb_powershare.attr,
+	NULL};
+
+static struct attribute_group uw_usb_powershare_attr_group = {
+	.name = "usb_powershare",
+	.attrs = uw_usb_powershare_attrs_list};
+
+static int uw_set_usb_powershare(u8 usb_powershare)
+{
+	u8 previous_data, next_data;
+	int result;
+	usb_powershare = (usb_powershare & 0x01) << 4;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_USB_POWERSHARE_STATUS,
+				     &previous_data);
+	if (result != 0)
+		return result;
+
+	next_data = (previous_data & ~(1 << 4)) | usb_powershare;
+	// This bit is set to 0 after a cold boot regardless of its original value for some reason.
+	result = uniwill_write_ec_ram(UW_EC_REG_USB_POWERSHARE_STATUS,
+				      next_data);
+	if (result == 0)
+		uw_usb_powershare_last_written_value = usb_powershare;
+
+	return result;
+}
+
+static int uw_get_usb_powershare(u8 *usb_powershare)
+{
+	int result;
+	result = uniwill_read_ec_ram(UW_EC_REG_USB_POWERSHARE_STATUS,
+				     usb_powershare);
+	if (result == 0)
+		*usb_powershare = (*usb_powershare >> 4) & 0x01;
+	return result;
+}
+
+static int uw_has_usb_powershare(bool *status)
+{
+	return is_auto_boot_and_powershare_supported(status);
+}
+
+static void uw_usb_powershare_init(struct platform_device *dev)
+{
+	u8 value;
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->uniwill_has_usb_powershare)
+		uw_usb_powershare_loaded =
+			sysfs_create_group(&dev->dev.kobj,
+					   &uw_usb_powershare_attr_group) == 0;
+
+	// Read for state init
+	if (uw_usb_powershare_loaded) {
+		uw_get_usb_powershare(&value);
+		uw_usb_powershare_last_written_value = value;
+	}
+}
+
+static ssize_t uw_usb_powershare_show(struct device *child,
+				      struct device_attribute *attr,
+				      char *buffer)
+{
+	u8 usb_powershare_value;
+	int result;
+
+	result = uw_get_usb_powershare(&usb_powershare_value);
+	if (result == 0)
+		return sprintf(buffer, "%d\n", usb_powershare_value);
+
+	return -EIO;
+}
+
+static ssize_t uw_usb_powershare_store(struct device *child,
+				       struct device_attribute *attr,
+				       const char *buffer, size_t size)
+{
+	u8 usb_powershare_value;
+	int result;
+
+	if (kstrtou8(buffer, 10, &usb_powershare_value) ||
+	    usb_powershare_value < 0 || usb_powershare_value > 1)
+		return -EINVAL;
+
+	result = uw_set_usb_powershare(usb_powershare_value);
+	if (result == 0)
+		return size;
+	else
+		return -EIO;
+}
+
+static bool uw_mini_led_local_dimming_loaded = false;
+static bool uw_mini_led_local_dimming_last_written_value;
+
+static ssize_t uw_mini_led_local_dimming_show(struct device *child,
+				     struct device_attribute *attr, char *buffer);
+static ssize_t uw_mini_led_local_dimming_store(struct device *child,
+				      struct device_attribute *attr,
+				      const char *buffer, size_t size);
+
+struct uw_mini_led_local_dimming_attrs_t {
+	struct device_attribute mini_led_local_dimming;
+} uw_mini_led_local_dimming_attrs = {
+	.mini_led_local_dimming = __ATTR(mini_led_local_dimming, 0644, uw_mini_led_local_dimming_show, uw_mini_led_local_dimming_store)
+};
+
+static struct attribute *uw_mini_led_local_dimming_attrs_list[] = {
+	&uw_mini_led_local_dimming_attrs.mini_led_local_dimming.attr,
+	NULL
+};
+
+static struct attribute_group uw_mini_led_local_dimming_attr_group = {
+	.name = "mini_led_local_dimming",
+	.attrs = uw_mini_led_local_dimming_attrs_list
+};
+
+/*
+ * mini_led_local_dimming values
+ *     0 => local dimming off
+ *     1 => local dimming on
+ */
+static int uw_set_mini_led_local_dimming(u8 mini_led_local_dimming)
+{
+	int result;
+	u32 uw_data[10];
+
+	if (mini_led_local_dimming == 1) {
+		result = uniwill_wmi_evaluate(UNIWILL_WMI_FUNCTION_FEATURE_TOGGLE,
+					    UNIWILL_WMI_LOCAL_DIMMING_ON,
+					    uw_data);
+	} else {
+		result = uniwill_wmi_evaluate(UNIWILL_WMI_FUNCTION_FEATURE_TOGGLE,
+					    UNIWILL_WMI_LOCAL_DIMMING_OFF, 
+					    uw_data);
+	}
+	if (result != 0)
+		return result;
+
+	uw_mini_led_local_dimming_last_written_value = mini_led_local_dimming;
+
+	return result;
+}
+
+static int uw_get_mini_led_local_dimming(u8 *mini_led_local_dimming)
+{
+	/* 
+	 * As of now, we do not have any possibility to read out the current state of local dimming. However, 
+	 * as this feature is set to disabled on boot per default by calling uw_set_mini_led_local_dimming, 
+	 * uw_mini_led_local_dimming_last_written_value is always initialized and thereby should not cause
+	 * any harm.
+	 *
+	 * A rather hacky solution could be the following, as uniwill_wmi_evaluate writes the current state
+	 * into the return buffer before overwriting it:
+	 
+	 * u32 return_buffer;
+	 * bool initial_status;
+	 * uniwill_wmi_evaluate(local_dimming, off, return_buffer);
+	 * if (return_buffer == UNIWILL_WMI_LOCAL_DIMMING_ON)
+	 * 	initial_status = true;
+	 * else 
+	 * 	initial_status = false;
+	 * uniwill_wmi_evaluate(local_dimming, initial_status, return_buffer);
+	 * *mini_led_local_dimming = initial_status;
+	 */
+	*mini_led_local_dimming = uw_mini_led_local_dimming_last_written_value;
+	return 0;
+}
+
+static int uw_has_mini_led_local_dimming(bool *status)
+{
+	u8 data;
+	int result;
+	
+	result = uniwill_read_ec_ram(UW_EC_REG_MINI_LED_LOCAL_DIMMING_SUPPORT,
+				     &data);
+	if (result)
+		return result;
+
+	*status = (data != 0xFF) && ((data & 0x01) > 0);
+	return 0;
+}
+
+static void uw_mini_led_local_dimming_init(struct platform_device *dev)
+{
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->uniwill_has_mini_led_local_dimming)
+		uw_mini_led_local_dimming_loaded = sysfs_create_group(&dev->dev.kobj, &uw_mini_led_local_dimming_attr_group) == 0;
+
+	// Set default to off
+	uw_set_mini_led_local_dimming(false);
+}
+
+static ssize_t uw_mini_led_local_dimming_show(struct device *child,
+				      struct device_attribute *attr,
+				      char *buffer)
+{
+	u8 mini_led_local_dimming_value;
+	int result;
+
+	result = uw_get_mini_led_local_dimming(&mini_led_local_dimming_value);
+	if (result == 0)
+		return sprintf(buffer, "%d\n", mini_led_local_dimming_value);
+
+	return -EIO;
+}
+
+static ssize_t uw_mini_led_local_dimming_store(struct device *child,
+				       struct device_attribute *attr,
+				       const char *buffer, size_t size)
+{
+	u8 mini_led_local_dimming_value;
+	int result;
+
+	if (kstrtou8(buffer, 10, &mini_led_local_dimming_value) ||
+	    mini_led_local_dimming_value < 0 || mini_led_local_dimming_value > 1)
+		return -EINVAL;
+
+	result = uw_set_mini_led_local_dimming(mini_led_local_dimming_value);
+	if (result == 0)
+		return size;
+	else
+		return -EIO;
+}
+
+static const u8 uw_romid_PH4PxX[14] = {0x0C, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+static const u8 uw_romid_PH6PxX[14] = {0x0C, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+
+static const struct dmi_system_id uw_sku_romid_table[] = {
+	// IBPG8 mk1
+	// Logic: If product serial matches 16inch use that, else default to 14inch
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_SKU, "IBP1XI08MK1"),
+			DMI_MATCH(DMI_PRODUCT_SERIAL, "PH6PRX"),
+		},
+		.driver_data = (void *)&uw_romid_PH6PxX
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_SKU, "IBP1XI08MK1"),
+		},
+		.driver_data = (void *)&uw_romid_PH4PxX
+	},
+	// IBP16G8 mk2
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_SKU, "IBP1XI08MK2"),
+			DMI_MATCH(DMI_PRODUCT_SERIAL, "PH6"),
+		},
+		.driver_data = (void *)&uw_romid_PH6PxX
+	},
+	{}
+};
+
+static int set_rom_id(void) {
+	int i, ret;
+	const struct dmi_system_id *uw_sku_romid;
+	const u8 *romid;
+	u8 data;
+	bool romid_false = false;
+
+	uw_sku_romid = dmi_first_match(uw_sku_romid_table);
+	if (!uw_sku_romid)
+		return 0;
+
+	romid = (const u8 *)uw_sku_romid->driver_data;
+	pr_debug("ROMID 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n",
+		 romid[0], romid[1], romid[2], romid[3], romid[4], romid[5], romid[6], romid[7],
+		 romid[8], romid[9], romid[10], romid[11], romid[12], romid[13]);
+
+	for (i = 0; i < 14; ++i) {
+		ret = uniwill_read_ec_ram_with_retry(UW_EC_REG_ROMID_START + i, &data, 3);
+		if (ret) {
+			pr_debug("uniwill_read_ec_ram_with_retry(...) failed.\n");
+			return ret;
+		}
+		pr_debug("ROMID index: %d, expected value: 0x%02X, actual value: 0x%02X\n", i, romid[i], data);
+		if (data != romid[i]) {
+			pr_debug("ROMID is false. Correcting...\n");
+			romid_false = true;
+			break;
+		}
+	}
+
+	if (romid_false) {
+		ret = uniwill_write_ec_ram_with_retry(UW_EC_REG_ROMID_SPECIAL_1, 0xA5, 3);
+		if (ret) {
+			pr_debug("uniwill_write_ec_ram_with_retry(...) failed.\n");
+			return ret;
+		}
+		ret = uniwill_write_ec_ram_with_retry(UW_EC_REG_ROMID_SPECIAL_2, 0x78, 3);
+		if (ret) {
+			pr_debug("uniwill_write_ec_ram_with_retry(...) failed.\n");
+			return ret;
+		}
+		for (i = 0; i < 14; ++i) {
+			ret = uniwill_write_ec_ram_with_retry(UW_EC_REG_ROMID_START + i, romid[i], 3);
+			if (ret) {
+				pr_debug("uniwill_write_ec_ram_with_retry(...) failed.\n");
+				return ret;
+			}
+		}
+	}
+	else
+		pr_debug("ROMID is correct.\n");
+
+	return 0;
+}
+
+static int has_universal_ec_fan_control(void) {
+	int ret;
+	u8 data;
+
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+
+	if (uw_feats->model == UW_MODEL_PH4TRX) {
+		// For some reason, on this particular device, the 2nd fan is not controlled via the
+		// "GPU" fan curve when the bit to separate both fancurves is set, but the old fan
+		// control works just fine.
+		return 0;
+	}
+
+	ret = uniwill_read_ec_ram(0x078e, &data);
+	if (ret < 0) {
+		return ret;
+	}
+	return (data >> 6) & 1;
+}
+
+static int has_double_pl4(bool *status)
+{
+	u8 data;
+	int result;
+
+	result = uniwill_read_ec_ram(0x0727, &data);
+	if (result)
+		return result;
+
+	if (data & (1 << 7))
+		*status = true;
+	else
+		*status = false;
+
+	return 0;
+}
+
+struct uniwill_device_features_t *uniwill_get_device_features(void)
+{
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+	u32 status;
+	int result;
+	bool feats_loaded;
+
+	if (uw_feats_loaded)
+		return uw_feats;
+
+	feats_loaded = true;
+
+	status = uniwill_read_ec_ram(0x0740, &uw_feats->model);
+	if (status != 0) {
+		uw_feats->model = 0;
+		feats_loaded = false;
+	}
+
+	uw_feats->uniwill_profile_v1_two_profs = false
+		|| dmi_match(DMI_BOARD_NAME, "PF5PU1G")
+		|| dmi_match(DMI_BOARD_NAME, "PULSE1401")
+		|| dmi_match(DMI_BOARD_NAME, "PULSE1501")
+	;
+
+	uw_feats->uniwill_profile_v1_three_profs = false
+	// Devices with "classic" profile support
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501A1650TI")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501A2060")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501I1650TI")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1501I2060")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701A1650TI")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701A2060")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701I1650TI")
+		|| dmi_match(DMI_BOARD_NAME, "POLARIS1701I2060")
+		|| dmi_match(DMI_BOARD_NAME, "GXxMRXx")
+		|| dmi_match(DMI_BOARD_NAME, "GXxHRXx")
+		|| dmi_match(DMI_BOARD_NAME, "XxHP4NAx")
+		|| dmi_match(DMI_BOARD_NAME, "XxKK4NAx_XxSP4NAx")
+		|| dmi_match(DMI_BOARD_NAME, "XxAR4NAx")
+
+		// Note: XMG Fusion removed for now, seem to have
+		// neither same power profile control nor TDP set
+		//|| dmi_match(DMI_BOARD_NAME, "LAPQC71A")
+		//|| dmi_match(DMI_BOARD_NAME, "LAPQC71B")
+		//|| dmi_match(DMI_PRODUCT_NAME, "A60 MUV")
+	;
+
+	uw_feats->uniwill_profile_v1_three_profs_leds_only = false
+	// Devices where profile mainly controls power profile LED status
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+		|| dmi_match(DMI_PRODUCT_SKU, "POLARIS1XA02")
+		|| dmi_match(DMI_PRODUCT_SKU, "POLARIS1XI02")
+		|| dmi_match(DMI_PRODUCT_SKU, "POLARIS1XA03")
+		|| dmi_match(DMI_PRODUCT_SKU, "POLARIS1XI03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XA03")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS1XI04")
+		|| dmi_match(DMI_PRODUCT_SKU, "STEPOL1XA04")
+#endif
+	;
+
+	uw_feats->uniwill_custom_profile_mode_needed = false
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I06")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS17I06")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS16I07")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLARIS16A07")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLSL15I06")
+		|| dmi_match(DMI_PRODUCT_SKU, "STELLSL15A06")
+		|| dmi_match(DMI_BOARD_NAME, "GXxMRXx")
+		|| dmi_match(DMI_BOARD_NAME, "GXxHRXx")
+		|| dmi_match(DMI_BOARD_NAME, "XxHP4NAx")
+		|| dmi_match(DMI_BOARD_NAME, "XxKK4NAx_XxSP4NAx")
+		|| dmi_match(DMI_BOARD_NAME, "X5KK45xS_X5SP45xS")
+#endif
+	;
+
+
+	if (has_double_pl4(&uw_feats->uniwill_has_double_pl4) != 0)
+		feats_loaded = false;
+
+	uw_feats->uniwill_profile_v1 =
+		uw_feats->uniwill_profile_v1_two_profs ||
+		uw_feats->uniwill_profile_v1_three_profs;
+
+	if (uw_has_charging_priority(&uw_feats->uniwill_has_charging_prio) != 0)
+		feats_loaded = false;
+	if (uw_has_charging_profile(&uw_feats->uniwill_has_charging_profile) != 0)
+		feats_loaded = false;
+	if (uw_has_ac_auto_boot(&uw_feats->uniwill_has_ac_auto_boot) != 0)
+		feats_loaded = false;
+	if (uw_has_usb_powershare(&uw_feats->uniwill_has_usb_powershare) != 0)
+		feats_loaded = false;
+	if (uw_has_mini_led_local_dimming(&uw_feats->uniwill_has_mini_led_local_dimming) != 0)
+		feats_loaded = false;
+
+	result = has_universal_ec_fan_control();
+	if (result < 0) {
+		feats_loaded = false;
+	} else {
+		uw_feats->uniwill_has_universal_ec_fan_control = (result == 1);
+	}
+
+
+	if (feats_loaded)
+		pr_debug("feats loaded\n");
+	else
+		pr_debug("feats not yet loaded\n");
+
+	uw_feats_loaded = feats_loaded;
+
+	return uw_feats;
+}
+EXPORT_SYMBOL(uniwill_get_device_features);
+
+// Fn lock
+
+static int uniwill_wmi_fn_lock_get(int *on)
+{
+	u8 data;
+	int err;
+
+	err = uniwill_read_ec_ram(UW_EC_REG_KBD_FN_LOCK_STATUS_BIT, &data);
+	if (err)
+		return err;
+
+	if (on)
+		*on = (data & UNIWILL_FN_LOCK_MASK) >> 4;
+
+	return 0;
+}
+
+static int uniwill_wmi_fn_lock_set(int on)
+{
+	u8 data;
+	int err;
+
+	// possible race condition
+	err = uniwill_read_ec_ram(UW_EC_REG_KBD_FN_LOCK_STATUS_BIT, &data);
+	if (err)
+		return err;
+
+	if (on)
+		data = data | UNIWILL_FN_LOCK_MASK;
+	else
+		data = data & ~UNIWILL_FN_LOCK_MASK;
+
+	err = uniwill_write_ec_ram(UW_EC_REG_KBD_FN_LOCK_STATUS_BIT, data);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static ssize_t uniwill_fn_lock_show(struct device *dev,
+		struct device_attribute *attr,
+		char *buf)
+{
+	int err, on;
+
+	err = uniwill_wmi_fn_lock_get(&on);
+	if (err)
+		return err;
+
+	return sprintf(buf, "%d\n", on);
+}
+
+static ssize_t uniwill_fn_lock_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int on, err;
+
+	if (kstrtoint(buf, 10, &on) ||
+			on < 0 || on > 1)
+		return -EINVAL;
+
+	err = uniwill_wmi_fn_lock_set(on);
+	if (err)
+		return err;
+
+	return size;
+}
+
+static bool uniwill_fn_lock_available(void){
+	int err, on;
+
+	// Fn lock does not work for XMG Fusion
+	// exclude all versions
+	if (dmi_match(DMI_BOARD_NAME, "LAPQC71A")
+	    || dmi_match(DMI_BOARD_NAME, "LAPQC71B")
+	    || dmi_match(DMI_PRODUCT_NAME, "A60 MUV")) {
+		return 0;
+	}
+
+	// do a read for test (this may not produce an error)
+	err = uniwill_wmi_fn_lock_get(&on);
+	if (err)
+		return 0;
+	else
+		return 1;
+}
+
+static u8 uniwill_touchp_toggle_seq[] = {
+	0xe0, 0x5b, // Super down
+	0x1d,       // Control down
+	0x76,       // Zenkaku/Hankaku down
+	0xf6,       // Zenkaku/Hankaku up
+	0x9d,       // Control up
+	0xe0, 0xdb  // Super up
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 14, 0)
+static bool uniwill_i8042_filter(unsigned char data, unsigned char str,
+				 struct serio *port __always_unused)
+#else
+static bool uniwill_i8042_filter(unsigned char data, unsigned char str,
+				 struct serio *port __always_unused,
+				 void *context __always_unused)
+#endif
+{
+	static u8 seq_pos;
+
+	if (unlikely(str & I8042_STR_AUXDATA))
+		return false;
+
+	if (unlikely(data == uniwill_touchp_toggle_seq[seq_pos])) {
+		++seq_pos;
+		if (unlikely(data == 0x76 || data == 0xf6))
+			return true;
+		else if (unlikely(seq_pos == ARRAY_SIZE(uniwill_touchp_toggle_seq))) {
+			schedule_work(&uniwill_key_event_work);
+			seq_pos = 0;
+		}
+		return false;
+	}
+
+	seq_pos = 0;
+	return false;
+}
+
+static int uniwill_keyboard_probe(struct platform_device *dev)
+{
+	u32 i;
+	u8 data;
+	int status;
+	struct uniwill_device_features_t *uw_feats;
+
+	set_rom_id();
+
+	uw_feats = uniwill_get_device_features();
+
+	// FIXME Hard set balanced profile until we have implemented a way to
+	// switch it while tuxedo_io is loaded
+	// uw_ec_write_addr(0x51, 0x07, 0x00, 0x00, &reg_write_return);
+	uniwill_write_ec_ram(0x0751, 0x00);
+
+	if (uw_feats->uniwill_profile_v1) {
+		// Set manual-mode fan-curve in 0x0743 - 0x0747
+		// Some kind of default fan-curve is stored in 0x0786 - 0x078a: Using it to initialize manual-mode fan-curve
+		for (i = 0; i < 5; ++i) {
+			uniwill_read_ec_ram(0x0786 + i, &data);
+			uniwill_write_ec_ram(0x0743 + i, data);
+		}
+	}
+
+	// Make sure custom TDP/custom fan curve mode is set. Using the
+	// custom profile mode flag to ID this set of devices.
+	uniwill_set_custom_profile_mode(true);
+
+	// Enable manual mode
+	uniwill_write_ec_ram(0x0741, 0x01);
+
+	// Zero second fan temp for detection
+	uniwill_write_ec_ram(0x044f, 0x00);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+	TUXEDO_ERROR("Warning: Kernel version less that 5.9, keyboard backlight might not be properly recognized.");
+#endif
+	uniwill_read_ec_ram(UW_EC_REG_KBD_BL_STATUS, &data);
+	uniwill_kbd_bl_enable_state_on_start = (data >> 1) & 0x01;
+	uniwill_leds_init(dev);
+	uniwill_write_kbd_bl_enable(1);
+
+	status = uw_lightbar_init(dev);
+	uw_lightbar_loaded = (status >= 0);
+
+	uw_charging_priority_init(dev);
+	uw_charging_profile_init(dev);
+	uw_ac_auto_boot_init(dev);
+	uw_usb_powershare_init(dev);
+	uw_mini_led_local_dimming_init(dev);
+
+	// Ignore return value, it just means there is already a filter active
+	// which is fine, because it is probably just the upstream patch of this
+	// filter.
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 14, 0)
+	if (i8042_install_filter(uniwill_i8042_filter))
+#else
+	if (i8042_install_filter(uniwill_i8042_filter, NULL))
+#endif
+		pr_info("Could not install i8042 filter.\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int uniwill_keyboard_remove(struct platform_device *dev)
+#else
+static void uniwill_keyboard_remove(struct platform_device *dev)
+#endif
+{
+	if (uw_charging_prio_loaded)
+		sysfs_remove_group(&dev->dev.kobj, &uw_charging_prio_attr_group);
+
+	if (uw_charging_profile_loaded)
+		sysfs_remove_group(&dev->dev.kobj, &uw_charging_profile_attr_group);
+
+	uniwill_leds_remove(dev);
+
+	// Restore previous backlight enable state
+	if (uniwill_kbd_bl_enable_state_on_start != 0xff) {
+		uniwill_write_kbd_bl_enable(uniwill_kbd_bl_enable_state_on_start);
+	}
+
+	if (uw_lightbar_loaded)
+		uw_lightbar_remove(dev);
+
+	// Disable manual mode
+	uniwill_write_ec_ram(0x0741, 0x00);
+
+	// Ignore return value, it just means this filter was not active atm.
+	if (i8042_remove_filter(uniwill_i8042_filter))
+		pr_info("Could not remove i8042 filter.\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static int uniwill_keyboard_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+	u8 data;
+	if (uw_feats->uniwill_custom_profile_mode_needed) {
+		// Unset "customer mode light" before suspend. Otherwise at
+		// least one device is known to immediately wake up.
+		uniwill_read_ec_ram(0x0727, &data);
+		data &= ~(1 << 6);
+		uniwill_write_ec_ram(0x0727, data);
+	}
+	uniwill_write_kbd_bl_enable(0);
+	return 0;
+}
+
+static int uniwill_keyboard_resume(struct platform_device *dev)
+{
+	struct uniwill_device_features_t *uw_feats = &uniwill_device_features;
+	u8 data;
+	if (uw_feats->uniwill_custom_profile_mode_needed) {
+		// Re-set "customer mode light" on resume
+		uniwill_read_ec_ram(0x0727, &data);
+		data |= (1 << 6);
+		uniwill_write_ec_ram(0x0727, data);
+	}
+	uniwill_leds_restore_state_extern();
+	uniwill_write_kbd_bl_enable(1);
+	return 0;
+}
+
+static struct platform_driver platform_driver_uniwill = {
+	.remove = uniwill_keyboard_remove,
+	.suspend = uniwill_keyboard_suspend,
+	.resume = uniwill_keyboard_resume,
+	.driver =
+		{
+			.name = DRIVER_NAME,
+			.owner = THIS_MODULE,
+		},
+};
+
+struct tuxedo_keyboard_driver uniwill_keyboard_driver = {
+	.platform_driver = &platform_driver_uniwill,
+	.probe = uniwill_keyboard_probe,
+	.key_map = uniwill_wmi_keymap,
+	.fn_lock_available = uniwill_fn_lock_available,
+	.fn_lock_show = uniwill_fn_lock_show,
+	.fn_lock_store = uniwill_fn_lock_store,
+};
+
+#endif // UNIWILL_KEYBOARD_H
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_leds.h linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_leds.h
--- linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_leds.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_leds.h	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,463 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*!
+ * Copyright (c) 2018-2020 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef UNIWILL_LEDS_H
+#define UNIWILL_LEDS_H
+
+#include <linux/platform_device.h>
+
+typedef enum {
+	UNIWILL_KB_BACKLIGHT_TYPE_NONE,
+	UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR,
+	UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS,
+	UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB,
+	UNIWILL_KB_BACKLIGHT_TYPE_PER_KEY_RGB
+} uniwill_kb_backlight_type_t;
+
+int uniwill_leds_init(struct platform_device *dev);
+int uniwill_leds_remove(struct platform_device *dev);
+
+uniwill_kb_backlight_type_t uniwill_leds_get_backlight_type_extern(void);
+void uniwill_leds_restore_state_extern(void);
+bool uniwill_leds_notify_brightness_change_extern(void);
+
+// TODO The following should go into a seperate .c file, but for this to work more reworking is required in the tuxedo_keyboard structure.
+
+//#include "uniwill_leds.h"
+
+#include <linux/types.h>
+#include <linux/leds.h>
+#include <linux/led-class-multicolor.h>
+#include "uniwill_interfaces.h"
+
+#define UNIWILL_KBD_BRIGHTNESS_MAX_WHITE		0x02
+#define UNIWILL_KBD_BRIGHTNESS_DEFAULT_WHITE		0x00
+
+#define UNIWILL_KBD_BRIGHTNESS_MAX_WHITE_5		0x04
+
+#define UNIWILL_KBD_BRIGHTNESS_MAX_1_ZONE_RGB		0x04
+#define UNIWILL_KBD_BRIGHTNESS_DEFAULT_1_ZONE_RGB	0x00
+
+#define UNIWILL_KBD_COLOR_DEFAULT_RED			0xff
+#define UNIWILL_KBD_COLOR_DEFAULT_GREEN			0xff
+#define UNIWILL_KBD_COLOR_DEFAULT_BLUE			0xff
+
+static uniwill_kb_backlight_type_t uniwill_kb_backlight_type = UNIWILL_KB_BACKLIGHT_TYPE_NONE;
+static u8 uniwill_barebone_id = 0;
+static bool uniwill_kbl_brightness_ec_controlled = false;
+static bool uw_leds_initialized = false;
+
+static int uniwill_write_kbd_bl_brightness(u8 brightness)
+{
+	int result = 0;
+	u8 data = 0;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_KBD_BL_STATUS, &data);
+	if (result)
+		return result;
+	data &= 0x0f; // lower bits must be preserved
+	data |= brightness << 5; // upper 2 to 3 bits encode brightness
+	data |= UW_EC_REG_KBD_BL_STATUS_SUBCMD_RESET; // "apply bit"
+	return uniwill_write_ec_ram(UW_EC_REG_KBD_BL_STATUS, data);
+}
+
+static int uniwill_write_kbd_bl_brightness_white_workaround(u8 brightness)
+{
+	int result = 0;
+	u8 data = 0;
+
+	// When keyboard backlight is off, new settings to 0x078c do not get applied automatically
+	// on Pulse Gen1/2 until next keypress or manual change to the 0x1808 immediate brightness
+	// value for some reason.
+	// Sidenote: IBP Gen6/7 has immediate brightness value on 0x1802 and not on 0x1808, but does
+	// not need this workaround. No model check required because this doesn't do anything on
+	// these devices.
+
+	result = uniwill_read_ec_ram(UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS_IMMEDIATE, &data);
+	if (result)
+		pr_debug("uniwill_write_kbd_bl_white(): Get UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS_IMMEDIATE failed.\n");
+
+	if (!data && brightness) {
+		result = uniwill_write_ec_ram(UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS_IMMEDIATE, 0x01);
+		if (result)
+			pr_debug("uniwill_write_kbd_bl_white(): Set UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS_IMMEDIATE failed.\n");
+	}
+
+	return uniwill_write_kbd_bl_brightness(brightness);
+}
+
+// Converts the range 0-255 to the range 0-50
+static int tf_convert_rgb_range(u8 input) {
+	return input*200/(255*4);
+}
+
+static int uniwill_write_kbd_bl_color(u8 red, u8 green, u8 blue)
+{
+	int result = 0;
+	u8 data = 0;
+
+	// If, after conversion, all three (red, green, and blue) values are zero at the same time,
+	// a special case is triggered in the EC and (probably device dependent) default values are
+	// written instead.
+
+	result = uniwill_write_ec_ram(UW_EC_REG_KBD_BL_RGB_RED_BRIGHTNESS, tf_convert_rgb_range(red));
+	if (result)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_KBD_BL_RGB_GREEN_BRIGHTNESS, tf_convert_rgb_range(green));
+	if (result)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_KBD_BL_RGB_BLUE_BRIGHTNESS, tf_convert_rgb_range(blue));
+	if (result)
+		return result;
+
+	result = uniwill_read_ec_ram(UW_EC_REG_KBD_BL_RGB_MODE, &data);
+	if (result)
+		return result;
+
+	result = uniwill_write_ec_ram(UW_EC_REG_KBD_BL_RGB_MODE, data | UW_EC_REG_KBD_BL_RGB_MODE_BIT_APPLY_COLOR);
+	if (result)
+		return result;
+
+	pr_debug("Wrote kbd color [%0#4x, %0#4x, %0#4x]\n", red, green, blue);
+
+	return result;
+}
+
+static void uniwill_leds_set_brightness(struct led_classdev *led_cdev __always_unused, enum led_brightness brightness) {
+	int result = 0;
+
+	result = uniwill_write_kbd_bl_brightness_white_workaround(brightness);
+	if (result) {
+		pr_debug("uniwill_leds_set_brightness(): uniwill_write_kbd_bl_white() failed\n");
+		return;
+	}
+
+	led_cdev->brightness = brightness;
+}
+
+static void uniwill_leds_set_brightness_mc(struct led_classdev *led_cdev, enum led_brightness brightness) {
+	int result = 0;
+	struct led_classdev_mc *mcled_cdev = lcdev_to_mccdev(led_cdev);
+
+	if (mcled_cdev->subled_info[0].intensity == 0 &&
+	    mcled_cdev->subled_info[1].intensity == 0 &&
+	    mcled_cdev->subled_info[2].intensity == 0) {
+		pr_debug("uniwill_leds_set_brightness_mc(): Trigger RGB 0x000000 special case\n");
+		result = uniwill_write_kbd_bl_brightness(0);
+		if (result) {
+			pr_debug("uniwill_leds_set_brightness_mc(): uniwill_write_kbd_bl_brightness() failed\n");
+			return;
+		}
+	}
+	else {
+		result = uniwill_write_kbd_bl_color(mcled_cdev->subled_info[0].intensity,
+					       mcled_cdev->subled_info[1].intensity,
+					       mcled_cdev->subled_info[2].intensity);
+		if (result) {
+			pr_debug("uniwill_leds_set_brightness_mc(): uniwill_write_kbd_bl_rgb() failed\n");
+			return;
+		}
+
+		result = uniwill_write_kbd_bl_brightness(brightness);
+		if (result) {
+			pr_debug("uniwill_leds_set_brightness_mc(): uniwill_write_kbd_bl_brightness() failed\n");
+			return;
+		}
+	}
+
+	led_cdev->brightness = brightness;
+}
+
+static struct led_classdev uniwill_led_cdev = {
+	.name = "white:" LED_FUNCTION_KBD_BACKLIGHT,
+	.max_brightness = UNIWILL_KBD_BRIGHTNESS_MAX_WHITE,
+	.brightness_set = &uniwill_leds_set_brightness,
+	.brightness = UNIWILL_KBD_BRIGHTNESS_DEFAULT_WHITE,
+};
+
+static struct mc_subled uw_mcled_cdev_subleds[3] = {
+	{
+		.color_index = LED_COLOR_ID_RED,
+		.intensity = UNIWILL_KBD_COLOR_DEFAULT_RED,
+		.channel = 0
+	},
+	{
+		.color_index = LED_COLOR_ID_GREEN,
+		.intensity = UNIWILL_KBD_COLOR_DEFAULT_GREEN,
+		.channel = 0
+	},
+	{
+		.color_index = LED_COLOR_ID_BLUE,
+		.intensity = UNIWILL_KBD_COLOR_DEFAULT_BLUE,
+		.channel = 0
+	}
+};
+
+static struct led_classdev_mc uniwill_mcled_cdev = {
+	.led_cdev.name = "rgb:" LED_FUNCTION_KBD_BACKLIGHT,
+	.led_cdev.max_brightness = UNIWILL_KBD_BRIGHTNESS_MAX_1_ZONE_RGB,
+	.led_cdev.brightness_set = &uniwill_leds_set_brightness_mc,
+	.led_cdev.brightness = UNIWILL_KBD_BRIGHTNESS_DEFAULT_1_ZONE_RGB,
+	.num_colors = 3,
+	.subled_info = uw_mcled_cdev_subleds
+};
+
+static const struct dmi_system_id force_no_ec_led_control[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "STELLARIS1XA05"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "STELLSL15I06"),
+		},
+	},
+	{ }
+};
+
+static const struct dmi_system_id kbl_type_fixed_color_5_levels[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_NAME, "GXxHRXx"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_NAME, "GXxMRXx"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_NAME, "XxHP4NAx"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_NAME, "XxKK4NAx_XxSP4NAx"),
+		},
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "TUXEDO"),
+			DMI_MATCH(DMI_BOARD_NAME, "XxAR4NAx"),
+		},
+	},
+	{ }
+};
+
+int uniwill_leds_init(struct platform_device *dev)
+{
+	int result = 0, i = 0;
+	u8 data = 0;
+
+	for (i = 0; i < 3; ++i) {
+		if (i) {
+			pr_err("Reading barebone ID failed. Retrying ...\n");
+		}
+
+		result = uniwill_read_ec_ram(UW_EC_REG_BAREBONE_ID, &uniwill_barebone_id);
+		if (!result && uniwill_barebone_id) {
+			break;
+		}
+		msleep(200);
+	}
+	if (result || !uniwill_barebone_id) {
+		pr_err("Reading barebone ID failed.\n");
+		return result;
+	}
+	pr_debug("EC Barebone ID: %#04x\n", uniwill_barebone_id);
+
+	// Some devices need this bit set for the keyboard backlight
+	// to be controllable by the driver. On some devices, it's
+	// set by default, but on some it's not enabled under certain
+	// conditions, so we make sure it's always set.
+	// Known affected devices:
+	// - IBP Gen7-9
+	// - Polaris Gen4-5
+	uniwill_read_ec_ram(UW_EC_REG_FEATURES_1, &data);
+	data |= UW_EC_REG_FEATURES_1_BIT_FIXED_COLOR_5_ENABLE;
+	uniwill_write_ec_ram(UW_EC_REG_FEATURES_1, data);
+
+	if (dmi_check_system(force_no_ec_led_control)) {
+		pr_debug("Skip uniwill_kb_backlight_type checks because of quirk.\n");
+	}
+	else if (uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PFxxxxx ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PFxMxxx ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH4TRX1 ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH4TUX1 ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH4TQx1 ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH6TRX1 ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH6TQxx ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH4Axxx ||
+		 uniwill_barebone_id == UW_EC_REG_BAREBONE_ID_VALUE_PH4Pxxx) {
+		uniwill_kb_backlight_type = UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR;
+		uniwill_kbl_brightness_ec_controlled = true;
+	}
+	else if (dmi_check_system(kbl_type_fixed_color_5_levels)) {
+		uniwill_kb_backlight_type = UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS;
+		uniwill_kbl_brightness_ec_controlled = true;
+	}
+	else {
+		result = uniwill_read_ec_ram(UW_EC_REG_FEATURES_1, &data);
+		if (result) {
+			pr_err("Reading features 1 failed.\n");
+			return result;
+		}
+		pr_debug("UW_EC_REG_FEATURES_1: 0x%02x\n", data);
+
+		if (data & UW_EC_REG_FEATURES_1_BIT_1_ZONE_RGB_KB) {
+			uniwill_kb_backlight_type = UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB;
+			uniwill_kbl_brightness_ec_controlled = true;
+		}
+	}
+	pr_debug("Keyboard backlight type: 0x%02x\n", uniwill_kb_backlight_type);
+
+	if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR) {
+		pr_debug("Registering fixed color leds interface\n");
+		if (uniwill_kbl_brightness_ec_controlled)
+			uniwill_led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+		result = led_classdev_register(&dev->dev, &uniwill_led_cdev);
+		if (result) {
+			pr_err("Registering fixed color leds interface failed\n");
+			return result;
+		}
+	}
+	else if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS) {
+		pr_debug("Registering fixed color 5 levels leds interface\n");
+		uniwill_led_cdev.max_brightness = UNIWILL_KBD_BRIGHTNESS_MAX_WHITE_5;
+		if (uniwill_kbl_brightness_ec_controlled)
+			uniwill_led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+		result = led_classdev_register(&dev->dev, &uniwill_led_cdev);
+		if (result) {
+			pr_err("Registering fixed color 5 levels leds interface failed\n");
+			return result;
+		}
+	}
+	else if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		pr_debug("Registering single zone rgb leds interface\n");
+		if (uniwill_kbl_brightness_ec_controlled)
+			uniwill_mcled_cdev.led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+		result = devm_led_classdev_multicolor_register(&dev->dev, &uniwill_mcled_cdev);
+		if (result) {
+			pr_err("Registering single zone rgb leds interface failed\n");
+			return result;
+		}
+	}
+
+	uw_leds_initialized = true;
+
+	return 0;
+}
+EXPORT_SYMBOL(uniwill_leds_init);
+
+int uniwill_leds_remove(struct platform_device *dev)
+{
+	int result = 0;
+
+	if (uw_leds_initialized) {
+		uw_leds_initialized = false;
+
+		if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR ||
+		    uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS) {
+			led_classdev_unregister(&uniwill_led_cdev);
+		}
+		else if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+			devm_led_classdev_multicolor_unregister(&dev->dev, &uniwill_mcled_cdev);
+		}
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(uniwill_leds_remove);
+
+uniwill_kb_backlight_type_t uniwill_leds_get_backlight_type_extern(void) {
+	return uniwill_kb_backlight_type;
+}
+EXPORT_SYMBOL(uniwill_leds_get_backlight_type_extern);
+
+void uniwill_leds_restore_state_extern(void) {
+	if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR ||
+	    uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS) {
+		if (uniwill_write_kbd_bl_brightness_white_workaround(uniwill_led_cdev.brightness)) {
+			pr_debug("uniwill_leds_restore_state_extern(): uniwill_write_kbd_bl_white() failed\n");
+		}
+	}
+	else if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+		if (uniwill_write_kbd_bl_color(uniwill_mcled_cdev.subled_info[0].intensity,
+					     uniwill_mcled_cdev.subled_info[1].intensity,
+					     uniwill_mcled_cdev.subled_info[2].intensity)) {
+			pr_debug("uniwill_leds_restore_state_extern(): uniwill_write_kbd_bl_rgb() failed\n");
+		}
+		if (uniwill_write_kbd_bl_brightness(uniwill_mcled_cdev.led_cdev.brightness)) {
+			pr_debug("uniwill_leds_restore_state_extern(): uniwill_write_kbd_bl_brightness() failed\n");
+		}
+	}
+}
+EXPORT_SYMBOL(uniwill_leds_restore_state_extern);
+
+bool uniwill_leds_notify_brightness_change_extern(void) {
+	int result = 0;
+	u8 data = 0, brightness = 0;
+
+	if (uw_leds_initialized) {
+		if (uniwill_kbl_brightness_ec_controlled) {
+			uniwill_read_ec_ram(UW_EC_REG_KBD_BL_STATUS, &data);
+			brightness = (data >> 5) & 0x07;
+			if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR ||
+			    uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_FIXED_COLOR_5_LEVELS) {
+				uniwill_led_cdev.brightness = brightness;
+				led_classdev_notify_brightness_hw_changed(&uniwill_led_cdev, uniwill_led_cdev.brightness);
+				return true;
+			}
+			else if (uniwill_kb_backlight_type == UNIWILL_KB_BACKLIGHT_TYPE_1_ZONE_RGB) {
+				result = 0;
+				if (uniwill_mcled_cdev.led_cdev.brightness == brightness) {
+					// Workaround for devices where EC does not react to FN+space in manual mode (know device: Polaris Gen2)
+					result = uniwill_write_kbd_bl_brightness((brightness + 1) % 5);
+					if (result) {
+						pr_debug("uniwill_leds_set_brightness_mc(): uniwill_write_kbd_bl_brightness() failed\n");
+					}
+					else {
+						brightness = (brightness + 1) % 5;
+					}
+				}
+				if (!result) {
+					uniwill_mcled_cdev.led_cdev.brightness = brightness;
+					led_classdev_notify_brightness_hw_changed(&uniwill_mcled_cdev.led_cdev, uniwill_mcled_cdev.led_cdev.brightness);
+				}
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+MODULE_LICENSE("GPL");
+
+#endif // UNIWILL_LEDS_H
diff -rupN linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_wmi.c linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_wmi.c
--- linux-6.17.13/drivers/platform/x86/tuxedo/uniwill_wmi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-6.17.13_tuxedo/drivers/platform/x86/tuxedo/uniwill_wmi.c	2025-12-16 23:32:05.000000000 +0100
@@ -0,0 +1,423 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*!
+ * Copyright (c) 2021 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ *
+ * This file is part of tuxedo-drivers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, see <https://www.gnu.org/licenses/>.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/acpi.h>
+#include <linux/module.h>
+#include <linux/wmi.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include "uniwill_interfaces.h"
+
+#define UNIWILL_EC_REG_LDAT	0x8a
+#define UNIWILL_EC_REG_HDAT	0x8b
+#define UNIWILL_EC_REG_FLAGS	0x8c
+#define UNIWILL_EC_REG_CMDL	0x8d
+#define UNIWILL_EC_REG_CMDH	0x8e
+
+#define UNIWILL_EC_BIT_RFLG	0
+#define UNIWILL_EC_BIT_WFLG	1
+#define UNIWILL_EC_BIT_BFLG	2
+#define UNIWILL_EC_BIT_CFLG	3
+#define UNIWILL_EC_BIT_DRDY	7
+
+#define UW_EC_BUSY_WAIT_CYCLES	30
+#define UW_EC_BUSY_WAIT_DELAY	15
+
+static bool uniwill_ec_direct = false;
+
+DEFINE_MUTEX(uniwill_ec_lock);
+
+/*
+ * Currently known functions for this are:
+ * 0: Write via WMI
+ * 1: Read via WMI
+ * 5: Apparently used for toggling features. Currently only used for toggling
+ * the NB02 local dimming feature (only possible via WMI). It is unclear what
+ * other functionalities this might have.
+ */
+static int uw_wmi_ec_evaluate(u8 function, u32 arg, u32 *return_buffer)
+{
+	acpi_status status;
+	union acpi_object *out_acpi;
+	int e_result = 0;
+
+	// Kernel buffer for input argument
+	u32 *wmi_arg = (u32 *) kmalloc(sizeof(u32)*10, GFP_KERNEL);
+	// Byte reference to the input buffer
+	u8 *wmi_arg_bytes = (u8 *) wmi_arg;
+
+	u8 wmi_instance = 0x00;
+	u32 wmi_method_id = 0x04;
+	struct acpi_buffer wmi_in = { (acpi_size) sizeof(wmi_arg), wmi_arg};
+	struct acpi_buffer wmi_out = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	mutex_lock(&uniwill_ec_lock);
+
+	// Zero input buffer
+	memset(wmi_arg, 0x00, 10 * sizeof(u32));
+
+	// Configure input buffer
+	memcpy(&wmi_arg_bytes[0], &arg, sizeof(arg));
+
+	wmi_arg_bytes[5] = function;
+
+	status = wmi_evaluate_method(UNIWILL_WMI_MGMT_GUID_BC, wmi_instance, wmi_method_id, &wmi_in, &wmi_out);
+	out_acpi = (union acpi_object *) wmi_out.pointer;
+
+	if (out_acpi && out_acpi->type == ACPI_TYPE_BUFFER) {
+		memcpy(return_buffer, out_acpi->buffer.pointer, out_acpi->buffer.length);
+	} /* else if (out_acpi && out_acpi->type == ACPI_TYPE_INTEGER) {
+		e_result = (u32) out_acpi->integer.value;
+	}*/
+	if (ACPI_FAILURE(status)) {
+		pr_err("uniwill_wmi.h: Error evaluating method\n");
+		e_result = -EIO;
+	}
+
+	kfree(out_acpi);
+	kfree(wmi_arg);
+
+	mutex_unlock(&uniwill_ec_lock);
+
+	return e_result;
+}
+
+/**
+ * EC address read through WMI
+ */
+static int uw_ec_read_addr_wmi(u8 addr_low, u8 addr_high, union uw_ec_read_return *output)
+{
+	u32 uw_data[10];
+	u32 arg = ((u32)addr_high << 8) | ((u32)addr_low);
+
+	int ret = uw_wmi_ec_evaluate(UNIWILL_WMI_FUNCTION_READ, arg, uw_data);
+	output->dword = uw_data[0];
+
+	if (output->dword == 0xfefefefe) {
+		pr_err("WMI read error: 0x%02x%02x, data: %0#4x\n", addr_high, addr_low, output->bytes.data_low);
+		ret = -EIO;
+	}
+
+	// pr_debug("addr: 0x%02x%02x value: %0#4x (high: %0#4x) result: %d\n", addr_high, addr_low, output->bytes.data_low, output->bytes.data_high, ret);
+	return ret;
+}
+
+/**
+ * EC address write through WMI
+ */
+static int uw_ec_write_addr_wmi(u8 addr_low, u8 addr_high, u8 data_low, u8 data_high, union uw_ec_write_return *output)
+{
+	u32 uw_data[10];
+	u32 arg = ((u32)data_high << 24) | ((u32)data_low << 16) |
+		  ((u32)addr_high << 8) | ((u32)addr_low);
+
+	int ret = uw_wmi_ec_evaluate(UNIWILL_WMI_FUNCTION_WRITE, arg, uw_data);
+	output->dword = uw_data[0];
+
+	if (output->dword == 0xfefefefe) {
+		pr_err("WMI write error, addr: 0x%02x%02x, data: %0#4x\n", addr_high, addr_low, data_low);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+/**
+ * Direct EC address read
+ */
+static int uw_ec_read_addr_direct(u8 addr_low, u8 addr_high, union uw_ec_read_return *output)
+{
+	int result;
+	int count;
+	u8 tmp, flags;
+	bool ready;
+	bool bflag = false;
+
+	mutex_lock(&uniwill_ec_lock);
+
+	ec_read(UNIWILL_EC_REG_FLAGS, &flags);
+	if ((flags & (1 << UNIWILL_EC_BIT_BFLG)) > 0) {
+		pr_debug("read: BFLG set\n");
+		bflag = true;
+	}
+
+	flags |= (1 << UNIWILL_EC_BIT_BFLG);
+	ec_write(UNIWILL_EC_REG_FLAGS, flags);
+
+	ec_write(UNIWILL_EC_REG_LDAT, addr_low);
+	ec_write(UNIWILL_EC_REG_HDAT, addr_high);
+
+	flags &= ~(1 << UNIWILL_EC_BIT_DRDY);
+	flags |= (1 << UNIWILL_EC_BIT_RFLG);
+	ec_write(UNIWILL_EC_REG_FLAGS, flags);
+
+	// Wait for ready flag
+	count = UW_EC_BUSY_WAIT_CYCLES;
+	ready = false;
+	while (!ready && count != 0) {
+		msleep(UW_EC_BUSY_WAIT_DELAY);
+		ec_read(UNIWILL_EC_REG_FLAGS, &tmp);
+		ready = (tmp & (1 << UNIWILL_EC_BIT_DRDY)) != 0;
+		count -= 1;
+	}
+
+	if (count != 0) {
+		output->dword = 0;
+		ec_read(UNIWILL_EC_REG_CMDL, &tmp);
+		output->bytes.data_low = tmp;
+		ec_read(UNIWILL_EC_REG_CMDH, &tmp);
+		output->bytes.data_high = tmp;
+		result = 0;
+	} else {
+		pr_err("uw ec read timeout, addr: 0x%02x%02x\n", addr_high, addr_low);
+		output->dword = 0xfefefefe;
+		result = -EIO;
+	}
+
+	ec_write(UNIWILL_EC_REG_FLAGS, 0x00);
+
+	mutex_unlock(&uniwill_ec_lock);
+
+	if (bflag)
+		pr_debug("addr: 0x%02x%02x value: %0#4x result: %d\n", addr_high, addr_low, output->bytes.data_low, result);
+
+	if ((UW_EC_BUSY_WAIT_CYCLES - count) > 1)
+		pr_debug("read wait count: %i", (UW_EC_BUSY_WAIT_CYCLES - count));
+
+	// pr_debug("addr: 0x%02x%02x value: %0#4x result: %d\n", addr_high, addr_low, output->bytes.data_low, result);
+
+	return result;
+}
+
+static int uw_ec_write_addr_direct(u8 addr_low, u8 addr_high, u8 data_low, u8 data_high, union uw_ec_write_return *output)
+{
+	int result = 0;
+	int count;
+	u8 tmp, flags;
+	bool ready;
+	bool bflag = false;
+
+	mutex_lock(&uniwill_ec_lock);
+
+	ec_read(UNIWILL_EC_REG_FLAGS, &flags);
+	if ((flags & (1 << UNIWILL_EC_BIT_BFLG)) > 0) {
+		pr_debug("write: BFLG set\n");
+		bflag = true;
+	}
+
+	flags |= (1 << UNIWILL_EC_BIT_BFLG);
+	ec_write(UNIWILL_EC_REG_FLAGS, flags);
+
+	ec_write(UNIWILL_EC_REG_LDAT, addr_low);
+	ec_write(UNIWILL_EC_REG_HDAT, addr_high);
+	ec_write(UNIWILL_EC_REG_CMDL, data_low);
+	ec_write(UNIWILL_EC_REG_CMDH, data_high);
+
+	flags &= ~(1 << UNIWILL_EC_BIT_DRDY);
+	flags |= (1 << UNIWILL_EC_BIT_WFLG);
+	ec_write(UNIWILL_EC_REG_FLAGS, flags);
+
+	// Wait for ready flag
+	count = UW_EC_BUSY_WAIT_CYCLES;
+	ready = false;
+	while (!ready && count != 0) {
+		msleep(UW_EC_BUSY_WAIT_DELAY);
+		ec_read(UNIWILL_EC_REG_FLAGS, &tmp);
+		ready = (tmp & (1 << UNIWILL_EC_BIT_DRDY)) != 0;
+		count -= 1;
+	}
+
+	// Replicate wmi output depending on success
+	if (count != 0) {
+		output->bytes.addr_low = addr_low;
+		output->bytes.addr_high = addr_high;
+		output->bytes.data_low = data_low;
+		output->bytes.data_high = data_high;
+		result = 0;
+	} else {
+		pr_err("uw ec write timeout, addr: 0x%02x%02x, value: %0#4x\n", addr_high, addr_low, data_low);
+		output->dword = 0xfefefefe;
+		result = -EIO;
+	}
+
+	ec_write(UNIWILL_EC_REG_FLAGS, 0x00);
+
+	if (bflag)
+		pr_debug("addr: 0x%02x%02x value: %0#4x result: %d\n", addr_high, addr_low, data_low, result);
+
+	if ((UW_EC_BUSY_WAIT_CYCLES - count) > 1)
+		pr_debug("write wait count: %i", (UW_EC_BUSY_WAIT_CYCLES - count));
+
+	mutex_unlock(&uniwill_ec_lock);
+
+	return result;
+}
+
+static int uw_wmi_read_ec_ram(u16 addr, u8 *data)
+{
+	int result;
+	u8 addr_low, addr_high;
+	union uw_ec_read_return output;
+
+	if (IS_ERR_OR_NULL(data))
+		return -EINVAL;
+
+	addr_low = addr & 0xff;
+	addr_high = (addr >> 8) & 0xff;
+
+	if (uniwill_ec_direct) {
+		result = uw_ec_read_addr_direct(addr_low, addr_high, &output);
+	} else {
+		result = uw_ec_read_addr_wmi(addr_low, addr_high, &output);
+	}
+
+	*data = output.bytes.data_low;
+	return result;
+}
+
+static int uw_wmi_write_ec_ram(u16 addr, u8 data)
+{
+	int result;
+	u8 addr_low, addr_high, data_low, data_high;
+	union uw_ec_write_return output;
+
+	addr_low = addr & 0xff;
+	addr_high = (addr >> 8) & 0xff;
+	data_low = data;
+	data_high = 0x00;
+
+	if (uniwill_ec_direct)
+		result = uw_ec_write_addr_direct(addr_low, addr_high, data_low, data_high, &output);
+	else
+		result = uw_ec_write_addr_wmi(addr_low, addr_high, data_low, data_high, &output);
+
+	return result;
+}
+
+struct uniwill_interface_t uniwill_wmi_interface = {
+	.string_id = UNIWILL_INTERFACE_WMI_STRID,
+	.read_ec_ram = uw_wmi_read_ec_ram,
+	.write_ec_ram = uw_wmi_write_ec_ram,
+	.wmi_evaluate = uw_wmi_ec_evaluate
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+static int uniwill_wmi_probe(struct wmi_device *wdev)
+#else
+static int uniwill_wmi_probe(struct wmi_device *wdev, const void *dummy_context)
+#endif
+{
+	int status;
+
+	// Look for for GUIDs used on uniwill devices
+	status =
+		wmi_has_guid(UNIWILL_WMI_EVENT_GUID_0) &&
+		wmi_has_guid(UNIWILL_WMI_EVENT_GUID_1) &&
+		wmi_has_guid(UNIWILL_WMI_EVENT_GUID_2) &&
+		wmi_has_guid(UNIWILL_WMI_MGMT_GUID_BA) &&
+		wmi_has_guid(UNIWILL_WMI_MGMT_GUID_BB) &&
+		wmi_has_guid(UNIWILL_WMI_MGMT_GUID_BC);
+	
+	if (!status) {
+		pr_debug("probe: At least one Uniwill GUID missing\n");
+		return -ENODEV;
+	}
+
+	uniwill_add_interface(&uniwill_wmi_interface);
+
+	pr_info("interface initialized\n");
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+static int uniwill_wmi_remove(struct wmi_device *wdev)
+#else
+static void uniwill_wmi_remove(struct wmi_device *wdev)
+#endif
+{
+	pr_debug("uniwill_wmi driver remove\n");
+	uniwill_remove_interface(&uniwill_wmi_interface);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 13, 0)
+	return 0;
+#endif
+}
+
+static void uniwill_wmi_notify(struct wmi_device *wdev, union acpi_object *obj)
+{
+	u32 code;
+
+	if (!IS_ERR_OR_NULL(uniwill_wmi_interface.event_callb)) {
+		if (obj) {
+			if (obj->type == ACPI_TYPE_INTEGER) {
+				code = obj->integer.value;
+				// Execute registered callback
+				uniwill_wmi_interface.event_callb(code);
+			} else {
+				pr_debug("unknown event type - %d (%0#6x)\n", obj->type, obj->type);
+			}
+		} else {
+			pr_debug("expected ACPI object doesn't exist\n");
+		}
+	} else {
+		pr_debug("no registered callback\n");
+	}
+}
+
+static const struct wmi_device_id uniwill_wmi_device_ids[] = {
+	// Listing one should be enough, for a driver that "takes care of all anyways"
+	// also prevents probe (and handling) per "device"
+	{ .guid_string = UNIWILL_WMI_EVENT_GUID_2 },
+	{ }
+};
+
+static struct wmi_driver uniwill_wmi_driver = {
+	.driver = {
+		.name = UNIWILL_INTERFACE_WMI_STRID,
+		.owner = THIS_MODULE
+	},
+	.id_table = uniwill_wmi_device_ids,
+	.probe = uniwill_wmi_probe,
+	.remove = uniwill_wmi_remove,
+	.notify = uniwill_wmi_notify,
+};
+
+module_wmi_driver(uniwill_wmi_driver);
+
+MODULE_AUTHOR("TUXEDO Computers GmbH <tux@tuxedocomputers.com>");
+MODULE_DESCRIPTION("Driver for Uniwill WMI interface");
+MODULE_LICENSE("GPL");
+
+/*
+ * If set to true, the module will use the replicated WMI functions
+ * (direct ec_read/ec_write) to read and write to the EC RAM instead
+ * of the original (WMI).
+ *
+ * The original functions didn't use to be
+ * preferred since they use large delays in the I/O loop. However,
+ * they have proven to be more stable and are therefore set as
+ * the current default.
+ */
+module_param_cb(ec_direct_io, &param_ops_bool, &uniwill_ec_direct, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);
+MODULE_PARM_DESC(ec_direct_io, "Do not use WMI methods to read/write EC RAM (default: false).");
+
+MODULE_DEVICE_TABLE(wmi, uniwill_wmi_device_ids);
+MODULE_ALIAS_UNIWILL_WMI();
